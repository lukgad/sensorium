<?xml version="1.0"?>
<doc>
    <assembly>
        <name>wx.NET</name>
    </assembly>
    <members>
        <member name="T:wx.Event">
            <summary>The class of  wxWidgets events.</summary>
        </member>
        <member name="T:wx.Object">
            <summary>This is the base class of all <c>wxWidgets</c> objects. This class manages pointers to C++ objects.
             </summary>
             <remarks>
             When wrapping C++ to be used in modern OO programming languages like C# or JAVA, the main
             difficulties arise from the different object model. On C++ instances are structs. In most
             other languages (keeping ancient things like Simula 1967 aside) instances are references
             to structs. C++ knows a lot of modifiers for data types without correlation in C#.
             One of the most problematic thing is wrapping <c>const</c> <c>wxObject &amp;</c> results from selectors.
             Requirements:
             \li Since most  wx.NET wrappers provide the full of  wxWidgets objects, the  wx.NET
                 generates many instances to generate independent objects. This is for instances the case
                 with strings (class wx.wxString). In these cases  wx.NET will take ownership of the
                 new object and destroy it on disposing the  wx.NET wrapper.
             \li Another option that is used in some rare cases is to wrap the pointer of a const referenced
                 object into a wrapper that does not provide any opportunity to modify the represented value.
                 Problem: One needs wrappers without any modifiers. Prerequisite:  wxWidgets continues to
                 have full ownership of the referenced memory but  wx.NET is preferred to reuse a wrapper
                 instance. So, this class as a static container of all generated members of this kind.
                 This container can be searched by method wx.Object.FindObject(). Problem: Garbage collection will never
                 destroy the wrapper instances. So, this functon can be turned off using enumeration
                 <c>StorageMode.VolatileObject</c>. In these case the C++ object usually receives a callback to
                 be used on destruction to delete all references of the .NET wrapper to the deleted C++ object.
                 Please keep also in mind, that using wx.Object.FindObject() usually means tha one wants to find
                 a previous wrapper on an instance retrieved from C++. So, this instance is likely to be destroyed
                 by the C++ implementation and not by the .NET wrapper. Consequently, you have to deactivate wx.Object.memOwn.
             \li A rare specialization of the previous case: Since the  wxWidgets object does not provide the opportunity
                 to call back on destruction, the object will be deleted on destroying the  wxWidgets container that probably
                 hold the object. Consider wx.HtmlBookRecord and wx.HtmlBookRecords as examples.
             \li The standard defensive way is to use both: New instances owned by  wx.NET plus static container
                 of instances.
             \li Refer to wx.Object.DllSync. Use this object to synchronze calls to the <c>wx-c</c> DLL at least
                 if these calls create new C++ objects or delete them.
             \li Usually, you will use FindObject() to identify preexisting wrappers for pointers to
                 C++ instances of <c>wxObject</c>. This method may also serve as a factory for wrappers if you
                 know the  wx.NET class of this new wrapper. If you don't know the class that shall be used
                 for the creation of wrappers, you have the option to use the interface to the  wxWidgets
                 RTTI. Refer to the remarks on wx.Object.ClassInfo.
             
             Classes wrapping a class implementing a non-virtual desctructor have to implement
             their own Dispose() method. Most of the other needs for managing C++ pointers are
             satisfied by this class.
             
             AddObject() and RemoveObject() implement a data base containing all wrappers to C++ pointers.
             So, methods receiving a pointer to a already wrapped object can retrieve this preexisting wrapper
             and reuse it by FindObject().
             
             More elaborate classes do not wrap the original  wxWidgets object but a C++ wrapper informing
             wx.NET on deallocating the  wxWidgets object. Usually, such wrappers receive a delegate of type
             Virtual_Dispose() that calls VirtualDispose().  Please  note  whenever  passing  delegates  to  C++
              objects: Load class member variables with these delegates in order to prevent undesired disposal
             of the delegates. This class offers member variable virtual_Dispose() to store the delegate
             of type Virtual_Dispose().  Please  note, that some  wxWidgets classes like <c>wxString</c> or
             <c>wxArrayString</c> have non-virtual destructors that, nevertheless, must run on destruction. So,
             adding callbacks on destruction is not applicable to all  wxWidget classes.
             File <c>local_events.h</c> in the <c>wx-c</c> directory of the sources contains some support for callbacks
             on desctruction and some other frequent cases on wrapping.
             
             Contributors should also not forget to initialize all callbacks to NULL on construction and to
             call only callbacks which are not NULL. This is important to achieve reliant code - it is important
             that instances with callbacks also run before these callbacks have been registered.
            </remarks>
        </member>
        <member name="F:wx.Object.objects">
            <summary>Hashtable to associate C++ objects with C# references</summary>
        </member>
        <member name="F:wx.Object.memOwn">
            <summary>memOwn is true when we create a new instance with the wrapper ctor
            		 or if a call to a wrapper function returns new c++ instance.
            		 Otherwise the created c++ object won't be deleted by the Dispose member.
                     
                     This member will now usually be set explicitely or depending on the StorageMode.</summary>
        </member>
        <member name="M:wx.Object.#ctor(System.IntPtr,wx.Object.StorageMode)">
            <summary>Default construction for objects of defined storage mode but with default memory ownership.
            wx.Object.StorageMode.VolatileObject will be allocated with memory ownership.
            Registered Objects will usually be allocated without memory ownership.</summary>
        </member>
        <member name="M:wx.Object.GetTranslation(System.Type)">
            <summary>This will return a translation of the type name.</summary>
            <remarks>Translations of types may be useful if the type represent a notion in the real world that has a name.
            For instance, wx.Font represents fonts. "Font" is a human readable name. If you want to print information on an
            object <c>o</c> - what kind of object is this - you might use wx.Object.GetTranslation(o.GetType()).
            
            Types may either provide a human readable name as defined by a wx.Globalization.TypeNameTranslationsAttribute attribute.
            Or they are translated by a \e gettext catalogue. This method will first search for a translation of the full qualified
            name. Then, this will search for a translation of the short type name.
            
            This will return a translation into the current wx.Locale.Language.</remarks>
        </member>
        <member name="M:wx.Object.GetTranslation(System.Enum)">
            <summary>This will translate the provided enumeration value.</summary>
            <remarks>
            You have two options to translate enumeration values.
            The enumeration might provide attributes of type wx.Globalization.EnumValueTranslations. If present, these
            will be used for translation first.
            However, if this fails, this will query the known \c gettext catalogs for a string \c "namespace.enumeration_type.enumeration_value".
            If this query fails, this will simply return \c "enumeration_value". Use tool \c getenums.exe to load
            enumeration values of an assembly into a gettext POT file.
            
            All translations will be done into the current \c wx.Locale.Language.
            </remarks>
        </member>
        <member name="M:wx.Object.GetTranslation(System.String)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:wx.Object.GetTranslation(wx.wxString)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:wx.Object._(System.String)">
            <summary>This will translate <c>str</c> into the currently selected locale.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:wx.Object._(System.Type)">
            <summary>This will return a translation of the type name.</summary>
            <remarks>Translations of types may be useful if the type represent a notion in the real world that has a name.
            For instance, wx.Font represents fonts. "Font" is a human readable name. If you want to print information on an
            object <c>o</c> - what kind of object is this - you might use wx.Object.GetTranslation(o.GetType()).
            
            Types may either provide a human readable name as defined by a wx.Globalization.TypeNameTranslationsAttribute attribute.
            Or they are translated by a gettext catalogue. This method will first search for a translation of the full qualified
            name. Then, this will search for a translation of the short type name.
            
            This will return a translation into the current wx.Locale.Language.
            </remarks>
        </member>
        <member name="M:wx.Object._(System.Enum)">
            <summary>Returns the translation of the enumeration value.
             Suppose, we have an enumeration <c>Assembly.Enumeration</c> containing a value <c>Assembly.Enumeration.Value</c>.
             Then, this will look for a translation of "Assembly.Enumeration.Value" first and then, if this fails, for a
             translation of "Value".
            
             Translations may also be provided by wx.Globalization.EnumValueTranslations.</summary>
        </member>
        <member name="M:wx.Object._(System.String,System.Object[])">
            <summary>This will translate <c>format</c> into the currently selected locale and then paste sting versions of the arguments into the result.
            Refer to wx.Locale.</summary>
        </member>
        <member name="M:wx.Object.__(System.String)">
            <summary>This is a dummy method that programmers may use to mark a text as to be translated by GETTEXT but not here.</summary><remarks>
                     * Example:
                     * \code
                     string theUntranslatedText=wx.Object.__("The untranslated text.");
                     System.Diagnostics.Trace.WriteLine(theUntranslatedText);     // this can be understood by developers.
                     System.Console.WriteLine(wx.Object._(theUntranslatedString); // this can be understood by the user of the program.
                     \endcode
                     * </remarks>
        </member>
        <member name="M:wx.Object.GetTypeName(System.IntPtr)">
            <summary>This will return the name of the C++ class of the wrapped pointer.
            Information will be derived from the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:wx.Object.GetTypeName">
            <summary>This will return the name of the C++ class of the wrapped pointer.
            Information will be derived from the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:wx.Object.GetClassInfo">
            <summary>This will return a wrapper of the  wxWidgets RTTI representation.</summary>
        </member>
        <member name="M:wx.Object.AddObject(wx.Object)">
            <summary>Registers an Object, so that it can be referenced using a C++ object
            		 pointer.</summary>
        </member>
        <member name="M:wx.Object.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:wx.Object.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.</summary>
            <param name="memOwn">defines whether this method creates wrappers owning the C++ object or not.</param>
        </member>
        <member name="M:wx.Object.FindObject(System.IntPtr,System.Type)">
            <summary>Locates the registered object that references the given C++ object pointer.
                      
                    If the pointer is not found, a reference to the object is created 
                    using type.
                    
                    Wrappers created by this method will not own the memory allocated by <c>ptr</c>.</summary>
        </member>
        <member name="M:wx.Object.FindObject(System.IntPtr,System.Type,System.Boolean)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             The result is assignable to <c>type</c>.
             
             If the pointer is not found, a reference to the object is created 
             using type.
            
             Argument <c>memOwn</c> defines, whether a fresh created wrapper owns
             the memory allcoated by <c>ptr</c>.
            
             </summary>
        </member>
        <member name="M:wx.Object.FindObject(System.IntPtr,System.Type,System.Type)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             If the pointer is not found, a reference to the object is created 
             using type.
            
             If this creates a new wrapper, this wrapper will NOT own the native instance.
             </summary>
             <param name="ptr">C++ pointer that shall be wrapped.</param>
             <param name="returnType">The resulting wrapper will be assignable to this type.</param>
             <param name="defaultType">Newly created wrappers will be of this type. Instances of this type shall be assignable to the return type.</param>
        </member>
        <member name="M:wx.Object.FindObject(System.IntPtr,System.Type,System.Type,System.Boolean)">
            <summary>Locates the registered object that references the given C++ object pointer.
            
             If the pointer is not found, a reference to the object is created 
             using type.
            
             Argument <c>memOwn</c> defines, whether a fresh created wrapper owns
             the memory allcoated by <c>ptr</c>.
             </summary>
             <param name="ptr">C++ pointer that shall be wrapped.</param>
             <param name="memOwn">Indicates with true that newly created instances shall own the native memory.</param>
             <param name="returnType">The resulting wrapper will be assignable to this type.</param>
             <param name="defaultType">Newly created wrappers will be of this type. Instances of this type shall be assignable to the return type.</param>
        </member>
        <member name="M:wx.Object.FindObject(System.IntPtr)">
            <summary>Locates the registered object that references the given C++ object
            pointer.</summary>
        </member>
        <member name="M:wx.Object.RemoveObject(System.IntPtr)">
            <summary>Removes a registered object.
            		 returns true if the object is found in the
            		 Hashtable and is removed (for Dispose)</summary>
        </member>
        <member name="M:wx.Object.VirtualDispose">
            <summary>called when an C++ (wx)Object dtor gets invoked
             This method may be passed to native objects that can use a 
             Virtual_Dispose method that will be called on deleting the native
             object.
            </summary>
        </member>
        <member name="M:wx.Object.VirtualDisposeAll">
            <summary>Dispose all safed instances of wrappers.
            This will be done for instance on closing the application.</summary>
        </member>
        <member name="M:wx.Object.CallDTor">
            <summary>This will be called by Dispose() to delete the C++ object.
            Overload this if you have to use another DTor.</summary>
        </member>
        <member name="M:wx.Object.DeregisterWrapper">
            <summary>Use this to implement services that decouple the .NET wrapper from the native  wxWidgets objects.
            Example: Remove callback function pointers.
            Please note that this may be called more than once.</summary>
        </member>
        <member name="P:wx.Object.SavedInstancesCount">
            <summary>Use this to get the number of valid/undisposed instances of  wxWidgets objects.</summary>
        </member>
        <member name="P:wx.Object.InstancesCount">
            <summary>Use this to read the number of valid instances.
            This will return the number of generated and undisposed instances of this class
            regardless whether these objects have been saved in the static container for
            instances or not.</summary>
        </member>
        <member name="P:wx.Object.DllSync">
            <summary>Use this object to synchronize calls to the <c>wx-c</c> DLL.
             Apparently, allocation and deallocation of C++ objects using <c>new</c> and <c>delete</c>
             must be synchronized at least on  Windows. It is generally a good idea, to synchronize
             most of calls to the DLL. Please keep in mind, that the garbage collector runs in
             parallel to the program. So, you typically have at least two threads running that
             use the <c>wx-c</c> DLL.
            </summary>
        </member>
        <member name="P:wx.Object.IsNULL">
            <summary>
            True if this does not refer to a valid C++ object.
            This situation typically occurs when a wrapped C++ object gets deallocated but
            the wrapper has net yet been finalized.
            </summary>
        </member>
        <member name="T:wx.Object.ClassInfo">
            <summary>This wrapps the  wxWidgets <c>wxClassInfo</c>.
            This class implements a DB of registered class informations.
            This DB may be used to identify pointers to <c>wxObject</c> by
            FindClassInfoOf(). Prerequisite: The wrapper class (e.g. HtmlCell) implements a public and static
            method <c>GetWxClassInfo()</c> or <c>HtmlCell_GetWxClassInfo()</c> returning a <c>System.IntPtr</c> to the
            <c>wxClassInfo</c> of the C++ objects wrapped by that class.
            </summary>
        </member>
        <member name="M:wx.Object.ClassInfo.FindOrCreate(System.IntPtr,System.Type)">
            <summary>This will return the wrapper for the  wxWidgets <c>wxClassInfo</c> <c>cptr</c>. or create one if necessary.</summary>
        </member>
        <member name="M:wx.Object.ClassInfo.FindWxObject(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxObject</c>.
            Please note, that not all  wxWidgets classes inerit from <c>wxObject</c>.
            </summary>
        </member>
        <member name="M:wx.Object.ClassInfo.FindWxGridCellEditor(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxGridCellEditor</c>.
            </summary>
        </member>
        <member name="M:wx.Object.ClassInfo.FindWxGridCellRenderer(System.IntPtr)">
            <summary>This will find the class info referring to a native instance of <c>wxGridCellRenderer</c>.
            </summary>
        </member>
        <member name="M:wx.Object.ClassInfo.Find(System.IntPtr,System.IntPtr)">
            <summary>Internal helper that finds a class info for <c>nativeInstance</c> provided that <c>classInfo</c> is a pointer to the <c>wxWidgets</c> class info.
            </summary>
        </member>
        <member name="P:wx.Object.ClassInfo.BaseClass1">
            <summary>First base class or <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Object.ClassInfo.BaseClass2">
            <summary>Second base class or <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Object.ClassInfo.Size">
            <summary>The size of the native object.</summary>
        </member>
        <member name="P:wx.Object.ClassInfo.wxNetType">
            <summary>This is the  wx.NET wrapper class.</summary>
        </member>
        <member name="T:wx.Object.StorageMode">
            <summary>Use constants of this kind to tell the CTor whether to hold the newly created object into the static container of instances or not.</summary>
        </member>
        <member name="F:wx.Event.wxEVT_CALENDAR_SEL_CHANGED">
            \name Calendar Control Events 
        </member>
        <member name="F:wx.Event.wxEVT_COMMAND_FIND">
            \name Search Dialog Events 
        </member>
        <member name="F:wx.Event.wxEVT_COMMAND_TREE_BEGIN_DRAG">
            \name Tree List Events 
        </member>
        <member name="F:wx.Event.wxEVT_COMMAND_LIST_BEGIN_DRAG">
            \name List Control Events 
        </member>
        <member name="F:wx.Event.wxEVT_COMMAND_NOTEBOOK_PAGE_CHANGED">
            \name Note Book Events 
        </member>
        <member name="F:wx.Event.wxEVT_COMMAND_LISTBOOK_PAGE_CHANGED">
            \name List Book Events 
        </member>
        <member name="F:wx.Event.wxEVT_GRID_CELL_LEFT_CLICK">
            \name Grid Events 
        </member>
        <member name="F:wx.Event.wxEVT_LOAD_HTML_PAGE">
            This is a new event type which is used in wx.HtmlWindow for deferred loading of HTML pages. 
        </member>
        <member name="F:wx.Event.wxEVT_TASKBAR_MOVE">
            \name wx.TaskBarIcon events impementation 
        </member>
        <member name="F:wx.Event.wxEVT_WIZARD_CANCEL">
            \name wx.Wizard Events 
        </member>
        <member name="M:wx.Event.#cctor">
            <summary> This initializes the event types.</summary> 
        </member>
        <member name="M:wx.Event.AddEventType(System.Int32,System.Type)">
            <summary>
            Use this to declare a new custom event class. You may use CreateNewEventId()
            to define the event ID. Provide a class for <c>type</c> that implements wx.Event.
            </summary>
            <param name="evt">The ID of the new event.</param>
            <param name="type">The class implementing the new event. This shall be assignable to wx.Event. This class 
            also MUST implement a public CTor accepting an IntPtr to a c++ instance of <c>wxEvent</c>.</param>
            <seealso cref="M:wx.EvtHandler.AddEventListener(System.Int32,wx.EventListener)"/>
        </member>
        <member name="M:wx.Event.CreateNewEventId">
            <summary>
            Creates a new, yet unused ID for a custom event class.
            </summary>
            <see cref="M:wx.Event.AddEventType(System.Int32,System.Type)"/>
            <seealso cref="M:wx.EvtHandler.AddEventListener(System.Int32,wx.EventListener)"/>
            <returns></returns>
        </member>
        <member name="M:wx.Event.AddEventType(System.Type)">
            <summary>
            Creates a new custom event of the provided type. This event will have a new unique ID that will
            be created automatically. The result of this method will return this new ID.
            </summary>
            <param name="type">The class implementing the new event. This shall be assignable to wx.Event. This class 
            also MUST implement a public CTor accepting an IntPtr to a c++ instance of <c>wxEvent</c>.</param>
            <seealso cref="M:wx.EvtHandler.AddEventListener(System.Int32,wx.EventListener)"/>
            <seealso cref="M:wx.Event.CreateNewEventId"/>
        </member>
        <member name="M:wx.Event.Skip">
            <summary>Equivalent to <c>Skipt(true)</c>.
            This tells the chain of event handlers to search for additional handlers of this
            event.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.Event.Skip(System.Boolean)" ignoriert -->
        <member name="P:wx.Event.Skipped">
            <summary>
            TRUE iff this has been skipped (shall not be handled by another handler).
            </summary>
        </member>
        <member name="T:wx.Dialog">
            <summary>
            A dialog box is a window with a title bar and sometimes a system menu, which can be moved around the screen. It can
            contain controls and other windows and is often used to allow the user to make some choice or to answer a question.
            
            Dialog Buttons:
            
            The dialog usually contains either a single button allowing to close the dialog or two buttons, one accepting the
            changes and the other one discarding them (such button, if present, is automatically activated if the user presses
            the "Esc" key). By default, buttons with the standard MenuIDs.wxID_OK and MenuIDs.wxID_CANCEL identifiers behave as expected.
            Starting with wxWidgets 2.7 it is also possible to use a button with a different identifier instead, see
            SetAffirmativeId() and SetEscapeId().
            
            Also notice that the CreateButtonSizer() should be used to create the buttons appropriate for the current platform
            and positioned correctly (including their order which is platform-dependent).
            </summary>
        </member>
        <member name="T:wx.Window">
            <summary>Window is the base class for all windows and represents any visible object on screen.
             All controls, top level windows and so on are windows. Sizers and device contexts are not,
             however, as they don't appear on screen themselves.
             Please note that all children of the window will be deleted automatically by
             the destructor before the window itself is deleted which means that you
             don't have to worry about deleting them manually.
            </summary>
        </member>
        <member name="T:wx.EvtHandler">
            <summary>Interface to the event handler.
            Main methods: wx.EvtHandler.AddCommandListener() and wx.EvtHandler.AddEventListener().</summary>
            
        </member>
        <member name="M:wx.EvtHandler.AddCommandListener(System.Int32,System.Int32,wx.EventListener,System.Object)">
            <summary> Use this form of adding a listener for a command event if the owner, who implements \c listener, might be accidentally disposed by the garbage collection.</summary>
        </member>
        <member name="M:wx.EvtHandler.RemoveListener(wx.EventListener)">
            <summary>This will remove event listener <c>listenerToRemove</c> from the list of event listeners.</summary>
        </member>
        <member name="M:wx.EvtHandler.AddCommandRangeListener(System.Int32,System.Int32,System.Int32,wx.EventListener,System.Object)">
            <summary>Use this form of adding a listener for a command event if the owner, who implements <c>listener</c>, might be accidentally disposed by the garbage collection.</summary>
        </member>
        <member name="M:wx.EvtHandler.AddEventListener(System.Int32,wx.EventListener)">
            <summary>
            Installs a new event listener listening to the event of the provided type.
            Use this method if this handler implements the listener. To add listeners
            here that are provided by other classes, use the form of this method that
            additionally accepts an owner.
            </summary>
            <param name="eventType">The event type that will be handled by this listener.
            This might have been created by wx.Event.AddEventType</param>
            <param name="listener">The delegate that actually handles this event.</param>
            <seealso cref="M:wx.Event.AddEventType(System.Int32,System.Type)"/>
        </member>
        <member name="M:wx.EvtHandler.AddEventListener(System.Int32,wx.EventListener,System.Object)">
            <summary>Use this form of adding a listener for a command event if the owner,
            that implements <c>listener</c>, might be accidentally disposed by the garbage collection.
            </summary>
            <param name="eventType">The event type that will be handled by this listener.
            This might have been created by wx.Event.AddEventType</param>
            <param name="listener">The delegate that actually handles this event.</param>
            <seealso cref="M:wx.Event.AddEventType(System.Int32,System.Type)"/>
        </member>
        <member name="M:wx.EvtHandler.MarshalEvent(System.IntPtr,System.Int32)">
            
            <summary>
            All listened-for events are received here. The event code is
            mapped to an actual Event type, and then the listener EventListener lnsertion is called.
            </summary>
            <param name="wxEvent">Ptr to C++ event</param>
            <param name="iListener">Designator of the event listener</param>	
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_MOVE(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_LEFT_DOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_LEFT_UP(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_RIGHT_DOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_RIGHT_UP(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_LEFT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_RIGHT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TASKBAR_CLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SIZE(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CLOSE(wx.EventListener)">
            <summary>
            This will handle wx.CloseEvent. The event handler may veto the closing of the application
            if <c>CanVeto</c> is true.
            Please do not forget to skip the event. Otherwise, the application may not be able to close
            down.
            </summary>
            <param name="lsnr">Event listener. This will provide the handler of the event.
            Please do not forget to skip the event in order to proceed with the closing section.</param>
            <see cref="T:wx.CloseEvent"/>
        </member>
        <member name="M:wx.EvtHandler.EVT_PAINT(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_ERASE_BACKGROUND(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_IDLE(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MOVE(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TIMER(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SOCKET(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_KILL_FOCUS(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SET_FOCUS(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MOUSE_EVENTS(wx.EventListener)">
            <summary>
            Installs a handler for all mouse events, i.e. EVT_ENTER_WINDOW().
            EVT_LEAVE_WINDOW(), EVT_LEFT_DOWN(), EVT_RIGHT_DOWN(), EVT_MIDDLE_DOWN(),
            EVT_LEFT_DCLICK(), EVT_RIGHT_DCLICK(), EVT_MIDDLE_DCLICK(), EVT_MOTION(),
            EVT_LEFT_UP(), EVT_RIGHT_UP(), EVT_MIDDLE_UP().
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_ENTER_WINDOW(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LEAVE_WINDOW(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LEFT_DOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_RIGHT_DOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MIDDLE_DOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LEFT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_RIGHT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MIDDLE_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MOTION(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LEFT_UP(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_RIGHT_UP(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MIDDLE_UP(wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_UPDATE_UI(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MENU(System.Object,wx.EventListener)">
            <summary><c>id</c> will be converted to <c>int</c>.
            </summary>
        </member>
        <member name="M:wx.EvtHandler.EVT_MENU(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_BUTTON(System.Int32,wx.EventListener)">
            <summary>Adds a command listener of type Event.wxEVT_COMMAND_BUTTON_CLICKED.
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CHECKBOX(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LISTBOX(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LISTBOX_DCLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CHOICE(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_COMBOBOX(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TEXT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TEXT_ENTER(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_RADIOBOX(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_RADIOBUTTON(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SLIDER(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SPINCTRL(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SPIN_UP(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SPIN_DOWN(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SPIN(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TOGGLEBUTTON(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_KEY_DOWN(wx.EventListener)">
            <summary>
            Adds a listener to the event of pressing a key down.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_KEY_UP(wx.EventListener)">
            <summary>
            Adds a listener to the event on releasing an event.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CHAR(wx.EventListener)">
            <summary>
            Adds a listener to character events.
            </summary>
            <param name="lsnr">The listener to the character events.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_DATE_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_COLOURPICKER_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FONTPICKER_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_SEL_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_DAY(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_MONTH(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_YEAR(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_DOUBLECLICKED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALENDAR_WEEKDAY_CLICKED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND(wx.EventListener)">
            \name Search Dialog Events 
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND_NEXT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND_REPLACE(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND_REPLACE_ALL(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_FIND_CLOSE(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_BEGIN_DRAG(System.Int32,wx.EventListener)">
            <summary>
            The user has started dragging an item with the left mouse button.
            The event handler must call wx.TreeEvent.Allow() for the drag operation to continue. 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_BEGIN_RDRAG(System.Int32,wx.EventListener)">
            <summary>
            The user has started dragging an item with the right mouse button.
            The event handler must call wx.TreeEvent.Allow() for the drag operation to continue.  
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_BEGIN_LABEL_EDIT(System.Int32,wx.EventListener)">
            <summary>
            Begin editing a label. This can be prevented by calling Veto(). 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_END_LABEL_EDIT(System.Int32,wx.EventListener)">
            <summary>
            The user has finished editing a label. This can be prevented by calling Veto(). 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_DELETE_ITEM(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_GET_INFO(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_SET_INFO(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_EXPANDED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_EXPANDING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_COLLAPSED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_COLLAPSING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_SEL_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_SEL_CHANGING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_KEY_DOWN(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_ACTIVATED(System.Int32,wx.EventListener)">
            <summary>The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard .
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_RIGHT_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_ITEM_MIDDLE_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_TREE_END_DRAG(System.Int32,wx.EventListener)">
            <summary>
            The user has released the mouse after dragging an item. 
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_BEGIN_DRAG(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_BEGIN_RDRAG(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_BEGIN_LABEL_EDIT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_END_LABEL_EDIT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_DELETE_ITEM(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_DELETE_ALL_ITEMS(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_SELECTED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_DESELECTED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_ACTIVATED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_FOCUSED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_MIDDLE_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_ITEM_RIGHT_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_KEY_DOWN(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_INSERT_ITEM(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_COL_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_COL_RIGHT_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_COL_BEGIN_DRAG(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_COL_DRAGGING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_COL_END_DRAG(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LIST_CACHE_HINT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_NOTEBOOK_PAGE_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_NOTEBOOK_PAGE_CHANGING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LISTBOOK_PAGE_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_LISTBOOK_PAGE_CHANGING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_CELL_LEFT_CLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_CELL_RIGHT_CLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_CELL_LEFT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_CELL_RIGHT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_LABEL_LEFT_CLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_LABEL_RIGHT_CLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_LABEL_LEFT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_LABEL_RIGHT_DCLICK(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_ROW_SIZE(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_COL_SIZE(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_RANGE_SELECT(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_CELL_CHANGE(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_SELECT_CELL(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_EDITOR_SHOWN(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_EDITOR_HIDDEN(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_GRID_EDITOR_CREATED(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_ACTIVATE(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_DISPLAY_CHANGED(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SASH_DRAGGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SASH_DRAGGED_RANGE(System.Int32,System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_QUERY_LAYOUT_INFO(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CALCULATE_LAYOUT(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CHECKLISTBOX(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_CONTEXT_MENU(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SYS_COLOUR_CHANGED(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_QUERY_NEW_PALETTE(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_PALETTE_CHANGED(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_INIT_DIALOG(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_SIZING(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_MOVING(wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_HELP(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_DETAILED_HELP(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_CHANGE(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_STYLENEEDED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_CHARADDED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_SAVEPOINTREACHED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_SAVEPOINTLEFT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_ROMODIFYATTEMPT(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_KEY(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_DOUBLECLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_UPDATEUI(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_MODIFIED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_MACRORECORD(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_MARGINCLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_NEEDSHOWN(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_PAINTED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_USERLISTSELECTION(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_URIDROPPED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_DWELLSTART(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_DWELLEND(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_START_DRAG(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_DRAG_OVER(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_DO_DROP(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_ZOOM(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_HOTSPOT_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_HOTSPOT_DCLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_STC_CALLTIP_CLICK(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_WIZARD_CANCEL(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_WIZARD_FINISHED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_WIZARD_HELP(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_WIZARD_PAGE_CHANGED(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="M:wx.EvtHandler.EVT_WIZARD_PAGE_CHANGING(System.Int32,wx.EventListener)">
            <summary>
            </summary>
            <param name="id">Window Id or -1 to declare a handler for all events.</param>
            <param name="lsnr">Event listener.</param>
        </member>
        <member name="F:wx.Window.wxID_OK">
            <summary>
            Default ID of the OK button.
            </summary>
        </member>
        <member name="F:wx.Window.wxID_CANCEL">
            <summary>
            Default ID of the cancel button.
            </summary>
        </member>
        <member name="F:wx.Window.wxID_YES">
            <summary>
            Default ID of the YES button.
            </summary>
        </member>
        <member name="F:wx.Window.wxID_NO">
            <summary>
            Default ID of the NO button.
            </summary>
        </member>
        <member name="F:wx.Window.wxID_ANY">
            <summary>
            Indefinite window ID: -1.
            </summary>
        </member>
        <member name="F:wx.Window.wxID_ABOUT">
            <summary>
            Default ID of the about box.
            </summary>
        </member>
        <member name="F:wx.Window.wxDefaultPosition">
            <summary>Default position.
            Use this when you are allowed to provide a position
            but you do not want to provide a particular position.
            </summary>
        </member>
        <member name="F:wx.Window.wxDefaultSize">
            <summary>Default size.
            Use this when you are allowed to provide a size
            but you do not want to specify a particular size.</summary>
        </member>
        <member name="F:wx.Window.wxDefaultCoord">
            <summary>Default coordinate.
            Use this when you are allowed to provide a coordinate
            but you do not want to provide information on a particular coordinate.</summary>
        </member>
        <member name="F:wx.Window.ClientData">
            <summary>
            In addition to the client data concept in wxWidgets, wx.NET offers you the 
            option to tag each window with client data. The motivation for this: When
            you deal with events, you usually know the sender. You may use the client data
            to attach data to the sender that is required to deal with the event. For instance,
            you may have a button that shall have an effect on a particular widget. You may
            ease implementation of such a solution assigning the widget to the button's
            client data. Thus, the event handler may retrieve the widgets that is required
            to implement the action directly from the control that caused the action.
            </summary>
        </member>
        <member name="M:wx.Window.Dispose(System.Boolean)">
            <summary>Overriden disposition.
            Even if we do not own the memory, we have to delete the window, since this
            is apparently intended by the user calling this method.</summary>
        </member>
        <member name="M:wx.Window.Close">
            <summary>This function simply generates a wxCloseEvent whose handler usually tries to close the window.
             It doesn't close the window itself, however.
            
             Close calls the close handler for the window, providing an opportunity for the window to choose whether to destroy
             the window. Usually it is only used with the top level windows (wx.Frame and wx.Dialog classes) as the others are
             not supposed to have any special <c>OnClose()</c> logic.
            
             The close handler should check whether the window is being deleted forcibly, using wx.CloseEvent.CanVeto, in which
             case it should destroy the window using wx.Window.Destroy().
            
             Note that calling <c>Close()</c> does not guarantee that the window will be destroyed; but it provides a way to simulate a manual
             close of a window, which may or may not be implemented by destroying the window. The default implementation of
             <c>wx.Dialog.OnCloseWindow()</c> does not necessarily delete the dialog, since it will simply simulate an <c>wxID_CANCEL</c> event
             which is handled by the appropriate button event handler and may do anything at all.
            
             To guarantee that the window will be destroyed, call wx.Window.Destroy instead.</summary>
        </member>
        <member name="M:wx.Window.Close(System.Boolean)">
            <summary>This will create a <c>wx.CloseEvent</c> but handlers are not allowed to veto if <c>force</c> is <c>true</c>.
            Try wx.Utils.Exit() if you want the application to be exited. Otherwise, the application will exit
            automatically, if all top level windows are closed.
            
            Refer also to Close().</summary>
        </member>
        <member name="M:wx.Window.Show">
            <summary>Shows or hides the window.
            You may need to call Raise() for a top level window if you want to bring it to top, although this
            is not needed if Show() is called immediately after the frame creation.
            </summary>
            <returns>true if the window has been shown or hidden or false if nothing was done because
            it already was in the requested state.</returns>
            <seealso cref="P:wx.Window.IsShown"/>
            <seealso cref="M:wx.Window.Hide"/>
            <seealso cref="M:wx.Window.Raise"/>
        </member>
        <member name="M:wx.Window.Show(System.Boolean)">
            <summary>Shows or hides the window.
            You may need to call Raise() for a top level window if you want to bring it to top, although this
            is not needed if Show() is called immediately after the frame creation.
            </summary>
            <param name="show">If true displays the window. Otherwise, hides it.</param>
            <returns>true if the window has been shown or hidden or false if nothing was done because
            it already was in the requested state.</returns>
            <seealso cref="P:wx.Window.IsShown"/>
            <seealso cref="M:wx.Window.Hide"/>
            <seealso cref="M:wx.Window.Raise"/>
        </member>
        <member name="M:wx.Window.IsEnabled">
            <summary>Returns true iff enabled.</summary>
        </member>
        <member name="M:wx.Window.Destroy">
            <summary>Destroy the window.
            Call this only is you do not want to show it again.</summary>
        </member>
        <member name="M:wx.Window.DestroyChildren">
            <summary>Destroy the window's children.
            Call this only is you do not want to show them again.</summary>
        </member>
        <member name="M:wx.Window.NewControlId">
            <summary>Generate a control id for the controls which were not given one by
            user.
            
             wx.NET provides property wx.Window.UniqueID to generate unqie IDs
            which are appropriate to designate windows.</summary>
        </member>
        <member name="M:wx.Window.NextControlId(System.Int32)">
            <summary>Get the id of the control following the one with the given
            (autogenerated) id.</summary>
        </member>
        <member name="M:wx.Window.PrevControlId(System.Int32)">
            <summary>Get the id of the control preceding the one with the given
            (autogenerated) id</summary>
        </member>
        <member name="M:wx.Window.Raise">
            <summary>Raises the window to the top of the window hierarchy (z-order).
            In current version of wxWidgets this works both for managed and child windows.
             </summary>
             <seealso cref="M:wx.Window.Lower"/>
        </member>
        <member name="M:wx.Window.Lower">
            <summary>
            Lowers the window to the bottom of the window hierarchy (z-order).
            </summary>
            <seealso cref="M:wx.Window.Raise"/>
        </member>
        <member name="M:wx.Window.CentreOnParent">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
        </member>
        <member name="M:wx.Window.CenterOnParent">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
        </member>
        <member name="M:wx.Window.CentreOnParent(wx.Orientation)">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
            <param name="direction">Specifies the direction for the centering. May be Orientation.wxHORIZONTAL,
            Orientation.wxVERTICAL or Orientation.wxBOTH.
            </param>
        </member>
        <member name="M:wx.Window.CenterOnParent(wx.Orientation)">
            <summary>
            Centres the window on its parent. This is a more readable synonym for Centre.
            This methods provides for a way to center top level windows over their parents instead of the entire screen.
            If there is no parent or if the window is not a top level window, then behaviour is the same as wx.Window.Centre().
            </summary>
            <param name="direction">Specifies the direction for the centering. May be Orientation.wxHORIZONTAL,
            Orientation.wxVERTICAL or Orientation.wxBOTH.
            </param>
        </member>
        <member name="M:wx.Window.Fit">
            <summary>
            Sizes the window so that it fits around its subwindows. This function won't do anything if there
            are no subwindows and will only really work correctly if the sizers are used for the subwindows layout.
            </summary>
            <remarks>
            Also, if the window has exactly one subwindow it is better (faster and the result is more precise as
            Fit() adds some margin to account for fuzziness of its calculations) to call
            <code>
             window->SetClientSize(child->GetSize());
            </code>
            instead of calling Fit.
            </remarks>
        </member>
        <member name="M:wx.Window.FitInside">
            <summary>
            Similar to Fit, but sizes the interior (virtual) size of a window.
            Mainly useful with scrolled windows to reset scrollbars after sizing changes that do not trigger
            a size event, and/or scrolled windows without an interior sizer.
            This function similarly won't do anything if there are no subwindows.
            </summary>
        </member>
        <member name="M:wx.Window.SetSizeHints(System.Drawing.Size)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
            <param name="minimalSize">Minimal size of the dialog or frame that will be propagated to the size of the children.</param>
        </member>
        <member name="M:wx.Window.SetSizeHints(System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
            <param name="minW">Minimal width of the dialog or frame that will be propagated to the size of the children.</param>
            <param name="minH">Minimal width of the dialog or frame that will be propagated to the size of the children.</param>
        </member>
        <member name="M:wx.Window.SetSizeHints(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
        </member>
        <member name="M:wx.Window.SetSizeHints(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Use of this function for windows which are not toplevel windows (such as wxDialog or wx.Frame) is discouraged.
            Please assign to <c>MinSize</c> and <c>MaxSize</c> instead.
            </summary>
        </member>
        <member name="M:wx.Window.HasFlag(wx.WindowStyles)">
            <summary>True if the designated style flag has been set for this window.</summary>
        </member>
        <member name="M:wx.Window.SetFocus">
            <summary>This sets the window to receive keyboard input.
            Please note, that this method cannot be overridden from any class.
            Currently, inheritors of <c>wx.Panel</c> and <c>wx.Dialog</c> can override this.</summary>
        </member>
        <member name="M:wx.Window.SetFocusFromKbd">
            <summary>This function is called by  wxWidgets keyboard navigation code
            when the user gives the focus to this window from keyboard (e.g. using TAB key).
            By default this method simply calls <c>SetFocus</c> but can be overridden to do something in addition
            to this in the derived classes.
            Please note, that this method cannot be overridden from any class.
            Currently, inheritors of <c>wx.Panel</c> and <c>wx.Dialog</c> can override this.</summary>
        </member>
        <member name="M:wx.Window.FindFocus">
            <summary>
            Finds the window or control which currently has the keyboard focus.
            
            Note that this is a static function, so it can be called without needing a wx.Window pointer.
            </summary>
        </member>
        <member name="M:wx.Window.AcceptsFocus">
            <summary>
            can this window have focus?
            </summary>
        </member>
        <member name="M:wx.Window.AcceptsFocusFromKeyboard">
            <summary>
            can this window be given focus by keyboard navigation? if not, the
            only way to give it focus (provided it accepts it at all) is to
            click it
            </summary>
        </member>
        <member name="M:wx.Window.FindWindow(System.Int32)">
             <summary>
             Adds a child window. This is called automatically by window creation functions so should not be required by the application programmer.
            
             Notice that this function is mostly internal to wxWidgets and shouldn't be called by the user code.
             </summary>
             <param name="child">Child window to add.</param>
        </member>
        <member name="M:wx.Window.FindWindow(System.Int32,System.Type)">
            <summary>This will find the window of the provided <c>id</c> and or create one of class <c>type</c>.
            </summary>
        </member>
        <member name="M:wx.Window.PushEventHandler(wx.EvtHandler)">
            <summary>Pushes this event handler onto the event stack for the window.
                      * \param handler Specifies the handler to be pushed.
                      * An event handler is an object that is capable of processing the events sent to a window.
                     * By default, the window is its own event handler, but an application may wish to substitute another, 
                     * for example to allow central implementation of event-handling for a variety of different window classes.
                     *
                     * wx.Window.PushEventHandler allows an application to set up a chain of event handlers, where an event not
                     * handled by one event handler is handed to the next one in the chain. Use wx.Window.PopEventHandler to remove
                     * the event handler.</summary>
        </member>
        <member name="M:wx.Window.PopEventHandler(System.Boolean)">
            <summary>cf. PushEventHandler().</summary>
        </member>
        <member name="M:wx.Window.CaptureMouse">
             <summary>
             Directs all mouse input to this window. Call wxWindow::ReleaseMouse to release the capture.
            
             Note that wxWidgets maintains the stack of windows having captured the mouse and when the mouse is released 
             the capture returns to the window which had had captured it previously and it is only really released if there
             were no previous window. In particular, this means that you must release the mouse as many times as you capture
             it, unless the window receives the wx.MouseCaptureLostEvent event.
            
             Any application which captures the mouse in the beginning of some operation must handle wx.MouseCaptureLostEvent 
             and cancel this operation when it receives the event. The event handler must not recapture mouse.
             </summary>
        </member>
        <member name="M:wx.Window.ReleaseMouse">
            <summary>
            Releases mouse input captured with wx.Window.CaptureMouse().
            </summary>
        </member>
        <member name="M:wx.Window.GetCapture">
            <summary>
            Returns the currently captured window.
            </summary>
            <seealso cref="M:wx.Window.CaptureMouse"/>
        </member>
        <member name="M:wx.Window.HasCapture">
            <summary>
            Returns true if this window has the current mouse capture.
            </summary>
            <seealso cref="M:wx.Window.CaptureMouse"/>
        </member>
        <member name="M:wx.Window.PrepareDC(wx.DC)">
            <summary>This prepares the argument for drawing.</summary>
        </member>
        <member name="M:wx.Window.IsExposed(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns true if the given point or rectangle area has been exposed since the last repaint.
            Call this in an paint event handler to optimize redrawing by only redrawing
            those areas, which have been exposed.</summary>
        </member>
        <member name="M:wx.Window.ScrollLines(System.Int32)">
            <summary>
            Scrolls the window by the given number of lines down (if lines is positive) or up.
            </summary>
            <param name="lines">Number of lines to scroll down (positive) or up (negative)</param>
            <returns>Returns true if the window was scrolled, false if it was already on top/bottom and nothing was done.</returns>
        </member>
        <member name="M:wx.Window.ScrollPages(System.Int32)">
            <summary>
            Scrolls the window by the given number of pages down (if pages is positive) or up.
            </summary>
            <param name="pages">Number of pages to scroll down (positive) or up.</param>
            <returns>This function is currently only implemented under MSW and wxGTK.</returns>
        </member>
        <member name="M:wx.Window.SetSizerAndFit(wx.Sizer)">
            <summary>
            The same as assigning a Sizer, except it also sets the size hints for the window based on the sizer's minimum size.
            </summary>
            <param name="sizer">The new sizer to use.</param>
            <seealso cref="P:wx.Window.Sizer"/>
        </member>
        <member name="M:wx.Window.SetSizerAndFit(wx.Sizer,System.Boolean)">
            <summary>
            The same as assigning a Sizer, except it also sets the size hints for the window based on the sizer's minimum size.
            </summary>
            <param name="sizer">The new sizer to use.</param>
            <param name="deleteOld">Default is true</param>
            <seealso cref="P:wx.Window.Sizer"/>
        </member>
        <member name="M:wx.Window.GetNextWindow">
            <summary>Get the next Window in the TAB order of the parent.
            This may be <c>null</c> if either this does not have a parent or the parent only has one child.</summary>
        </member>
        <member name="M:wx.Window.GetPreviousWindow">
            <summary>Get the previous Window in the TAB order of the parent.
            This may be <c>null</c> if either this does not have a parent or the parent only has one child.</summary>
        </member>
        <member name="E:wx.Window.OnTransferDataFromWindow">
            <summary>This will be called on <c>wxWindow</c>::TransferDataFromWindow.
            This is the right place for validation.</summary>
        </member>
        <member name="P:wx.Window.UniqueID">
            <summary>This always returns a unique ID that is appropriate to denote windows.</summary>
        </member>
        <member name="P:wx.Window.StyleFlags">
            <summary>This will set or get the styles flags that define this window.</summary>
        </member>
        <member name="P:wx.Window.Enabled">
            <summary>Enable or disable cf. read whether enabled or disabled.</summary>
        </member>
        <member name="P:wx.Window.MinWidth">
            <summary>Get or set the minimal width of the window.</summary>
        </member>
        <member name="P:wx.Window.MinHeight">
            <summary>Get or set the minimal height of the window.</summary>
        </member>
        <member name="P:wx.Window.MinSize">
            <summary>Read and set the minimum size of the window.
            This should be set after changing the size for instance after construction and before
            adding this to tha parent sizer.
            However, you should consider to set size hints instead of using this method.</summary>
        </member>
        <member name="P:wx.Window.MaxWidth">
            <summary>This is a read-only property. Use wx.Window.MaxSize to change this.</summary>
        </member>
        <member name="P:wx.Window.MaxSize">
            <summary>Read and set the maximum size of the window.
            This should be set after changing the size for instance after construction and before
            adding this to tha parent sizer.
            However, you should consider to set size hints instead of using this method.</summary>
        </member>
        <member name="P:wx.Window.IsRetained">
             <summary>
             Returns true if the window is retained, false otherwise.
            
             Remarks: Retained windows are only available on X platforms.
             </summary>
        </member>
        <member name="P:wx.Window.HelpText">
            <summary>
            Refer to wx.Html.HtmlHelpController.
            </summary>
        </member>
        <member name="P:wx.Window.DropTarget">
            <summary>
            On setting a value: Associates a drop target with this window.
            If the window already has a drop target, it is deleted.
            On getting the value: Returns the associated drop target, which may be NULL.
            </summary>
            <remarks>
            Cf. \ref drag-and-drop.
            </remarks>
        </member>
        <member name="P:wx.Window.Sizer">
            <summary>
            The sizer of this window (if defined).
            Assign to this property to specify a dynamic layout providing a sizer.
            </summary>
        </member>
        <member name="P:wx.Window.Children">
            <summary>The children of this window in an array.</summary>
        </member>
        <member name="P:wx.Window.AcceleratorTable">
            <summary>
            The accelerator table that is associated to this window.
            </summary>
        </member>
        <member name="P:wx.Window.BackgroundStyle">
            <summary>Returns or defines the background mode of the window.
             The background style indicates whether background colour should be determined by the system
             (wxBG_STYLE_SYSTEM), be set to a specific colour (wxBG_STYLE_COLOUR), or should be left to the
             application to implement (wxBG_STYLE_CUSTOM).
            
             On GTK+, use of wxBG_STYLE_CUSTOM allows the flicker-free drawing of a custom background, such
             as a tiled bitmap. Currently the style has no effect on other platforms.</summary>
        </member>
        <member name="E:wx.Window.LeftUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_UP.
            </summary>
        </member>
        <member name="E:wx.Window.RightUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_UP.
            </summary>
        </member>
        <member name="E:wx.Window.MiddleUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_UP.
            </summary>
        </member>
        <member name="E:wx.Window.LeftDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_DOWN.
            </summary>
        </member>
        <member name="E:wx.Window.MiddleDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_DOWN.
            </summary>
        </member>
        <member name="E:wx.Window.RightDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_DOWN.
            </summary>
        </member>
        <member name="E:wx.Window.LeftDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEFT_DCLICK.
            </summary>
        </member>
        <member name="E:wx.Window.RightDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_RIGHT_DCLICK.
            </summary>
        </member>
        <member name="E:wx.Window.MiddleDoubleClick">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MIDDLE_DCLICK.
            </summary>
        </member>
        <member name="E:wx.Window.MouseMove">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MOTION.
            </summary>
        </member>
        <member name="E:wx.Window.MouseThumbTrack">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_THUMBTRACK.
            </summary>
        </member>
        <member name="E:wx.Window.MouseEnter">
            <summary>
            Adds a listener to the wx.Event.wxEVT_ENTER_WINDOW.
            </summary>
        </member>
        <member name="E:wx.Window.MouseLeave">
            <summary>
            Adds a listener to the wx.Event.wxEVT_LEAVE_WINDOW.
            </summary>
        </member>
        <member name="E:wx.Window.ScrollLineUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_LINEUP.
            </summary>
        </member>
        <member name="E:wx.Window.ScrollLineDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SCROLL_LINEDOWN.
            </summary>
        </member>
        <member name="E:wx.Window.UpdateUI">
            <summary>
            Adds a listener to the wx.Event.wxEVT_UPDATE_UI.
            </summary>
        </member>
        <member name="E:wx.Window.KeyDown">
            <summary>
            Adds a listener to the wx.Event.wxEVT_KEY_DOWN.
            </summary>
        </member>
        <member name="E:wx.Window.KeyUp">
            <summary>
            Adds a listener to the wx.Event.wxEVT_KEY_UP.
            </summary>
        </member>
        <member name="E:wx.Window.Char">
            <summary>
            Adds a listener to the wx.Event.wxEVT_CHAR.
            </summary>
        </member>
        <member name="E:wx.Window.Closing">
            <summary>
            Adds a listener to the wx.Event.wxEVT_CLOSE_WINDOW.
            </summary>
        </member>
        <member name="E:wx.Window.Activated">
            <summary>
            Adds a listener to the wx.Event.wxEVT_ACTIVATE.
            </summary>
        </member>
        <member name="E:wx.Window.Moved">
            <summary>
            Adds a listener to the wx.Event.wxEVT_MOVE.
            </summary>
        </member>
        <member name="E:wx.Window.Resized">
            <summary>
            Adds a listener to the wx.Event.wxEVT_SIZE.
            </summary>
        </member>
        <member name="T:wx.Window.Validator">
            <summary>Simply a delegator for validation.
            Asign <c>false</c> to the argument if you want to indicate</summary>
        </member>
        <member name="M:wx.Dialog.CreateButtonSizer(wx.Dialog.ButtonFlags)">
            <summary>
            Creates a sizer with standard buttons. flags is a bit list of the following flags:
            ButtonFlags.OK, ButtonFlags.CANCEL, ButtonFlags.YES, ButtonFlags.NO, ButtonFlags.HELP, ButtonFlags.NO_DEFAULT.
            
            The sizer lays out the buttons in a manner appropriate to the platform.
            
            This function uses CreateStdDialogButtonSizer internally for most platforms but doesn't create the sizer at all for the platforms with hardware buttons (such as smartphones) for which it sets up the hardware buttons appropriately and returns NULL, so don't forget to test that the return value is valid before using it.
            </summary>
            <param name="flags">The flags defining the buttons to be present.</param>
            <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="M:wx.Dialog.CreateSeparatedButtonSizer(wx.Dialog.ButtonFlags)">
             <summary>
             Creates a sizer with standard buttons using CreateButtonSizer() separated from the rest of the dialog
             contents by a horizontal wx.StaticLine.
            
             Please notice that just like CreateButtonSizer() this function may return <c>null</c> if no buttons were created.
             </summary>
             <param name="flags">The flags defining the buttons to be present.</param>
             <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="M:wx.Dialog.CreateStdDialogButtonSizer(wx.Dialog.ButtonFlags)">
             <summary>
             Creates a wxStdDialogButtonSizer with standard buttons. flags is a bit list of the following
             flags: ButtonFlags.OK, ButtonFlags.CANCEL, ButtonFlags.YES, ButtonFlags.NO, ButtonFlags.HELP, ButtonFlags.NO_DEFAULT.
            
             The sizer lays out the buttons in a manner appropriate to the platform.
             </summary>
             <param name="flags">The flags defining the buttons to be present.</param>
             <returns>A button sizer or <c>null</c> if not supported</returns>
        </member>
        <member name="P:wx.Dialog.ReturnCode">
            <summary>
            Use this to get or set the value that will be returned by this dialog if shown modally.
            </summary>
        </member>
        <member name="P:wx.Dialog.DefaultItem">
            <summary>Get or set the default item.
            This usually is a button.</summary>
        </member>
        <member name="T:wx.Dialog.ButtonFlags">
            <summary>This is for CreateButtonSizer.
            </summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.YES">
            <summary>Show an YES button.
            This shall be used together either with NO or CANCEL.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.OK">
            <summary>Show an OK button.</summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.NO">
            <summary>Show an NO button.
            This shall be used together either with DIALOG_YES.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.CANCEL">
            <summary>Show an CANCEL button.</summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.YES_NO">
            <summary>Show YES and NO button.</summary>
        </member>
        <member name="F:wx.Dialog.ButtonFlags.NO_DEFAULT">
            <summary>Used with <c>NO</c>, makes NO button the default.</summary>
        </member>
        <member name="T:wx.Frame">
             <summary>
             A frame is a window whose size and position can (usually) be changed by the user. It usually has thick borders and a title bar, and can optionally contain a menu bar, toolbar and status bar. A frame can contain any window that is not a frame or dialog.
            
             A frame that has a status bar and toolbar created via the CreateStatusBar/CreateToolBar functions manages these windows, and adjusts the value returned by GetClientSize to reflect the remaining size available to application windows.
             
             Refer to the styles 
             WindowStyles.DEFAULT_FRAME_STYLE, WindowStyles.MINIMIZE_BOX, WindowStyles.MAXIMIZE_BOX, WindowStyles.RESIZE_BORDER
             WindowStyles.SYSTEM_MENU, WindowStyles.CAPTION, WindowStyles.CLOSE_BOX, WindowStyles.CLIP_CHILDREN ...
             </summary>
        </member>
        <member name="M:wx.Frame.ShowFullScreen(System.Boolean,wx.Fullscreen)">
            <summary> Depending on the value of show parameter the window is either shown full screen or restored to its normal
            state.
            <c>style</c> is a bit list containing some or all of the following
            values, which indicate what elements of the window to hide in
            full-screen mode:
            
            This function has not been tested with MDI frames.
            Note that showing a window full screen also actually Show()s if it
            hadn't been shown yet. </summary>
        </member>
        <member name="M:wx.Frame.ShowFullScreen(System.Boolean)">
            <summary>The window is either shown full screen.
            This function has not been tested with MDI frames.
            Note that showing a window full screen also actually Show()s if it
            hadn't been shown yet. </summary>
        </member>
        <member name="M:wx.Frame.CreateToolBar">
            <summary>
            Create a toolbar of undefined ID and name (of the toolbar control) "toolBar".
            </summary>
            <returns>The created toolbar.</returns>
        </member>
        <member name="M:wx.Frame.CreateToolBar(wx.WindowStyles)">
            <summary>
            Create a toolbar of undefined ID and name (of the toolbar control) "toolBar".. 
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="M:wx.Frame.CreateToolBar(wx.WindowStyles,System.Int32)">
            <summary>
            Create a toolbar with name (of the toolbar control) "toolBar".
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <param name="id">Window ID of the toolbar.</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="M:wx.Frame.CreateToolBar(wx.WindowStyles,System.Int32,System.String)">
            <summary>
            Create a toolbar. 
            </summary>
            <param name="style">Window styles to be used. Specific styles have names starting with "TB_".</param>
            <param name="id">Window ID of the toolbar.</param>
            <param name="name">Name of the window.</param>
            <returns>The created toolbar.</returns>        
        </member>
        <member name="P:wx.Frame.Icon">
            <summary>
            Get or set the icon that will be displayed in the window decorator or when iconifying.
            </summary>
        </member>
        <member name="P:wx.Frame.MenuBar">
            <summary>
            The menu bar of this instance.
            You may get the current instance using this property or set
            a new menu bar assigning to this property.
            </summary>
        </member>
        <member name="P:wx.Frame.Iconized">
            <summary>
            True iff the frame has been iconized. This is false if the frame has been deallocated.
            </summary>
        </member>
        <member name="P:wx.Frame.Maximized">
            <summary>
            True iff the frame has been iconized. This is false if the frame has been deallocated.
            </summary>
        </member>
        <member name="P:wx.Frame.DefaultItem">
            <summary>
            Get or set the default item.
            This usually is a button.
            </summary>
        </member>
        <member name="M:wx.FontDialog.Create(wx.Window,wx.FontData)">
            <summary>
            Create the dialog.
            </summary>
            <param name="parent">The parent window of the dialog. This may be <c>null</c>.</param>
            <param name="data">The initially selected font.</param>
            <returns></returns>
        </member>
        <member name="M:wx.FontDialog.ShowModal">
            <summary>Modal display of the dialog. Returns whether input has been confirmed or cancelled.
            </summary>
        </member>
        <member name="P:wx.FontDialog.FontData">
            <summary>
            The font that has been selected by the user.
            </summary>
        </member>
        <member name="T:wx.ControlWithItems">
            <summary>
            base class of some controls presenting a list of items.
            </summary>
        </member>
        <member name="T:wx.Control">
            <summary>This is the base class for a control or "widget''.
             A control is generally a small window which processes user input and/or displays one or more item of data.
            </summary>
        </member>
        <member name="M:wx.ControlWithItems.SetString(System.Int32,System.String)">
            <summary>Set the label of the entry of index <c>n</c>.
            Refer also to the indexer of this class.
            </summary>
        </member>
        <member name="M:wx.ControlWithItems.GetString(System.Int32)">
            <summary>Get the label of the entry of index <c>n</c>.
             Refer also to the indexer of this class.
            </summary>
        </member>
        <member name="M:wx.ControlWithItems.FindString(System.String)">
            <summary>Finds an item whose label matches the given string.</summary>
            <returns> The zero-based position of the item, or -1 if the string was not found.</returns>
        </member>
        <member name="M:wx.ControlWithItems.SetStringSelection(System.String)">
            <summary>Select the designated label. Return <c>true</c> on success and <c>false</c> otherwise.
             Refer also to property <c>StringSelection()</c>.
            </summary>
        </member>
        <member name="M:wx.ControlWithItems.GetClientObject(System.Int32)">
            <summary>Reads client data for item <c>n</c>.
            </summary>
        </member>
        <member name="M:wx.ControlWithItems.Append(System.String[])">
            \name Maintaining items.
        </member>
        <member name="M:wx.ControlWithItems.Append(System.String,wx.ClientData)">
            <summary>This will append <c>item</c> to the end of the item list and associate it with the provided client data.
             The client data may be <c>null</c>.
            </summary> 
             <returns> The index of the new item.</returns>
        </member>
        <member name="M:wx.ControlWithItems.Insert(System.String,System.Int32,wx.ClientData)">
            <summary>Inserts the item into the list before pos, associating the given, typed or untyped, client data pointer with the item.
            Not valid for ListBox.wxLB_SORT or ComboBox.wxCB_SORT styles, use Append() instead.</summary>
            <returns> The return value is the index of the newly inserted item. If the insertion failed for some reason, -1 is returned.</returns>
        </member>
        <member name="M:wx.ControlWithItems.Clear">
            <summary>Deletes all items.
            </summary>
        </member>
        <member name="P:wx.ControlWithItems.StringSelection">
            <summary>Also refer to method SetStringSelection() that returns a Boolean that is true on success and false otherwise.
            </summary>
        </member>
        <member name="P:wx.ControlWithItems.Count">
            <summary>Returns the number of items.
            </summary>
        </member>
        <member name="P:wx.ControlWithItems.IsEmpty">
            <summary>True iff this is empty.
            </summary>
        </member>
        <member name="P:wx.ControlWithItems.Strings">
            <summary>All the currently known labels.
             Read only property. Alternatively, use the indexer of this class.
            </summary>
        </member>
        <member name="P:wx.ControlWithItems.Item(System.Int32)">
            <summary>This is equivalent to the methods GetString() and SetString().
            </summary>
        </member>
        <member name="T:wx.Colour">
            <summary>This class represents colours.
            </summary>
        </member>
        <member name="T:wx.ICanBeMadeReadonly">
            <summary>
            Objects implement this interface if they can be readonly. In that case, all 
            calls to modifiers will cause exceptions of class  CannotChangeReadonly.
            </summary>
        </member>
        <member name="M:wx.ICanBeMadeReadonly.MakeReadOnly">
            <summary>
            From this call, all calls to modifiers will cause exceptions.
            This shall return <c>this</c>.
            </summary>
        </member>
        <member name="P:wx.ICanBeMadeReadonly.IsReadonly">
            <summary>
            If this is true, all modifiers will cause exceptions. If this is false,
            modfiers can be used.
            </summary>
        </member>
        <member name="F:wx.Colour.wxALPHA_TRANSPARENT">
            <summary>This is the APLPHA value indicating transparency.
            </summary>
        </member>
        <member name="F:wx.Colour.wxALPHA_OPAQUE">
            <summary>This is the APLPHA value indicating opaque colour.
            </summary>
        </member>
        <member name="M:wx.Colour.Set(System.Byte,System.Byte,System.Byte)">
            <summary>Assign RGB values.</summary>
        </member>
        <member name="M:wx.Colour.Set(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Assign RGB and Alpha values.</summary>
        </member>
        <member name="M:wx.Colour.Set(wx.wxString)">
            <summary>
            Set RGB values from the provided string.
            Set() accepts: colour names (those listed in wxTheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green,
            blue components).
            </summary>
            <param name="str">Colour name, RGB-syntax string or HTML-like colour notation</param>
        </member>
        <member name="M:wx.Colour.Set(System.String)">
            <summary>
            Set RGB values from the provided string.
            Set() accepts: colour names (those listed in wxTheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green,
            blue components).
            </summary>
            <param name="str">Colour name, RGB-syntax string or HTML-like colour notation</param>
        </member>
        <member name="M:wx.Colour.GetAsString(wx.Colour.C2S)">
            <summary>Returns the colour in string form according to the provided flags.</summary>
        </member>
        <member name="M:wx.Colour.ToString">
            <summary>Returns a string form representing the colour.
            Implemented by GetAsString().</summary>
        </member>
        <member name="P:wx.Colour.TheColourDatabase">
            <summary>Returns ColourDatabase.TheColourDatabase.
            
            The standard database contains at least the following colours:
            AQUAMARINE, BLACK, BLUE, BLUE VIOLET, BROWN, CADET BLUE, CORAL, CORNFLOWER BLUE, CYAN, DARK GREY,
            DARK GREEN, DARK OLIVE GREEN, DARK ORCHID, DARK SLATE BLUE, DARK SLATE GREY DARK TURQUOISE,
            DIM GREY, FIREBRICK, FOREST GREEN, GOLD, GOLDENROD, GREY, GREEN, GREEN YELLOW, INDIAN RED, KHAKI,
            LIGHT BLUE, LIGHT GREY, LIGHT STEEL BLUE, LIME GREEN, MAGENTA, MAROON, MEDIUM AQUAMARINE, MEDIUM BLUE,
            MEDIUM FOREST GREEN, MEDIUM GOLDENROD, MEDIUM ORCHID, MEDIUM SEA GREEN, MEDIUM SLATE BLUE,
            MEDIUM SPRING GREEN, MEDIUM TURQUOISE, MEDIUM VIOLET RED, MIDNIGHT BLUE, NAVY, ORANGE, ORANGE RED,
            ORCHID, PALE GREEN, PINK, PLUM, PURPLE, RED, SALMON, SEA GREEN, SIENNA, SKY BLUE, SLATE BLUE,
            SPRING GREEN, STEEL BLUE, TAN, THISTLE, TURQUOISE, VIOLET, VIOLET RED, WHEAT, WHITE, YELLOW,
            YELLOW GREEN.</summary>
        </member>
        <member name="T:wx.Colour.C2S">
            <summary>Options for wx.Colour.GetAsString()
            </summary>
        </member>
        <member name="F:wx.Colour.C2S.NAME">
            <summary>return colour name, when possible
            </summary>
        </member>
        <member name="F:wx.Colour.C2S.CSS_SYNTAX">
            <summary>return colour in rgb(r,g,b) syntax
            </summary>
        </member>
        <member name="F:wx.Colour.C2S.HTML_SYNTAX">
            <summary> return colour in #rrggbb syntax.
            </summary>
        </member>
        <member name="T:wx.AcceleratorEntry">
            <summary>
            An entry in the AcceleratorTable.
            </summary>
        </member>
        <member name="T:wx.AcceleratorEntry.AccelFlags">
            <summary>Use this to define any modifier key that has to be pressed together with the provided key code.</summary>
        </member>
        <member name="T:wx.AcceleratorTable">
            <summary>
            An accelerator table allows the application to specify a table of keyboard shortcuts for menu or button commands.
            Initially, windows bear an accelerator table with no data.
            </summary>
        </member>
        <member name="M:wx.AcceleratorTable.#ctor(System.IntPtr)">
            <summary>This is for internal purposes only.
            This CTor will be used on creating wrappers for internally created instances.</summary>
        </member>
        <member name="M:wx.AcceleratorTable.#ctor">
            <summary>Creates a NULL accelerator table.</summary>
        </member>
        <member name="M:wx.AcceleratorTable.#ctor(wx.AcceleratorEntry[])">
            <summary>Creates an accelerator table from an array of accelerator entries.</summary>
        </member>
        <member name="M:wx.CommandEvent.#ctor(System.Int32,System.Int32)">
            <summary>Refer to wx.Event for available values for <c>evtType</c>.
            </summary>
            <param name="evtType">The type of the created event, e.g. Event.wxEVT_COMMAND_TEXT_ENTER</param>
            <param name="winId">The id of the windows that fires the event.</param>
        </member>
        <member name="M:wx.CommandEvent.#ctor(System.Int32)">
            <summary>Refer to wx.Event for available values for <c>evtType</c>.
            </summary>
        </member>
        <member name="T:wx.Printout">
            <summary>
            This class encapsulates the functionality of printing out an application document.
            A new class must be derived and members overridden to respond to calls such as OnPrintPage() and HasPage()
            and to render the print image onto an associated wx.DC. Instances of this class are passed to wx.Printer.Print()
            or to a wx.PrintPreview object to initiate printing or previewing.
            </summary>
            <remarks>
            Your derived wx.Printout is responsible for drawing both the preview image and the printed page. If your windows'
            drawing routines accept an arbitrary DC as an argument, you can re-use those routines within your wxPrintout subclass
            to draw the printout image. You may also add additional drawing elements within your wx.Printout subclass,
            like headers, footers, and/or page numbers. However, the image on the printed page will often differ from the
            image drawn on the screen, as will the print preview image -- not just in the presence of headers and footers,
            but typically in scale. A high-resolution printer presents a much larger drawing surface (i.e., a higher-resolution
            DC); a zoomed-out preview image presents a much smaller drawing surface (lower-resolution DC). By using the routines
            <c>FitThisSizeToXXX()</c> and/or <c>MapScreenSizeToXXX()</c> within your wxPrintout subclass to set the user scale
            and origin of the associated DC, you can easily use a single drawing routine to draw on your application's windows,
            to create the print preview image, and to create the printed paper image, and achieve a common appearance to the
            preview image and the printed page.
            </remarks>
        </member>
        <member name="T:wx.Html.HtmlCond">
            <summary>Conditions for HtmlCell.Find().</summary>
        </member>
        <member name="F:wx.Html.HtmlCond.IS_ANCHOR">
            <summary>Finds the anchor of 'param' name (argument is a string).</summary>
        </member>
        <member name="F:wx.Html.HtmlCond.IS_IMAGEMAP">
            <summary>Finds imagemap of 'param' name (argument is a string).</summary>
        </member>
        <member name="T:wx.Html.HtmlFind">
            <summary>Refer to HtmlCell.FindCellByPos().</summary>
        </member>
        <member name="T:wx.Html.HtmlWindow">
            <summary>A window displaying (reduced) HTML formatted text.
            </summary>
            <remarks>
            \image html helpview.jpg
            </remarks>
        </member>
        <member name="T:wx.ScrolledWindow">
            <summary>The wx.ScrolledWindow class manages scrolling for its client area, transforming the coordinates according to the scrollbar positions, and setting the scroll positions, thumb sizes and ranges according to the area in view.
             Starting from version 2.4 of wxWidgets, there are several ways to use a
             wx.ScrolledWindow. In particular, there are now three ways to set the size of
             the scrolling area:
             One way is to set the scrollbars directly using a call to
             wx.ScrolledWindow.SetScrollbars(). This is the way it used to be in any previous
             version of  wxWidgets and it will be kept for backwards compatibility.
            
             An additional method of manual control, which requires a little less computation
             of your own, is to set the total size of the scrolling area by calling either
             wx.Window.VirtualSize, or wx.Window.FitInside(), and setting the scrolling
             increments for it by calling wx.ScrolledWindow.SetScrollRate(). Scrolling in some
             orientation is enabled by setting a non-zero increment for it.
            
             The most automatic and newest way is to simply let sizers determine the scrolling
             area. This is now the default when you set an interior sizer into a
             wx.ScrolledWindow with wx.Window.SetSizer. The scrolling area will be set to the
             size requested by the sizer and the scrollbars will be assigned for each
             orientation according to the need for them and the scrolling increment set by
             wx.Scrolled.Window.SetScrollRate. As above, scrolling is only enabled in
             orientations with a non-zero increment. You can influence the minimum size of the
             scrolled area controlled by a sizer by calling wx.Window.SetVirtualSizeHints().
            
             Note: if Maximum size hints are still supported by SetVirtualSizeHints(), use
             them at your own dire risk. They may or may not have been removed for 2.4, but it
             really only makes sense to set minimum size hints here. We should probably replace
             SetVirtualSizeHints() with SetMinVirtualSize() or similar and remove it entirely
             in future.
            
             As with all windows, an application can draw onto a wx.ScrolledWindow using a
             device context.
            
             You have the option of handling the OnPaint handler or overriding the <c>OnDraw()</c>
             function, which is passed a pre-scrolled device context (prepared by <c>DoPrepareDC)</c>.
            
             If you don't wish to calculate your own scrolling, you must call <c>DoPrepareDC</c> when
             not drawing from within <c>OnDraw</c>, to set the device origin for the device context
             according to the current scroll position.
            
             A wx.ScrolledWindow will normally scroll itself and therefore its child windows as
             well. It might however be desired to scroll a different window than itself: e.g.
             when designing a spreadsheet, you will normally only have to scroll the
             (usually white) cell area, whereas the (usually grey) label area will scroll very
             differently. For this special purpose, you can call <c>SetTargetWindow</c> which means
             that pressing the scrollbars will scroll a different window.
            
             Note that the underlying system knows nothing about scrolling coordinates, so that
             all system functions (mouse events, expose events, refresh calls etc) as well as
             the position of subwindows are relative to the "physical" origin of the scrolled
             window. If the user insert a child window at position (10,10) and scrolls the
             window down 100 pixels (moving the child window out of the visible area), the
             child window will report a position of (10,-90).
            
             Remarks:
             Use wx.ScrolledWindow for applications where the user scrolls by a fixed amount,
             and where a 'page' can be interpreted to be the current visible portion of the
             window. For more sophisticated applications, use the wx.ScrolledWindow
             implementation as a guide to build your own scroll behaviour.
            
             See also wx.ScrollBar, wx.ClientDC, wx.PaintDC, and wx.VScrolledWindow.</summary>
        </member>
        <member name="T:wx.Panel">
            <summary>A panel is a window on which controls are placed.
             It is usually placed within a frame. It contains minimal extra functionality over and above its parent
             class wx.Window; its main purpose is to be similar in appearance and functionality to a dialog, but with
             the flexibility of having any window as a parent.
            
             Note: if not all characters are being intercepted by your OnKeyDown or OnChar handler, it may be because you are
             using the wx.WindowStyles.TAB_TRAVERSAL style, which grabs some keypresses for use by child controls.</summary>
        </member>
        <member name="M:wx.Panel.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,wx.wxString)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.#ctor(wx.Window,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.#ctor(wx.Window,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.Create(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.Panel.Create(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,wx.wxString)">
            <summary>Do not forget to use style wx.WindowStyles.TAB_TRAVERSAL if you want this panel to be traversal.</summary>
        </member>
        <member name="M:wx.ScrolledWindow.GetViewStart(System.Int32@,System.Int32@)">
            <summary>Get the position at which the visible portion of the window starts.
             \params x Receives the first visible x position in scroll units.
             \params y Receives the first visible y position in scroll units.
            
             If either of the scrollbars is not at the home position, x and/or y will be greater than zero.
             Combined with wx.Window.ClientSize, the application can use this function to efficiently redraw only the
             visible portion of the window. The positions are in logical scroll units, not pixels, so to convert to pixels
             you will have to multiply by the number of pixels per scroll increment.
             See also wx.ScrolledWindow.SetScrollbars()</summary>
        </member>
        <member name="M:wx.ScrolledWindow.GetScrollPixelsPerUnit(System.Int32@,System.Int32@)">
            <summary>Get the number of pixels per scroll unit (line), in each direction, as set by wx.ScrolledWindow.SetScrollbars().
            A value of zero indicates no scrolling in that direction.
            <list type="table">
            <item><term>xUnit</term><description> Receives the number of pixels per horizontal unit.</description></item>
            <item><term>yUnit</term><description> Receives the number of pixels per vertical unit.</description></item>
            </list>
            
            See also wx.ScrolledWindow.SetScrollbars(), wx.ScrolledWindow.GetVirtualSize()
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.ScrolledWindow.CalcScrolledPosition(System.Int32,System.Int32,System.Int32@,System.Int32@)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.ScrolledWindow.CalcScrolledPosition(System.Drawing.Point)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.ScrolledWindow.CalcUnscrolledPosition(System.Int32,System.Int32,System.Int32@,System.Int32@)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.ScrolledWindow.CalcUnscrolledPosition(System.Drawing.Point)" ignoriert -->
        <member name="M:wx.ScrolledWindow.GetVirtualSize">
            <summary>Read the virtual size of the control here.
             Gets the size in device units of the scrollable window area
             (as opposed to the client size, which is the area of the window currently visible).
             \param x Receives the length of the scrollable window, in pixels.
             \param y Receives the height of the scrollable window, in pixels.
            
             Use wx.DC.DeviceToLogicalX() and wx.DC.DeviceToLogicalY() to translate these units to logical units.</summary>
        </member>
        <member name="M:wx.ScrolledWindow.Scroll(System.Int32,System.Int32)">
            <summary>Scrolls to the designated virtual position in scroll units.</summary>
        </member>
        <member name="M:wx.ScrolledWindow.Scroll(System.Drawing.Point)">
            <summary>Scrolls to the designated virtual position in points.
            This will do the translation via GetScrollPixelsPerUnit() for you.</summary>
        </member>
        <member name="P:wx.ScrolledWindow.ViewStart">
            <summary>Get the position at which the visible portion of the window starts.
            If either of the scrollbars is not at the home position, x and/or y will be greater than zero.
            Combined with wx.Window.ClientSize, the application can use this function to efficiently redraw only the
            visible portion of the window. The positions are in logical pixels, so this is the result of GetViewStart()
            multiplied by the number of pixels per scroll increment.
            </summary>
        </member>
        <member name="P:wx.ScrolledWindow.ScrollPixelsPerUnit">
            <summary>The result of GetScrollPixelsPerUnit() as size.
            This returns the size of a square defining the scroll unit.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.OnNewPage">
            <summary>This has to be called before changing the displayed HTML page.
            This method increments the version counter and will remove the wrappers
            of the currently displayed page if they don't own their memory.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.RegisterWidgetCell(wx.Html.HtmlWidgetCell)">
            <summary>A .NET wx.HtmlWidgetCell will register itself here.
            Reason: ClearWidgetCells().</summary>
            
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.Html.HtmlWindow.SetInvisibleWidgetCells" ignoriert -->
        <member name="M:wx.Html.HtmlWindow.SetPage(System.String)">
            <summary>This will set a new HTML text to be displayed.</summary>
            <param name="source">The HTML source code that shall be displayed.</param>
        </member>
        <member name="M:wx.Html.HtmlWindow.SetPage(wx.wxString)">
            <summary>This will set a new HTML text to be displayed.</summary>
            <param name="source">The HTML source code that shall be displayed.</param>
        </member>
        <member name="M:wx.Html.HtmlWindow.AppendToPage(System.String)">
            <summary>This will append string <c>source</c> to the currently displayed text.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.AppendToPage(wx.wxString)">
            <summary>This will append string \c source to the currently displayed text.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.OnLoadPageEvent(System.Object,wx.Event)">
            <summary>Call this only on wx.CommandEvent().
            This will load the page URL retrieved from the client string wx.CommandEvent.String.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.LoadPage(System.String)">
            <summary>Overload this to change the behaviour on loading a page from the designated location.
            Refer to FSFile and FileSystemHandler for remarks on available locations.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.LoadPage(wx.wxString)">
            <summary>Overload this to change the behaviour on loading a page from the designated location.
            Refer to FSFile and FileSystemHandler for remarks on available locations.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.LoadFile(System.String)">
            <summary>Overload this to change the behaviour on loading a file.
            The argument is a file name in native style.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.LoadFile(wx.wxString)">
            <summary>Overload this to change the behaviour on loading a file.
            The argument is a file name in native style.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SetRelatedFrame(wx.Frame,System.String)">
            <summary>Sets the related frame.
                     * This window will change the title of the related frame according to
                     * the title definition of the displayed HTML text.</summary>
                     * <remarks>
                     * Sample: 
                     <code>
                     m_html.SetRelatedFrame(this, "HTML: %s");
                     </code>
                     * This will display the title according to the displayed HTML page plus
                     * a prefix "HTML:"
                     * </remarks>
        </member>
        <member name="M:wx.Html.HtmlWindow.SetRelatedFrame(wx.Frame,wx.wxString)">
            <summary>Sets the related frame.
            This window will change the title of the related frame according to
            the title definition of the displayed HTML text.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.ReadCustomization(wx.Config)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. WriteCustomization().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.ReadCustomization(wx.Config,System.String)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. WriteCustomization().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.ReadCustomization(wx.Config,wx.wxString)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.WriteCustomization(wx.Config)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. ReadCustomization().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.WriteCustomization(wx.Config,System.String)">
            <summary>The HTML window is able to configure several properties.
            You may read from a particular configuration to reuse settings that have
            been done on previous runs of the appliation.
            Cf. ReadCustomization().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.OnCellMouseHover(wx.Html.HtmlCell,System.Int32,System.Int32)">
            <summary>This will be called when the mouse is moved over the cell.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.OnCellClicked(wx.Html.HtmlCell,System.Int32,System.Int32,wx.MouseEvent)">
            <summary>This is called when the user clicks at a particular cell.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.OnLinkClicked(wx.Html.HtmlLinkInfo)">
            <summary>This is called when the user clicks on a cell representing a hyper link.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SelectAll">
            <summary>This will select the whole text.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SelectLine(System.Drawing.Point)">
            <summary>This will select a line in the text.
            Please note, that this method will not scroll to the selected word.
            Call wx.Window.Scroll().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SelectWord(System.Drawing.Point)">
            <summary>This will select a word that is displayed at the provided position.
            Please note, that this method will not scroll to the selected word.
            Call wx.Window.Scroll().</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SelectCell(wx.Html.HtmlCell)">
            <summary>This will select the content of the provided cell.
            Note, that the provided cell may be a formatting cell. So, you might
            see nothing of the selection.
            
            Please also note, that this method will not scroll the window to
            the selected cell. Call ScrollToCell() for this purpose.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.SelectCells(wx.Html.HtmlCell,wx.Html.HtmlCell)">
            <summary>Additional method to select cells.
            <c>fromCell</c> and <c>lastCell</c> may be the same cell. Otherwise,
            leafs of <c>fromCell</c> must be before those of <c>lastCell</c> when traversing
            the HTML document.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.ScrollToCell(wx.Html.HtmlCell)">
            <summary>This will scroll to the position of the provided cell.</summary><remarks>
            Equivalent to \code this.Scroll(cell.AbsPos) \endcode.</remarks>
        </member>
        <member name="M:wx.Html.HtmlWindow.OpenFindDialog(wx.FindReplaceData)">
            <summary>This will open a find dialog for the current HTML page.
            The result will be <c>true</c> in case of success and <c>false</c> in case of any problem.
            This method will fail to open the dialog if it is already open.
            
            Cf. wx.HtmlWindow.FindDialog and HtmlFindDialog.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.OpenedPage">
            <summary>HTML text displayed by this window.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.Version">
            <summary>This will be incremented whenver the displayed document changes.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.RelatedFrame">
            <summary>Set or gets the related frame.
            This window will change the title of the related frame according to
            the title definition of the displayed HTML text.
            This will simply use "%s" as format for the related frame.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InternalRepresentation">
            <summary>Use this to gain access to the internal representation of the displayed HTML text.
            HTML is displayed as a tree of cells where the container cell represends a node
            with occasionally more than one sibling.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.HasSelection">
            <summary>This is true if the window knows a selection.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.SelectionInfo">
            <summary>Returns a new instance providing information in the current selection.
            The result will be <c>null</c> if nothing is selected.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.Text">
            <summary>This is the displayed HTML as text.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.SelectionText">
            <summary>This is the selected part of the HTML</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.FindDialog">
            <summary>This is a new feature explusive to  wx.NET: A search dialog for searching the presented HTML page.
            This will read the dialog and create one if this has not yet been created.
            You may alteratively use ShowFindDialog() to show the dialog with particular data.</summary>
        </member>
        <member name="T:wx.Html.HtmlWindow.InfoOnSelection">
            <summary>This contains detailled information of a selection if there is any.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindow.InfoOnSelection.#ctor(wx.Html.HtmlWindow)">
            <summary>This will read and store the current information on the provided window.
            This will throw an exception if the argument does not have a selection.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.Window">
            <summary>This is the window where the selection has been recorded.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.FromPosition">
            <summary>This will return the position where the current selection starts.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.ToPosition">
            <summary>This will return the position where the current selection ends.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.FromCell">
            <summary>This is the first cell of selected content.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.ToCell">
            <summary>This is the last cell of selected content.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindow.InfoOnSelection.Text">
            <summary>Returns the selected text.</summary>
        </member>
        <member name="T:wx.Html.HtmlTerminalCellIterator">
            <summary>This is a pure .NET 2 implementation iterating over terminal siblings of an wx.HtmlCell.
            You may turn this off defining <c>NET_1_1_ONLY</c> on compilation.
            
            You may increment or decrement the iterator. The iterator will complete a list of all
            terminal cells on demand. Once this list has been created, it will not be maintained. So,
            you probably will encounter problems if you edit cells while iterating thair siblings.
            </summary>
        </member>
        <member name="F:wx.Html.HtmlTerminalCellIterator._currentCellSelection">
            <summary>This will be used if searching for consecutive words to record the text
            content of previously selected cells (wx.FindReplaceFlags.WHOLEWORD).</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.#ctor(wx.Html.HtmlCell)">
            <summary>This will iterate all relevant cells that are siblings of <c>root</c>.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.#ctor(wx.Html.HtmlCell,wx.Html.HtmlCell)">
            <summary>This will iterate all relevant cells that are siblings of <c>root</c> starting  after <c>start</c>.
            The start of iteration is not defined if <c>start</c> is not a sibling of
            <c>root</c>.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.LoadFindString(System.String,wx.FindReplaceFlags@)">
            <summary>Central private method to create an array of words that will be used as a filter for terminal cells.
            Use double quotes to suppress splitting.
            </summary>
            <param name="findFlags"> defines the mode of the search (that might influence normalization
                   of the find string) and will be changed if the find string comprises mode specifications.
                   If the find string is quoted by either single or double quotes, mode will switch to
                   searching for whole words. In that case, the words in the find string do not define
                   alternatives for matching but a sequence of constraints that have to be met.
            </param>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.#ctor(wx.Html.HtmlCell,System.String,wx.FindReplaceFlags)">
            <summary>Enumerates terminal cells below <c>root</c> that comprise text complying with <c>findString</c>.
            The text contents complies with <c>findString</c> if it is a word from <c>findString</c>.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.#ctor(wx.Html.HtmlCell,wx.Html.HtmlCell,System.String,wx.FindReplaceFlags)">
            <summary>Enumerates terminal cells below <c>root</c> starting at position after <c>start</c> that comprise text complying with <c>findString</c>.
            The text contents complies with <c>findString</c> if it is a word from <c>findString</c>.
            
            Refer to the remarks on the CTor defining a start position without a find string for
            details on setting the start position.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.MoveNext">
            <summary>Moves one position forward to the next element.
            This must be called once before reading a current element.
            this will return <c>true</c> iff more elements exist in this direction.</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.Reset">
            <summary>Moves the iterator back to the initial position before the first element or behind the next.</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.SelectCurrent(wx.Html.HtmlWindow)">
            <summary>Selects in the argument according to the currently enumerated selection.
            This iterator enumerated cells but also selections that may comprise more than
            cell. The current cell is always the last cell of this selection. However, if
            this searches for more than one word (searching e.g. for a quoted find string),
            then the resulting selection will comprise also cells preceeding the current.
            This iterator keeps track of this. So, if you want select in the searched dialog
            acording to this iterator, use this method.
            
            Please note: <c>wnd</c> must comprise the root of this document.</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.EquivalentToFindString(System.String,wx.FindReplaceFlags)">
            <summary>This is <c>true</c> iff the argument is equivalent to the currently used find string.</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.MoveBack">
            <summary>Moves back to the previous position.
            If the current position is the initial position, this will move to
            the last terminal cell.
            The result will be <c>true</c> iff more elements exist in this direction.</summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.CompliesWithFindString(System.String)">
            <summary>Use this to test text associated with a HTML cell agains the find string.
            If this iterator does filter according to string input, this is always <c>true</c>.
            
            This method will be used within IsCellRelevant() to test with resp. to a find string.
            You may either reuse this in alternative implementations of IsCellRelevant() or
            you may replace this to implement alternative filters regarding text.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.CompliesWithFindString(System.String[])">
            <summary>Use this to test text associated with a HTML cell agains the find string.
            If this iterator does filter according to string input, this is always <c>true</c>.
            
            This method will be used within IsCellRelevant() to test with resp. to a find string.
            You may either reuse this in alternative implementations of IsCellRelevant() or
            you may replace this to implement alternative filters regarding text.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.IsCellRelevant(System.Collections.Generic.Queue{wx.Html.HtmlCell})">
            <summary>Overload this to implement iterators selecting non-terminal or more specific terminal nodes.
            This method will be asked before selecting a new Current() node on MoveNext() and
            MoveBack(). This must be true for all Current() nodes.
            
            Overload and change this to select different classes of nodes.
            
            Currently, this will select terminal nodes which are not formatting nodes.
            If this iterations defines a find string then this method will also take
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.IsCellRelevant(wx.Html.HtmlCell)">
            <summary>Overload this to implement iterators selecting non-terminal or more specific terminal nodes.
            This method will be asked before selecting a new Current() node on MoveNext() and
            MoveBack(). This must be true for all Current() nodes.
            
            Overload and change this to select different classes of nodes.
            
            Currently, this will select terminal nodes which are not formatting nodes.
            If this iterations defines a find string then this method will also take
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTerminalCellIterator.FindNextNode(wx.Html.HtmlCell)">
            <summary>This method will return the next relevant cell after <c>current</c>.
            You may pass <c>null</c> as an argument. In that case, this will start with
            <c>root</c>.
            This will return <c>null</c> if this cannot find a next relevant cell.
            </summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.CallbackProgressReport">
            <summary>Set this if you want a specific function to be called regularly during search.
            This function may terminate the search returning <c>false</c>.
            </summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.FindString">
            <summary>The original strings that this dialog shall find.
            You may also set this here.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.NumberOfFoundCells">
            <summary>Returns the number of yet found cells that comply.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.VisitedAllRelevantCells">
            <summary>True iff all relevant cells have been visited at least once.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.FindFlags">
            <summary>These are the flags that will be used for searching the HTML page.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.ListOfCells">
            <summary>This is a list of all cells that will be enumerated by this enumerator.
            \b Do \b not \b modify \b this.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.RelevantCells">
            <summary>The array of relevant cells.</summary>
        </member>
        <member name="P:wx.Html.HtmlTerminalCellIterator.FindStrings">
            <summary>Returns the array of words that this instance uses as a filter.
            This might be <c>null</c>;</summary>
        </member>
        <member name="T:wx.Html.HtmlTerminalCellIterator.DelegateProgressReport">
            <summary>Something of this kind will be called on searching.
            \param current snd <c>end</c> specify a measure for the progress. 
            \param end is the end point for current on completed search. However, if this
                   is negative, progress report is not supported.
            
            You may return <c>false</c> in order to stop searching and <c>true</c> to proceed.</summary>
        </member>
        <member name="T:wx.Html.HtmlFindDialog">
            <summary>This is a dialog supporting finding strings in HTML cells.
            You will normally not create this on your own but use wx.HtmlWindow.OpenFindDialog()
            to open this.</summary>
        </member>
        <member name="T:wx.FindReplaceDialog">
            <summary>wx.FindReplaceDialog is a standard modeless dialog which is used to allow the user to search for some text
            (and possibly replace it with something else).
            The actual searching is supposed to be done in the owner window which is the parent of this
            dialog. Note that it means that unlike for the other standard dialogs this one must have a
            parent window. Also note that there is no way to use this dialog in a modal way; it is
            always, by design and implementation, modeless (non-modal).
            
            The dialog issues a FindDialogEvent if a search has been requested.
            
            Currently only one find dialog is supported. So, if you create them on the fly,
            be sure to place them in <c>using</c> environments to ensure early finalization.</summary>
        </member>
        <member name="M:wx.FindReplaceDialog.#ctor(wx.Window,wx.FindReplaceData,System.String,wx.WindowStyles)">
            <summary>* Use dialog styles here. Specific styles will start with prefix FR_.</summary>
        </member>
        <member name="P:wx.FindReplaceDialog.Data">
            <summary>Use this to change the data model.
            This is virtual to enable implementations extending this dialog which have to react
            on changes in the data model.</summary>
        </member>
        <member name="E:wx.FindReplaceDialog.Find">
            <summary>The unique listener for the "find" event.</summary>
        </member>
        <member name="E:wx.FindReplaceDialog.FindNext">
            <summary>The unique listener for the "find next" event.</summary>
        </member>
        <member name="E:wx.FindReplaceDialog.FindReplace">
            <summary>The unique listener for the "find/replace" event.</summary>
        </member>
        <member name="E:wx.FindReplaceDialog.FindReplaceAll">
            <summary>The unique listener for the "find/replace all" event.</summary>
        </member>
        <member name="M:wx.Html.HtmlFindDialog.DoFind">
            <summary>Act as if [ENTER] has been pressed in the search string control.</summary>
        </member>
        <member name="M:wx.Html.HtmlFindDialog.DoFindNext">
            <summary>Act as if the "find next" button has been pressed.</summary>
        </member>
        <member name="P:wx.Html.HtmlFindDialog.State">
            <summary>True if this dialog is currently searching. 
            If this is <c>true</c>, all further actions will be aborted.</summary>
        </member>
        <member name="F:wx.Html.HtmlWindowWithSearch.TextBgOnError">
            <summary>Background of the search text will switch to this colour if the specified text cannot be found.</summary>
        </member>
        <member name="F:wx.Html.HtmlWindowWithSearch.TextBgOnCompletedSearch">
            <summary>Background of the search text will switch to this colour if all occurances of the search text have been found but the search can be restarted.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.#ctor">
            <summary>This is for two step construction.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.CreateHtmlWindow">
            <summary>You may overload this if you want to have a specialization of this class dealing with specific HTML windows.
            The result mus have <c>this</c> as parent.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.Bell">
            <summary>This is the bell on error or completed search.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.ShowSearchPanel(System.Boolean)">
            <summary>This will show or hide the search panel.
            Run with <c>true</c> to show and with <c>false</c> to hide the search panel.
            
            This will initialize the search text with the current selection of
            the search panel becomes visible because of this method call.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.ShowSearchPanel(System.Boolean,System.Boolean)">
            <summary>This will show or hide the search panel.
            Run with <c>true</c> to show and with <c>false</c> to hide the search panel.
            \param pickCurrentSelection will cause this method with <c>true</c> to initialize
                   the search text with the current selection.</summary>
        </member>
        <member name="M:wx.Html.HtmlWindowWithSearch.ToggleSearchPanel">
            <summary>Changes visibility of the internal search panel.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindowWithSearch.Html">
            <summary>This is the encapsulated HTML window.</summary>
        </member>
        <member name="P:wx.Html.HtmlWindowWithSearch.IsSearchPanelShown">
            <summary>True iff the integrated search panel is shown.</summary>
        </member>
        <member name="T:wx.Html.HtmlFontCell">
            <summary>A wx.HtmlCell containing font information.</summary>
        </member>
        <member name="T:wx.Html.HtmlCell">
            <summary>Internal representation of HTML in a wx.HtmlWindow.
            HTML is represented as a tree of nodes, the so-called cells.
            The framework uses several classes of nodes.
            
            Please note, that the current implementation might not call all virtual methods.</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.HtmlCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="F:wx.Html.HtmlCell._siblings">
            <summary>This will hold all wrappers of siblings if this is a root node.
            DisposeAllNonOwners() depends on this.</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.RelativePos(wx.Html.HtmlCell)">
            <summary>This returns the position of this cell relative to the argument.
            The argument shall be a parent or a parent of the parent etc.</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.GetTextUpToLength(System.Int32)">
            <summary>This will load all texts from this node or the children up to the maximum length.
            Words will be separated by a single blank.</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.IsBefore(wx.Html.HtmlCell)">
            <summary>Returns true if the cell appears before 'cell' in natural order of cells (as they are read).
             If cell A is (grand)parent of cell B, then both A.IsBefore(B) and B.IsBefore(A)
             returns true.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlCell.SetPos(System.Int32,System.Int32)">
            <summary>Deprecated: Use property <c>pos</c>.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.Html.HtmlCell.Draw(wx.DC,System.Int32,System.Int32,System.Int32,System.Int32)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.Html.HtmlCell.Draw(wx.DC,System.Int32,System.Int32,System.Int32,System.Int32,wx.Html.HtmlRenderingInfo)" ignoriert -->
        <member name="M:wx.Html.HtmlCell.Find(wx.Html.HtmlCond,System.String)">
            <summary>This method returns the first cell complying with the designated condition referring to the provided string.</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.Find(wx.Html.HtmlCond,wx.Object)">
            <summary>This method returns a pointer to the FIRST cell for that the condition is true.</summary>
                     * <remarks>
                     * It first checks if the condition is true for this
                     * cell and then calls the next ones. (Note: it checks
                     * all subcells if the cell is container).
                     * Condition is unique condition identifier (see htmldefs.h)
                     * (user-defined condition IDs should start from 10000)
                     * and param is optional parameter
                     * Example:
                     * \code
                     cell.Find(HtmlCond.IS_ANCHOR, "news");
                     \endcode
                     * returns pointer to anchor news.
                     * </remarks>
        </member>
        <member name="M:wx.Html.HtmlCell.FindCellByPos(System.Drawing.Point)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.FindCellByPos(System.Int32,System.Int32)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.FindCellByPos(System.Drawing.Point,wx.Html.HtmlFind)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="M:wx.Html.HtmlCell.FindCellByPos(System.Int32,System.Int32,wx.Html.HtmlFind)">
            <summary>Find a cell which is part of this one according to the provided position relative to this cell.
            Cf. RelativePos().</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.PosX">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.PosY">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.Pos">
            <summary>This is the position of the cell within its parent.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.AbsPos">
            <summary>This returns the absolute position of the cell relative to the root.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.FirstChild">
            <summary>First cell that is part of this node.
            Follow the HtmlCell.Next() cells to enumerate all direct siblings of this node.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.FirstTerminal">
            <summary>First terminal cell below.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.LastTerminal">
            <summary>Last terminal cell below.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.Text">
            <summary>The contained text.</summary>
        </member>
        <member name="P:wx.Html.HtmlCell.Link">
            <summary>Get or set the information on contained hyper link.
            Note, that this infor may be <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlFontCell.HtmlFontCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="T:wx.Html.HtmlColourCell">
            <summary>A wx.HtmlCell containing colour information.</summary>
        </member>
        <member name="M:wx.Html.HtmlColourCell.HtmlColourCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="T:wx.Html.HtmlWidgetCell">
            <summary>The wrapper for the <c>wxHtmlWidgetCell</c> of  wxWidgets.
            Please note, that the  wx.NET system uses a specialization of <c>wxHtmlWidgetCell</c>
            that contains some fixes.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlWordCell.HtmlWordCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="T:wx.Html.HtmlContainerCell">
            <summary>Internal representation of HTML in a wx.HtmlWindow.
            HTML is represented as a tree of nodes, the so-called cells.
            The framework uses several classes of nodes. This class represends a node that
            occasionally has more than one sibling.
            
            Please note, that the current implementation might not call all virtual methods.
            
            Note, that the HtmlCell.Next cell is the next cell of the HtmlCell.Parent.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlContainerCell.HtmlContainerCell_GetWxClassInfo">
            <summary>Returns Ptr to the  wxWidgets RTTI.</summary>
        </member>
        <member name="M:wx.Html.HtmlParser.FindObject(System.IntPtr)">
            <summary>A virtual construction of a  wx.NET parser object from a pointer to a  wxWidgets parser object.
            Use this method to ensure existance of an appropriate wrapper for a HTML parser object.
            Problem:  wxWidgets knows 2 classes: The general <c>wxHtmlParser</c> and the <c>wxHtmlWinParser</c>.
            This will return (and create of not existing) an instance of wx.HtmlWinParser iff the
            argument is a pointer to a <c>wxHtmlWinParser</c> instance. This method will use the internal
            run time type information built into  wxWidgets.
            
            Consider this as a specialization of method wx.Object.FindObject().
            
            <c>IntPtr.Zero</c> will always result into <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Html.HtmlParser.FS">
            <summary>.NET form of <c>wxHtmlParser</c>::GetFS() and <c>wxHtmlParser</c>::SetFS().
            Please note, on setting the file system of the parser: The HTML parser
            will take control of the native C++ instance that is wrapped by assigned
            instance of wx.FileSystem. So, the .NET wrapper must have memory ownership of
            instances, that will be assigned to this property. Otherwise, this will raise
            an exception.</summary>
        </member>
        <member name="T:wx.Html.HtmlTagHandler">
            <summary>Overload this and add this to an HtmlParser to define new tags.
            The typical use of tag handlers is the definition of new tags that designate
            forms which have been implemented as  wxWidgets panels. Refer to wx.HtmlHelpFrame.OnAboutBox()
            for a simple example.
            
            Refer to HtmlButtonTagHandler for a tag presenting a button that raises a CommandEvent.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlTagHandler.GetSupportedTags">
            <summary>Use this to define the tags that this handler implements.
            Return a comma-separated list of tag names like "I,B,FONT,P".
            
            Please note, that in contrast to modern XML-compatible conventions  wxWidgets 
            uses upper case letters as standard form for tag names. For this reason,  wx.NET
            will convert th result of this method automatically into upper case form. However,
            analogous code in C++ will probably not run with the original  wxWidgets in C++ if
            this result contains lower case letters.</summary>
        </member>
        <member name="M:wx.Html.HtmlTagHandler.HandleTag(wx.Html.HtmlTag)">
            <summary>Implement the tags as defined by GetSupportedTags().</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.Html.HtmlButtonTagHandler" ignoriert -->
        <member name="M:wx.Html.HtmlButtonTagHandler.GetSupportedTags">
            <summary> Handler for HTML tag "WXBUTTON".
            Please note, that in contrast to modern XML-compatible conventions  wxWidgets 
            uses upper case letters as standard form for tag names. So, use upper class letters
            here exclusively.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlButtonTagHandler.HandleTag(wx.Html.HtmlTag)">
            <summary>This generates a window with a single button to be placed into the HTML page.
            Return value is false to enable inner parsing.</summary>
        </member>
        <member name="T:wx.Html.HtmlButtonTagHandler.CmdClosure">
            <summary>This contains the <c>eventstr</c> if one is specified and this implements the addition of the event string to the event.</summary>
        </member>
        <member name="M:wx.Html.HtmlButtonTagHandler.CmdClosure.OnButtonSelect(System.Object,wx.Event)">
            <summary>This will complete the button event if an event string has been specified by the hyperlink.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.Html.HtmlOptionTagHandler" ignoriert -->
        <member name="M:wx.Html.HtmlOptionTagHandler.GetSupportedTags">
            <summary> Handler for HTML tag "WXOPTION".
            </summary>
        </member>
        <member name="M:wx.Html.HtmlOptionTagHandler.HandleTag(wx.Html.HtmlTag)">
            <summary>This generates a window with a check box to be placed into the HTML page.
            Return value is false to enable inner parsing.</summary>
        </member>
        <member name="T:wx.Html.HtmlArtProviderTagHandler">
            <summary>Tag presenting a bitmap from an art provider.</summary>
            <remarks>
            Tag is WXART, legal attributes are 
            <list type="table">
            <item><term> ARTID</term><description> with a string describing an art id as argument. The string will be converted to
                upper case letters and the prefix "wxART_" will be added. The result will be passed to
                the parser of enumeration wx.ArtID. Example: Value "cross_mark" will be converted to
                "wxART_CROSS_MARK" that will be parsed to wx.ArtID.wxART_CROSS_MARK. However, you may also
                pass "wxART_CROSS_MARK" directly as attribute or a number representing the index
                of the art work.
                This attribute is mandatory.
                </description></item>
            <item><term> WIDTH</term><description> is a number providing the desired size in X direction.</description></item>
            <item><term> HEIGHT</term><description> is a number providing the desired size in Y direction.</description></item>
            <item><term> CLIENT</term><description> is analog to ARTID a string describing an element of wx.ArtClient with our without prefix.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:wx.Html.HtmlArtProviderTagHandler.GetSupportedTags">
            <summary>"WXART"</summary>
        </member>
        <member name="M:wx.Html.HtmlArtProviderTagHandler.HandleTag(wx.Html.HtmlTag)">
            <summary>This generates a window presenting an image of the specified size.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.Html.HtmlChoiceTagHandler" ignoriert -->
        <member name="M:wx.Html.HtmlChoiceTagHandler.#ctor(wx.Html.HtmlChoiceTagHandler.Style,System.String,System.Drawing.Size,System.Int32)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
            <param name="id">The window id of the choice dialog. This may be overridden by attribute ID.</param>
            <param name="size">The size of the control in pixel.</param>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.#ctor(wx.Html.HtmlChoiceTagHandler.Style,System.String,System.Int32)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
            <param name="id">The window id of the choice dialog. This may be overridden by attribute ID.</param>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.#ctor(wx.Html.HtmlChoiceTagHandler.Style,System.String)">
            <summary>
            Creates a handler.
            </summary>
            <param name="style">The style (appearance) of the switch/choice-control.</param>
            <param name="tag">The HTML tag that this handler implements.</param>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.Append(System.String)">
            <summary>Adds an item to the control without any command associated.</summary>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.Append(System.String,System.Int32)">
            <summary>Add an item to the control.
             Selecting the item will cause a command event that may be processed in surrounding
             windows.
            </summary>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.Append(System.String,System.String)">
            <summary>Add an item to the control loading a URL on selection.</summary>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.Append(System.String,System.Object)">
            <summary>
            this creates a choice with attached client data.
            </summary>
            <param name="item">The name of the item.</param>
            <param name="clientdata">The client data.</param>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.FindItem(System.String)">
            <summary>Find the provided item string and return its index on success or -1 otherwise.</summary>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.FindCmd(System.Int32)">
            <summary>Find the first item of the provided command ID and return its index on success or -1 otherwise.
            Items are often subject of localization/translation. A neutral designator for
            selecting item is a representation of the action issued by the item. Therefore,
            this method enables a user to select an item issueing a certain command.</summary>
        </member>
        <member name="M:wx.Html.HtmlChoiceTagHandler.FindHyperref(System.String)">
            <summary>Find the first item of the provided hyperref and return its index on success or -1 otherwise.
            Items are often subject of localization/translation. A neutral designator for
            selecting item is a representation of the action issued by the item. Therefore,
            this method enables a user to select an item issueing a new page to be displayed.</summary>
        </member>
        <member name="P:wx.Html.HtmlChoiceTagHandler.SelectionString">
            <summary>Returns or sets the label of the selected item.
            This is an empty string if nothing is selected.
            Please refer to SelectCmd() and SelectHyperref() for alternative methods
            of selecting items.
            
            Assignments trying to select an unknown item will be ignored silently.
            Refer to SelectItem() for an alternative method.</summary>
        </member>
        <member name="T:wx.Html.HtmlTextFieldTagHandler">
            <summary>This tag handler will produce a text field in wxHTML pages using the wx.TextCtrl.</summary>
            <remarks>
            Add an instance of this to the tag handlers of an HTML parser before use:
            <code>
            wx.Html.HtmlWindow html = new wx.Html.HtmlWindow(this);
            html.Parser.AddTagHandler(new wx.Html.HtmlTextFieldTagHandler());
            </code>
            From this code on, <c>html.Parser</c> will understand the tag "WXTEXT"
            with the following parameters:
            <list type="table">
            <listheader><term>Parameter</term><description>Effect</description></listheader>
            <item><term>text</term><description>Provides the default text that will be displayed before the user put something in.</description></item>
            <item><term>id</term><description>A positive integer - the id of the created text window.</description></item>
            <item><term>width</term><description>Specifies the width in pixels</description></item>
            <item><term>height</term><description>Specifies the height in pixels</description></item>
            <item><term>styles</term><description>Is a comma-separated list of style names (like <c>TE_MULTILINE</c> or <c>TE_PASSWORD</c>) that will be used to create the window.
            Additional styles: DIRECTORY or DIRECTORY_LIST. These styles will add a button that will open a directory selector.
            </description></item>
            <item><term>fgcolor</term><description>The foreground (text) color in HTML notation</description></item>
            <item><term>bgcolor</term><description>The background color in HTML notation.</description></item>
            </list>
            Please note, that the tag handler may raise EVT_TEXT() events (class wx.CommantEvent) with empty
            string on startup. 
            In contrast to the standard bahaviour of the wx.TextCtrl, the control used by this tag handler
            will also raise a EVT_TEXT_ENTER event on loosing the focus. Unfortunately, you may encounter
            unexpected senders. The sender will be determined according to the C++ interface to the wxWidgets
            system - the class that implements the used event table.
            </remarks>
        </member>
        <member name="M:wx.Html.HtmlTextFieldTagHandler.OnLeave(System.Object,wx.Event)">
            <summary>
            This will be called on the EVT_LEAVE_WINDOW event of the created text window and will send
            a Event.wxEVT_COMMAND_TEXT_ENTER
            </summary>
            <param name="sender"></param>
            <param name="evt"></param>
        </member>
        <member name="M:wx.Html.HtmlTextFieldTagHandler.OnAskForDirectories(System.Object,wx.Event)">
            <summary>
            Will be called on pressing the button and opening the directory selector.
            </summary>
            <param name="sender">This should be the button for opening the directory selector.</param>
            <param name="evt"></param>
        </member>
        <member name="T:wx.Graph.IGraph`1">
            <summary>
            Methods of graphs that can be provided without references to internal representations.
            </summary>
        </member>
        <member name="M:wx.Graph.IGraph`1.GetEdgesFromNode(System.Int32)">
            <summary>
            Returns a collection of that nodes A (designated by their IDs) where there is an arc from A to
            the node designated by <c>nodeID</c>.
            </summary>
            <param name="nodeID">The node that is the target of the selected edges</param>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.IGraph`1.GetEdgesToNode(System.Int32)">
            <summary>
            Returns a collection of that nodes A (designated by their IDs) where there is an edge from the
            node designated by <c>nodeID</c> to A.
            </summary>
            <param name="nodeID">The node that is the target of the selected edges</param>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.IGraph`1.GetDataOfNode(System.Int32)">
            <summary>
            This will return the data that is associated with the graph node of the provided ID.
            </summary>
            <param name="id">designates the graph node whose data will be returned.</param>
            <returns></returns>
        </member>
        <member name="P:wx.Graph.IGraph`1.NodeIDs">
            <summary>
            Collection of node IDs.
            </summary>
        </member>
        <member name="P:wx.Graph.IGraph`1.Arcs">
            <summary>
            A collection of tuples of integers that represent the arcs between the nodes.
            The integers are node IDs.
            </summary>
        </member>
        <member name="T:wx.Graph.GraphNode`1">
            <summary>
            Represents a node in a graph.
            Please note, that instances can at most be part of exactly one graph.
            </summary>
        </member>
        <member name="F:wx.Graph.GraphNode`1._tag">
            <summary>
            This tag is for node oriented graph algorithms.
            </summary>
        </member>
        <member name="M:wx.Graph.GraphNode`1.#ctor(`0)">
            <summary>
            Creates a new node of a unique ID associated with the provided data.
            </summary>
            <param name="data">The data of the new node.</param>
        </member>
        <member name="M:wx.Graph.GraphNode`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:wx.Graph.GraphNode`1.Id">
            <summary>
            A unique identifier of the node.
            </summary>
        </member>
        <member name="P:wx.Graph.GraphNode`1.LevelFromStart">
            <summary>
            This is exactly one more than the largest LevelFromStart of a predecessor node.
            </summary>
        </member>
        <member name="P:wx.Graph.GraphNode`1.LevelFromEnd">
            <summary>
            This is exactly on more than the largest LevelFromEnd of a successor node.
            </summary>
        </member>
        <member name="P:wx.Graph.GraphNode`1.Data">
            <summary>
            The data associated with this node.
            </summary>
        </member>
        <member name="P:wx.Graph.GraphNode`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="T:wx.Graph.GraphEdge`1">
            <summary>
            Directed edge from one node to another.
            Please not that edges between the same nodes are equal.
            If edges bears data, two edges are usually equal if the from node, the to node, and the data are equal.
            </summary>
        </member>
        <member name="F:wx.Graph.GraphEdge`1._tag">
            <summary>
            This is for flow-oriented graph algorithms.
            </summary>
        </member>
        <member name="M:wx.Graph.GraphEdge`1.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.GraphEdge`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:wx.Graph.GraphEdge`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="T:wx.Graph.DirectedGraph`1">
            <summary>
            Represents a graph, a collection of nodes and edges.
            
            </summary>
        </member>
        <member name="M:wx.Graph.DirectedGraph`1.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.DirectedGraph`1.Add(wx.Graph.GraphNode{`0})">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="newNode">The new node.</param>
            <exception cref="T:wx.CannotChangeReadonly">Will be thrown iff this is readonly.</exception>
            <exception cref="T:System.ApplicationException">Will be thrown iff the new node has already been added to another graph.</exception>
        </member>
        <member name="M:wx.Graph.DirectedGraph`1.Add(wx.Graph.GraphEdge{`0})">
            <summary>
            Adds a new edge to the graph. The nodes will be added to the this graph of they are not already
            parts of the graph.
            </summary>
            <param name="edge">The new edge (between two nodes).</param>
            <exception cref="T:wx.CannotChangeReadonly">Will be raised if this is readonly.</exception>
            <exception cref="T:System.ApplicationException">Will be raised if the nodes of the edge are already part of another
            graph.</exception>
        </member>
        <member name="P:wx.Graph.DirectedGraph`1.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="P:wx.Graph.DirectedGraph`1.NodeIDs">
            <summary>
            Collection of node IDs.
            </summary>
        </member>
        <member name="P:wx.Graph.DirectedGraph`1.Arcs">
            <summary>
            A collection of tuples of integers that represent the edges between the nodes.
            The integers are node IDs.
            </summary>
        </member>
        <member name="M:wx.Graph.TreeNode`1.#ctor(`0)">
            <summary>
            Creates an instance with the provided data.
            </summary>
            <param name="data">The data that will be associated with the new node.</param>
        </member>
        <member name="M:wx.Graph.TreeNode`1.#ctor(wx.Graph.TreeNode{`0})">
            <summary>
            Creates a deep copy of the argument and its children that is NOT readonly.
            </summary>
            <param name="src">A subtree.</param>
        </member>
        <member name="M:wx.Graph.TreeNode`1.Add(wx.Graph.TreeNode{`0})">
            <summary>
            Adds a child to the node. Preconditions: This must not be read-only. Thsi must be a part of
            a tree. The new node must not be part of a tree.
            </summary>
            <param name="newChild">The new child node</param>
            <exception cref="T:System.ApplicationException">This is not part of a tree or the new node
            is already a part of a tree.</exception>
            <exception cref="T:wx.CannotChangeReadonly">If this is read-only.</exception>
        </member>
        <member name="M:wx.Graph.TreeNode`1.CollectNodes(System.Collections.Generic.ICollection{wx.Graph.TreeNode{`0}})">
            <summary>
            Adds this tree node and all siblings to the argument.
            </summary>
            <param name="collector"></param>
        </member>
        <member name="M:wx.Graph.TreeNode`1.CollectArcs(System.Collections.Generic.ICollection{System.Int32[]})">
            <summary>
            Collects the arcs between tree nodes. Adds tuples of the form (parent ID, child ID) to the argument.
            </summary>
            <param name="collector">List that will be loaded.</param>
        </member>
        <member name="M:wx.Graph.TreeNode`1.Find(System.Int32)">
            <summary>
            Returns the tree node if the ID as defined by the argument.
            The result is <c>null</c> if neither this node nor one of its siblings
            bear this ID.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.TreeNode`1.Clone">
            <summary>
            Returns a deep copy of this.
            </summary>
            <returns></returns>
        </member>
        <member name="P:wx.Graph.TreeNode`1.Id">
            <summary>
            The ID of the node.
            </summary>
        </member>
        <member name="P:wx.Graph.TreeNode`1.Parent">
            <summary>
            The parent of this node. This is <c>null</c> if this is a root or this is not part of a tree.
            </summary>
        </member>
        <member name="P:wx.Graph.TreeNode`1.Children">
            <summary>
            Collection of children.
            </summary>
        </member>
        <member name="P:wx.Graph.TreeNode`1.Data">
            <summary>
            Get or set the data that is associated with this node.
            </summary>
        </member>
        <member name="P:wx.Graph.TreeNode`1.IsRoot">
            <summary>
            True iff this is the root node of a tree.
            </summary>
        </member>
        <member name="P:wx.Graph.TreeNode`1.IsInTree">
            <summary>
            True iff this is part of a tree.
            </summary>
        </member>
        <member name="M:wx.Graph.Tree`1.SetRoot(wx.Graph.TreeNode{`0})">
            <summary>
            Sets the argument as a new root node.
            </summary>
            <param name="newRoot">The node that shall be the root node.</param>
            <exception cref="T:wx.CannotChangeReadonly">Will be thrown if this is read-only.</exception>
            <exception cref="T:System.ApplicationException">If the argument is already part of a tree.</exception>
        </member>
        <member name="P:wx.Graph.Tree`1.Root">
            <summary>
            This is the root node of the tree. This is <c>null</c> if the tree is empty.
            </summary>
        </member>
        <member name="T:wx.ArtID">
            <summary>The elements of this enumeration are used in wx.ArtProvider to designate requested bitmaps.
            If you are viewing this with the <c>helpview.exe</c> tool, then <a href="helpview:artprovider.html">this
            provides a table of the contained bitmaps</a>.</summary>
        </member>
        <member name="T:wx.ArtClient">
            <summary>Elements of this enumerations will be used in wx.ArtProvider to describe the client of a request for a bitmap.</summary>
        </member>
        <member name="T:wx.ArtProvider">
            <summary>This class provides some bitmaps (cf. to wx.ArtID).</summary>
        </member>
        <member name="T:wx.App">
            <summary>The wxApp class represents the application itself.
            It is used to:
            <list type="bullet">
            <item> set and get application-wide properties; </item>
            <item> implement the windowing system message or event loop; </item>
            <item> initiate application processing via wxApp.OnInit();</item>
            <item> allow default processing of events not handled by other objects in the application. </item> 
            </list>
            </summary>
        </member>
        <member name="M:wx.App.GetLastOSError">
            <summary>
            This method is a helper for platform specific diagnostics.
            The method will return an error code directly from the operating system or other
            platform specific software. The resulting code is platform specific but 0 is guaranteed
            to mean "no error" or "this function is not supported".
            
            The currently only supported platform is MS WINDOWS, where this return 
            <c>GetLastError()</c>.
            </summary>
            <returns>Error code or 0 if not error or not supported.</returns>
        </member>
        <member name="M:wx.App.OnInit">
            <summary>This must be provided by the application, and will usually create the application's main window, optionally calling wx.App.SetTopWindow.
             You may use wx.App.OnExit to clean up anything initialized here, provided that the function
             returns true.
            
             Notice that if you want to to use the command line processing provided by wxWidgets you have
             to call the base class version in the derived class OnInit().
             
             Please note, that the <c>STAThreadAttribute</c> shall be set in threads running this. wxWidgets as well as 
             .NET will conduct OLE initialization and these initializations must be done consistently.
            </summary>
             <returns>
             Return true to continue processing, false to exit the application immediately
             </returns>
        </member>
        <member name="M:wx.App.OnExceptionInMainLoop">
            <summary>This function is called if an unhandled exception occurs inside the main application event loop.
             It can return true to ignore the exception and to continue running the loop or false to exit the
             loop and terminate the program. \b Warning: Do not throw an exception here.
            
             The default behaviour of this function is the latter in all ports except under Windows where
             a dialog is shown to the user which allows him to choose between the different options.
             You may override this function in your class to do something more appropriate.
             </summary>
        </member>
        <member name="M:wx.App.OnExit">
            <summary>Override this member function for any processing which needs to be done as the application is about to exit.
             OnExit() is called after destroying all application windows and controls, but before
             wxWidgets cleanup. Note that it is not called at all if OnInit() failed.
            
             The return value of this function is currently ignored, return the same value as returned
             by the base class method if you override it.
             </summary>
        </member>
        <member name="M:wx.App.OnFatalException">
            <summary>This function may be called if something fatal happens: an unhandled exception under Win32 or a a fatal signal under Unix, for example.
             However, this will not happen by default: you have to explicitly call
             SetHandleFatalExceptions() to enable this.
            
             Generally speaking, this function should only show a message to the user and return.
             You may attempt to save unsaved data but this is not guaranteed to work and, in fact,
             probably won't.
             
             The standard implementation does nothing.
             </summary>
        </member>
        <member name="M:wx.App.SetHandleFatalException(System.Boolean)">
            <summary>Enable callback on fatal exceptions.
            Refer to OnFatalException().</summary>
        </member>
        <member name="M:wx.App.SafeYield">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
            Returns the result of the call to wx.App.Yield().
            </summary>
        </member>
        <member name="M:wx.App.SafeYield(wx.Window)">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
             If win is not NULL, this window will remain enabled, allowing the implementation
             of some limited user interaction.
            </summary>
            <returns>
             Returns the result of the call to wx.App.Yield().
             </returns>
             <param name="win">A top level window that will remain enabled or <c>null</c>.</param>
        </member>
        <member name="M:wx.App.SafeYield(wx.Window,System.Boolean)">
            <summary>This function is similar to wx.App.Yield(), except that it disables the user input to all program windows before calling wx.App.Yield and re-enables it again afterwards.
             If win is not NULL, this window will remain enabled, allowing the implementation
             of some limited user interaction.
            </summary>
            <returns>
             Returns the result of the call to wx.App.Yield().
            </returns>
             <param name="win">A top level window that will remain enabled or <c>null</c>.</param>
        </member>
        <member name="M:wx.App.Yield">
            <summary>cf. Yield(bool).</summary>
        </member>
        <member name="M:wx.App.Yield(System.Boolean)">
            <summary>Yields control to pending messages in the windowing system.
             This can be useful, for example, when a time-consuming process writes to
             a text window. Without an occasional yield, the text window will not be
             updated properly, and on systems with cooperative multitasking, such as
             Windows 3.1 other processes will not respond.
            
             Caution should be exercised, however, since yielding may allow the user to
             perform actions which are not compatible with the current task. Disabling
             menu items or whole menus during processing can avoid unwanted reentrance
             of code: see wx.App.SafeYield for a better function.
            
             Note that Yield() will not flush the message logs. This is intentional as
             calling Yield() is usually done to quickly update the screen and popping up
             a message box dialog may be undesirable. If you do wish to flush the log
             messages immediately (otherwise it will be done during the next idle loop
             iteration), call wx.Log.FlushActive.
            
             Calling Yield() recursively is normally an error and an assert failure is
             raised in debug build if such situation is detected. However if the
             <c>onlyIfNeeded</c> parameter is true, the method will just silently return
             false instead.
             </summary>
        </member>
        <member name="P:wx.App.TheApp">
            <summary>Returns the application instance.</summary>
        </member>
        <member name="E:wx.App.OnExitEvent">
            <summary>This will be called in the standard implementation of OnExit() before closing down the application.</summary>
        </member>
        <member name="P:wx.App.IsActive">
            <summary>Returns true if the application is active, i.e. if one of its windows is currently in the foreground. </summary>
        </member>
        <member name="P:wx.App.IsMainLoopRunning">
            <summary>Returns true if the main event loop is currently running, i.e. if the application is initialized and runs.
            
             This can be useful to test whether the events can be dispatched. For example, if this
             function returns false, non-blocking sockets cannot be used because the events from them
             would never be processed.
             </summary>
        </member>
        <member name="P:wx.App.VendorName">
            <summary>
            Name of the vendor.
            Will be used e.g. in the hierarchy of the Windows registry entries.
            </summary>
        </member>
        <member name="P:wx.App.AppName">
            <summary>
            Name of the application.
            Will be used e.g. to create keys in the hierarchy of registry entries.
            </summary>
        </member>
        <member name="M:wx.VListBox.GetEnumerator">
            <summary>This returns a new instance of EnumerateSelections on this list box.</summary>
        </member>
        <member name="T:wx.VListBox.EnumerateSelections">
            <summary>This will enumerate all selections in the argument list passed to the constructor.
            This is more convenient and comprehensable than using the original calls to
            GetFirstSelected()/GetNextSelected().</summary>
        </member>
        <member name="P:wx.VListBox.EnumerateSelections.Cookie">
            <summary>To whom it may concern.
            This is the cookie used for reading the selections. Nothing users need to know.</summary>
        </member>
        <member name="M:wx.DatePickerCtrl.#ctor(System.IntPtr)">
            <summary>CTor for internal use only.</summary>
        </member>
        <member name="M:wx.DatePickerCtrl.#ctor">
            <summary>CTor for 2 step construction.
            Use create to provide the control with data.</summary>
        </member>
        <member name="P:wx.DatePickerCtrl.Range">
            <summary>Constraint on the allowed values.</summary>
        </member>
        <member name="T:wx.DateEvent">
            <summary>This event class holds information about a date change and is used together with wx.DatePickerCtrl.
            It also serves as a base class for wx.CalendarEvent.</summary>
        </member>
        <member name="P:wx.PickerBase.IsPickerCtrlGrowable">
            <summary>True if the picker grows with the control.</summary>
        </member>
        <member name="P:wx.PickerBase.IsTextCtrlGrowable">
            <summary>True if the contained text control grows with the whole control.</summary>
        </member>
        <member name="P:wx.PickerBase.TextCtrlProportion">
            <summary>Read or set the text control's proportion.</summary>
        </member>
        <member name="P:wx.PickerBase.PickerCtrlProportion">
            <summary>Read or set the picker control's proportion.</summary>
        </member>
        <member name="P:wx.PickerBase.HasTextCtrl">
            <summary>True iff this shows a text control.</summary>
        </member>
        <member name="P:wx.PickerBase.TextCtrl">
            <summary>Reads the text control. 
            This is <c>null</c> if this does not show a text control.</summary>
        </member>
        <member name="T:wx.ColourPickerCtrl">
            <summary>This control allows the user to select a colour.
            The generic implementation is a button which brings up a wx.ColourDialog when clicked. Native implementation may differ but this
            is usually a (small) widget which give access to the colour-chooser dialog.
            
            Available styles: wx.WindowStyles.CLRP_DEFAULT_STYLE, wx.WindowStyles.CLRP_USE_TEXTCTRL, wx.WindowStyles.CLRP_SHOW_LABEL.</summary>
        </member>
        <member name="M:wx.ColourPickerCtrl.#ctor">
            <summary>Default CTor for two step construction using Create().</summary>
        </member>
        <member name="M:wx.ColourPickerCtrl.SetColour(System.String)">
            <summary>Setting the clour from a string.
            This accepts: colour names (those listed in wx.Colour.TheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green, blue components).</summary>
        </member>
        <member name="M:wx.ColourPickerCtrl.SetColour(wx.wxString)">
            <summary>Setting the clour from a string.
            This accepts: colour names (those listed in wx.Colour.TheColourDatabase), the CSS-like "RGB(r,g,b)" syntax
            (case insensitive) and the HTML-like syntax (i.e. "#" followed by 6 hexadecimal digits for red, green, blue components).</summary>
        </member>
        <member name="P:wx.ColourPickerCtrl.Colour">
            <summary>The displayed colour.</summary>
        </member>
        <member name="T:wx.ColourPickerEvent">
            <summary>Events raised by the wx.ColourPickerCtrl</summary>
        </member>
        <member name="P:wx.ColourPickerEvent.Colour">
            <summary>The affected colour.
            If this indicates a change, then this is e.g. the new colour.</summary>
        </member>
        <member name="T:wx.FontPickerCtrl">
            <summary>This control allows the user to select a font.
            The generic implementation is a button which brings up a wxFontDialog when clicked.
            Native implementation may differ but this is usually a (small) widget which give access to the font-chooser dialog.
            
            Uses the styles wx.WindowStyles.FNTP_FONTDESC_AS_LABEL, wx.WindowStyles.FNTP_USEFONT_FOR_LABEL,
            wx.WindowStyles.FNTP_USE_TEXTCTRL, wx.WindowStyles.FNTP_DEFAULT_STYLE.</summary>
        </member>
        <member name="M:wx.FontPickerCtrl.#ctor">
            <summary>Default CTor.
            Use this in two step construction in combination with <c>Create()</c>.</summary>
        </member>
        <member name="M:wx.FontPickerCtrl.Create(wx.Window,System.Int32,wx.Font,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,wx.wxString)">
            <summary>Second step in 2-step construction.</summary>
        </member>
        <member name="P:wx.FontPickerCtrl.SelectedFont">
            <summary>Get or set the selected font.
            Please keep care that the result will be finalized as soon as possible since
            some platforms only allow a certain amount of allocated font objects.</summary>
        </member>
        <member name="P:wx.FontPickerCtrl.MaxPointSize">
            <summary>Reads or defines the maximal point size of a font.</summary>
        </member>
        <member name="T:wx.FontPickerEvent">
            <summary>This event refers to wx.FontPickerCtrl</summary>
        </member>
        <member name="P:wx.FontPickerEvent.Font">
            <summary>Get or set the affected font.
            Please keep care that the result will be finalized as soon as possible since
            some platforms only allow a certain amount of allocated font objects.</summary>
        </member>
        <member name="T:wx.Bitmap">
            <summary>
            Represents a bitmap.
            </summary>
        </member>
        <member name="M:wx.GDIObject.MakeReadOnly">
            <summary>
            This will make this readonly.
            </summary>
            <returns>Returns <c>this</c>.</returns>
        </member>
        <member name="P:wx.GDIObject.IsReadonly">
            <summary>
            True iff this is readonly.
            </summary>
        </member>
        <member name="M:wx.Bitmap.#ctor(System.String)">
            <summary>Be careful: Create an wx.Image first before creating a bitmap from a file.
            In fact I don't know why, but this works better for <c>wxGTK</c>.
            </summary>
        </member>
        <member name="M:wx.Bitmap.#ctor(System.String,System.Reflection.Assembly)">
            <summary>Convenience CTor for reading the resource of the provided name from the provided assembly.</summary>
        </member>
        <member name="M:wx.Bitmap.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary><remarks>
            This will load a bitmap <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
            <code>
            wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
            wx.Bitmap bmp=new wx.Bitmap("archiveName.zrs", "iconname.png");
            </code>
            </remarks>
        </member>
        <member name="M:wx.Bitmap.FromBits(System.Boolean[],System.Int32)">
            <summary>This will create a monochrome bitmaps with data from <c>bits</c>.</summary>
                     * <remarks>
                     * Sample:
                     * <code>
                     wx.Bitmap monochromeCross=new wx.Bitmap(new bool[]
                       {false, false,  true,  true,  true,  true, false, false,
                        false, false, false,  true,  true, false, false, false,
                         true, false, false,  true,  true, false, false,  true,
                         true,  true,  true,  true,  true,  true,  true,  true,
                         true,  true,  true,  true,  true,  true,  true,  true,
                         true, false, false,  true,  true, false, false,  true,
                        false, false, false,  true,  true, false, false, false,
                        false, false,  true,  true,  true,  true, false, false},
                        8);
                     </code>
                     * </remarks>
        </member>
        <member name="M:wx.Bitmap.FromBits(System.Byte[],System.Int32)">
            <summary>This will create a monochrome bitmaps with data from <c>bytes</c>.
            </summary>
        </member>
        <member name="P:wx.Bitmap.Size">
            <summary>Get or set the size of the bitmap.
            Equivalent to sequential use of Width() and Height().
            </summary>
        </member>
        <member name="P:wx.Bitmap.NullBitmap">
            <summary>This is a static instance of an empty bitmap.
            This instance may be of use as default argument to several methods,
            e.g. wx.ToolBar. Don't copy or draw into this.
            </summary>
        </member>
        <member name="M:wx.Icon.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary>
                     * <remarks>
                     * This will load an image <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
                     * \code
                     wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
                     wx.Icon icon=new wx.Icon("archiveName.zrs", "iconname.png");
                     \endcode
                     * </remarks>
        </member>
        <member name="M:wx.Icon.#ctor(System.String)">
            <summary>This loads the icon from a local file.
            This CTor will NOT raise exceptions but display a default icon if the file cannot be loaded.
            You may use the CTor requiring a BitmapType to specify alternative ways of loading.</summary>
            <param name="name">Filename of the icon to be displayed.</param>
        </member>
        <member name="M:wx.Icon.#ctor(System.String,System.Boolean)">
            <summary>This loads the icon from a local file. You may use the CTor requiring a BitmapType to specify alternative ways of loading.</summary>
            <param name="name">Filename of the icon to be displayed.</param>
            <param name="enableException">Enables with <c>true</c> raising of exceptions if the file has not been found.</param>
            <exception cref="T:System.ArgumentException">Raised if <c>enableExceptions</c> and the icon file cannot be loaded.</exception>
        </member>
        <member name="M:wx.Icon.#ctor(System.String,wx.BitmapType)">
            <summary>Loads a bitmap of the provided type.
            Use wx.BitmapType.wxBITMAP_TYPE_ANY if you have no information on the type
            of the bitmap. Use wx.BitmapType.wxBITMAP_TYPE_RESOURCE to load a bitmap
            from the .NET resource named <c>name</c>.
            </summary>
        </member>
        <member name="M:wx.Icon.#ctor(System.String,System.Reflection.Assembly)">
            <summary>Convenience CTor for reading the resource of the provided name from the provided assembly.</summary>
        </member>
        <member name="T:wx.BoxSizer">
            <summary>Wrapps the  wxWidgets <c>wxBoxSizer</c> class, the most frequently used specification of dynamic layouts.</summary><remarks>
                 * 
                 * The basic idea behind a wxBoxSizer is that windows will most often be laid out in
                 * rather simple basic geometry, typically in a row or a column or several
                 * hierarchies of either.
                 *
                 * As an example, we will construct a dialog that will contain a text field at the
                 * top and two buttons at the bottom. This can be seen as a top-hierarchy column with
                 * the text at the top and buttons at the bottom and a low-hierarchy row with an
                 * OK button to the left and a Cancel button to the right. In many cases
                 * (particularly dialogs under Unix and normal frames) the main window will be
                 * resizable by the user and this change of size will have to get propagated to
                 * its children. In our case, we want the text area to grow with the dialog, whereas
                 * the button shall have a fixed size. In addition, there will be a thin border
                 * around all controls to make the dialog look nice and - to make matter worse - the
                 * buttons shall be centred as the width of the dialog changes.
                 * 
                 * It is the unique feature of a box sizer, that it can grow in both directions
                 * (height and width) but can distribute its growth in the main direction (horizontal
                 * for a row) unevenly among its children. In our example case, the vertical sizer
                 * is supposed to propagate all its height changes to only the text area, not to the
                 * button area. This is determined by the proportion parameter when adding a window
                 * (or another sizer) to a sizer. It is interpreted as a weight factor, i.e. it can
                 * be zero, indicating that the window may not be resized at all, or above zero.
                 * If several windows have a value above zero, the value is interpreted relative
                 * to the sum of all weight factors of the sizer, so when adding two windows with
                 * a value of 1, they will both get resized equally much and each half as much as
                 * the sizer owning them. Then what do we do when a column sizer changes its width?
                 * This behaviour is controlled by flags (the second parameter of the wx.Sizer.Add()
                 * function): Zero or no flag indicates that the window will preserve it is original
                 * size, wx.SizerFlag.wxGROW flag (same as wx.SizerFlag.wxEXPAND) forces the window
                 * to grow with the sizer, and wx.SizerFlag.wxSHAPED flag tells the window to change
                 * it is size proportionally, preserving original aspect ratio. When
                 * wx.SizerFlag.wxGROW flag is not used, the item can be aligned within available
                 * space. wx.SizerFlag.wxALIGN_LEFT, wx.SizerFlag.wxALIGN_TOP,
                 * wx.SizerFlag.wxALIGN_RIGHT, wx.SizerFlag.wxALIGN_BOTTOM,
                 * wx.SizerFlag.wxALIGN_CENTER_HORIZONTAL and wx.SizerFlag.wxALIGN_CENTER_VERTICAL do
                 * what they say. wx.SizerFlag.wxALIGN_CENTRE (same as wx.SizerFlag.wxALIGN_CENTER)
                 * is defined as
                 * \verbatim
                 (wx.SizerFlag.wxALIGN_CENTER_HORIZONTAL | wx.SizerFlag.wxALIGN_CENTER_VERTICAL).
                 \endverbatim
                 * Default alignment is <c>wx.SizerFlag.wxALIGN_LEFT</c> \c | <c>wx.SizerFlag.wxALIGN_TOP</c>.
                 * 
                 * As mentioned above, any window belonging to a sizer may have border, and it can be specified which of the four sides may have this border, using the wxTOP, wxLEFT, wxRIGHT and wxBOTTOM constants or wxALL for all directions (and you may also use wxNORTH, wxWEST etc instead). These flags can be used in combination with the alignment flags above as the second parameter of the Add() method using the binary or operator |. The sizer of the border also must be made known, and it is the third parameter in the Add() method. This means, that the entire behaviour of a sizer and its children can be controlled by the three parameters of the Add() method.
                 *
                 * <code>
                 * 
                 * // we want to get a dialog that is stretchable because it
                 * // has a text ctrl at the top and two buttons at the bottom
                 * 
                 * MyDialog(Frame *parent, int id, string title )
                 *   : Dialog(parent, id, title, wxDefaultPosition, wxDefaultSize,
                 *               DIALOG_DEFAULT_STYLE | RESIZE_BORDER)
                 * {
                 *   BoxSizer topsizer = new BoxSizer( Orientation.wxVERTICAL );
                 * 
                 *   // create text ctrl with minimal size 100x60
                 *   topsizer.Add(
                 *     new TextCtrl( this, -1, "My text.", wxDefaultPosition, wxSize(100,60), TE_MULTILINE),
                 *     1,                      // make vertically stretchable
                 *     SizerFlag.wxEXPAND |    // make horizontally stretchable
                 *     SizerFlag.wxALL,        //   and make border all around
                 *     10 );                   // set border width to 10
                 * 
                 * 
                 *   BoxSizer button_sizer = new BoxSizer( Orientation.wxHORIZONTAL );
                 *   button_sizer.Add(
                 *      new Button( this, -1, "OK" ),
                 *      0,                  // make horizontally unstretchable
                 *      SizerFlag.wxALL,    // make border all around (implicit top alignment)
                 *      10 );               // set border width to 10
                 *   button_sizer.Add(
                 *      new Button( this, -1, "Cancel" ),
                 *      0,                  // make horizontally unstretchable
                 *      SizerFlag.wxALL,    // make border all around (implicit top alignment)
                 *      10 );               // set border width to 10
                 * 
                 *   topsizer.Add(
                 *      button_sizer,
                 *      0,                           // make vertically unstretchable
                 *      SizerFlag.wxALIGN_CENTER );  // no border and centre horizontally
                 * 
                 *   this.SetSizer( topsizer );      // use the sizer for layout
                 * 
                 *   topsizer.SetSizeHints( this ); // set size hints to honour minimum size
                 * }
                 * </code>
                 * Note that the new way of specifying flags to wxSizer is via wxSizerFlags. This class greatly eases the burden of passing flags to a wxSizer.
                 * Here's how you'd do the previous example with wxSizerFlags:
                 * 
                 * <code>
                 * // we want to get a dialog that is stretchable because it
                 * // has a text ctrl at the top and two buttons at the bottom
                 * 
                 * MyDialog(Frame *parent, int id, string title )
                 *        : Dialog(parent, id, title, wxDefaultPosition, wxDefaultSize,
                 *                    DIALOG_DEFAULT_STYLE | RESIZE_BORDER)
                 * {
                 *   BoxSizer topsizer = new BoxSizer( Orientation.wxVERTICAL );
                 * 
                 *   // create text ctrl with minimal size 100x60 that is horizontally and 
                 *   // vertically stretchable with a border width of 10
                 *   topsizer.Add(
                 *     new TextCtrl( this, -1, "My text.", wxDefaultPosition, new Size(100,60), TE_MULTILINE),
                 *     SizerFlag.wxALIGN|SizerFlag.wxEXPAND|SizerFlag.wxALL, 10);
                 * 
                 *   BoxSizer button_sizer = new BoxSizer( Orientation.wxHORIZONTAL );
                 * 
                 *   //create two buttons that are horizontally unstretchable, 
                 *   // with an all-around border with a width of 10 and implicit top alignment
                 *   button_sizer.Add(
                 *      new Button( this, -1, "OK" ),
                 *      SizerFlag.wxEXPAND|SiserFlag.wxALL, 10);       
                 * 
                 *   button_sizer.Add(
                 *      new Button( this, -1, "Cancel" ),
                 *      SizerFlag.wxALIGN|SizerFlags.wxEXPAND|SizerFlags.wxALL, 10);    
                 * 
                 *   //create a sizer with no border and centered horizontally
                 *   topsizer.Add(
                 *      button_sizer,
                 *      SizerFlag.wxALIGN_CENTER ); 
                 * 
                 *   this.SetSizer( topsizer );      // use the sizer for layout
                 * 
                 *   topsizer.SetSizeHints( this );  // set size hints to honour minimum size
                 * }
                 * </code>
                 * </remarks>
        </member>
        <member name="M:wx.Sizer.#ctor(System.IntPtr)">
            <summary>
            Do not use this. This is for internal purposes only.
            </summary>
            <param name="wxObject">Address of the pointer to the native sizer.</param>
        </member>
        <member name="M:wx.Sizer.Add(wx.Window,System.Int32,wx.SizerFlag)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
        </member>
        <member name="M:wx.Sizer.Add(wx.Window,System.Int32,wx.SizerFlag,System.Int32)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:wx.Sizer.Add(wx.Window,System.Int32,wx.SizerFlag,System.Int32,wx.Object)">
            <summary>Adds a component to the sizer.</summary>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:wx.Sizer.Add(System.Int32,System.Int32)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
        </member>
        <member name="M:wx.Sizer.Add(System.Int32,System.Int32,System.Int32,wx.SizerFlag,System.Int32)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:wx.Sizer.Add(System.Int32,System.Int32,System.Int32,wx.SizerFlag,System.Int32,wx.Object)">
            <summary>
            Adds free space.
            </summary>
            <param name="width">Width of the free space.</param>
            <param name="height">Height of the inserted space.</param>
            <param name="proportion">1 for components that increase their size with the composite.</param>
            <param name="flag">Bit-flags from <c>wx.Stretch</c>, <c>wx.Orientation</c> and <c>wx.Alignment</c>.</param>
            <param name="border">width of blank space around the inserted window.</param>
        </member>
        <member name="M:wx.Sizer.Fit(wx.Window)">
             <summary>
             Tell the sizer to resize the window to match the sizer's minimal size.
             This is commonly done in the constructor of the window itself, see sample in the description of wx.BoxSizer.
             Returns the new size.
            
             For a top level window this is the total window size, not client size.
             </summary>
             <param name="window"></param>
             <returns></returns>
        </member>
        <member name="M:wx.Sizer.FitInside(wx.Window)">
            <summary>
            Tell the sizer to resize the virtual size of the window to match the sizer's minimal size.
            This will not alter the on screen size of the window, but may cause the addition/removal/alteration of
            scrollbars required to view the virtual area in windows which manage it.
            </summary>
            <param name="window"></param>
        </member>
        <member name="M:wx.Sizer.SetSizeHints(wx.Window)">
            <summary>This will cause the layout to honour minimal size of <c>window</c>.
             Note: First assign the sizer. Then, set size hints.
             
             This method first calls <c>wx.Sizer.Fit</c> and then <c>SetSizeHints</c> on the window passed to it.
             This only makes sense when window is actually a top level window such as a wx.Frame or a wx.Dialog,
             since <c>SetSizeHints</c> only has any effect in these classes. It does nothing in normal windows or controls.
            
              This method is commonly invoked in the constructor of a toplevel window itself if the toplevel window is resizable.
              </summary>
        </member>
        <member name="M:wx.BoxSizer.#ctor(wx.Orientation)">
            <summary>Creates a new sizer of the designated orientation.
             Refer to class wx.Orientation for applicable flags.
            </summary>
        </member>
        <member name="T:wx.wxDateTime">
            <summary>A wrapper to the  wxWidgets representation of points in time.
            </summary>
        </member>
        <member name="M:wx.wxDateTime.ToString">
            <summary>Comprehensable output.
            </summary>
        </member>
        <member name="M:wx.wxDateTime.FromWxWeekDay(System.Int32)">
            <summary>Converts the int into a DayOfWeek assuming the argumetn to be an index in  wxWidgets enumeration <c>WeekDay</c>.
            This will throw an System.ArgumentOutOfRangeException on negative arguments.
            </summary>
        </member>
        <member name="T:wx.TipProvider">
            <summary>
            Offers opportunity to display a unique tip dialog showing tips from a file.
            </summary>
        </member>
        <member name="M:wx.TipProvider.CreateFileTipProvider(System.String,System.Int32)">
            <summary>
            Creates a tip provider.
            </summary>
            <param name="filename">Name of the file providing the tips-
            </param>
            <param name="currentTip">Index of the current tip.
            </param>
        </member>
        <member name="M:wx.TipProvider.CreateFileTipProvider(wx.wxString,System.Int32)">
            <summary>
            Creates a tip provider.
            </summary>
            <param name="filename">Name of the file providing the tips-
            </param>
            <param name="currentTip">Index of the current tip.
            </param>
        </member>
        <member name="M:wx.TipProvider.ShowTip(wx.Window)">
            <summary>
            Shows the dialog.
            </summary>
            <param name="parent">This shall be the parent of the tip dialog.
            </param>
            <returns>True on success.
            </returns>
        </member>
        <member name="M:wx.TipProvider.ShowTip(wx.Window,System.Boolean)">
            <summary>
            Shows the dialog.
            </summary>
            <param name="parent">This shall be the parent of the tip dialog.
            </param>
            <returns>True on success.
            </returns>
        </member>
        <member name="P:wx.TipProvider.CurrentTip">
            <summary>
            Returns the current tip.
            </summary>
        </member>
        <member name="T:wx.TaskBarIcon">
            <summary>This class represents a taskbar icon.
             A taskbar icon is an icon that appears in the 'system tray' and responds to mouse clicks, optionally with a tooltip
             above it to help provide information.
             
             \par wxNET notes
             Apparently, task icons prohibit application exit on closing the main frame. So, you will have to use
             <c>wx.Utils.Exit()</c> instead where appropriate.
             
             \par X Window System Note
             Under X Window System, the window manager must support either the System Tray Protocol by <c>freedesktop.org</c>
             (WMs used by modern desktop environments such as GNOME >= 2, KDE >= 3 and XFCE >= 4 all do) or the older
             methods used in GNOME 1.2 and KDE 1 and 2. If it doesn't, the icon will appear as a toplevel window on
             user's desktop.
            
             Because not all window managers have system tray, there's no guarantee that wx.TaskBarIcon will work correctly
             under X Window System and so the applications should use it only as an optional component of their user interface.
             The user should be required to explicitly enable the taskbar icon on Unix, it shouldn't be on by default.
            
             \par Event handling
            
             To process input from a taskbar icon, use the following event handler macros to direct input to member functions
             that take a wxTaskBarIconEvent argument. Note that not all ports are required to send these events and so it's 
             better to override CreatePopupMenu if all that the application does is that it shows a popup menu in reaction to
             mouse click.
            
             \li <c>EVT_TASKBAR_MOVE(func)</c>  Process a <c>wxEVT_TASKBAR_MOVE</c> event.  
             \li <c>EVT_TASKBAR_LEFT_DOWN(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_DOWN</c> event.  
             \li <c>EVT_TASKBAR_LEFT_UP(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_UP</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_DOWN(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_DOWN</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_UP(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_UP</c> event.  
             \li <c>EVT_TASKBAR_LEFT_DCLICK(func)</c>  Process a <c>wxEVT_TASKBAR_LEFT_DCLICK</c> event.  
             \li <c>EVT_TASKBAR_RIGHT_DCLICK(func)</c>  Process a <c>wxEVT_TASKBAR_RIGHT_DCLICK</c> event.  
             \li <c>EVT_TASKBAR_CLICK(func)</c>  This is a synonym for either <c>EVT_TASKBAR_RIGHT_DOWN</c> or <c>UP</c>
             depending on the platform, use this event macro to catch the event which should result in the menu being displayed on the current platform.  
             
             Contributed by Jacek Trublajewicz 2008 with some changes by Harald Meyer auf'm Hofe.</summary>
        </member>
        <member name="M:wx.TaskBarIcon.SetIcon(wx.Icon,System.String)">
            <summary>Defines icon and optional tool tip to be presented inthe task bar.
            Call RemoveIcon() to remove the icon from the task bar.</summary>
        </member>
        <member name="M:wx.TaskBarIcon.RemoveIcon">
            <summary>This will remove the icon from the task bar.</summary>
        </member>
        <member name="M:wx.TaskBarIcon.CreatePopupMenu">
            <summary>This method is called by the library when the user requests popup menu (on Windows and Unix platforms, this is when the user right-clicks the icon).
             Override this function in order to provide popup menu associated with the icon.
            
             If CreatePopupMenu returns <c>null</c> (this happens by default), no menu is shown, otherwise the menu is displayed
             and then deleted by the library as soon as the user dismisses it. The events can be handled by a class derived
             from wx.TaskBarIcon.
             
             Note, that the returned wrapper will loose ownership of the native wx menu immediately after this method has
             been finished.</summary>
        </member>
        <member name="M:wx.TaskBarIcon.PopupMenu(wx.Menu)">
            <summary>Pops up a menu at the current mouse position.
            The events can be handled by a class derived from wx.TaskBarIcon.
            \par Note
            It is recommended to override <c>CreatePopupMenu()</c> callback instead of calling this method from event handler,
            because some ports (e.g. wxCocoa) may not implement <c>PopupMenu()</c> and mouse click events at all.</summary>
        </member>
        <member name="P:wx.TaskBarIcon.IsIconInstalled">
            <summary>True iff icon is presented in the task bar.
            Call RemoveIcon() to remove the icon from the task bar.</summary>
        </member>
        <member name="T:wx.NotifyEvent">
            <summary>This class is not used by the event handlers by itself, but is a base class for other event classes (such as wx.NotebookEvent).
            
             It (or an object of a derived class) is sent when the controls state is being changed and allows the program to <c>Veto()</c>
             this change if it wants to prevent it from happening.</summary>
        </member>
        <member name="M:wx.NotifyEvent.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="M:wx.NotifyEvent.Veto">
            <summary>Prevents the change announced by this event from happening.
            
             It is in general a good idea to notify the user about the reasons for vetoing the change because otherwise the
             applications behaviour (which just refuses to do what the user wants) might be quite surprising.</summary>
        </member>
        <member name="M:wx.NotifyEvent.Allow">
            <summary>Call this to explicitely allow processing of this event.
            This is the opposite of <c>Veto()</c>: it explicitly allows the event to be processed.
            For most events it is not necessary to call this method as the events are allowed anyhow 
            but some are forbidden by default (this will be mentioned in the corresponding event description).</summary>
        </member>
        <member name="P:wx.NotifyEvent.Allowed">
            <summary>This is <c>true</c> if processing this event is allowed (has not been vetoed).
            You may also set a value. This will either call Veto() or Allow().</summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellDateTimeEditor">
            <summary>Input of DateTime values using the wx.MaskedEdit.DateTimeCtrl.
            This will expect the grid model to store the natural string forms of System.DateTime
            values.
            
            Refer to wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer for a compatible renderer.</summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellEditor">
            <summary>Inherit from this class to implement you won grid cell editor.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            \param memOwn defines whether this method creates wrappers owning the C++ object or not.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.DeregisterWrapper">
            <summary>This will deregister the wrapper.
            This is necessary if natice instance live longer than their wrappers.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.Create(wx.Window,System.Int32,wx.EvtHandler)">
            <summary>Do not forget to set the generated control (SetControl())
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.SetControl(wx.Control)">
            <summary>Sets the control to be raised on edit a cell.
             Setting this is a prerequisite for several methods and shall be done in Create().
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEditor.GetControl">
            <summary>Gets the control that is used for editing cells.
            Note: This only works if the control has been generated from the wx.net side.
            If this editor is a native implementation like for instance GridCellTextEditor,
            this method returns <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.GridCtrl.Editors.GridCellDateTimeEditor.InputCtrl">
            <summary>Returns the input control.</summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer">
            <summary>Renders DateTime data compatbile to wx.GridCtrl.Editors.GridCellDateTimeEditor.</summary>
            <remarks>
            This expand the following format strings using <c>data</c>:
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            </remarks>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellRenderer.FindOrCreateObjectUsingClassInfo(System.IntPtr)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            The wrappers that are created by this method do not own the C++ objects.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellRenderer.FindOrCreateObjectUsingClassInfo(System.IntPtr,System.Boolean)">
            <summary>Finds an existing wrapper or creates one if necessary from information of ClassInfo.
            This will throw an exception of type information is required but ClassInfo fails to
            provide.
            
            \param memOwn defines whether this method creates wrappers owning the C++ object or not.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.#ctor(System.String)">
            <summary>Creates a renderer showing data in the provided format.
            refer to the class documentation.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.DateTimeToString(System.DateTime)">
            <summary>Creates a string from <c>data</c> using the format string <c>Format</c>.
            </summary>
        </member>
        <member name="P:wx.GridCtrl.Renderers.GridCellDateTimeMaskRenderer.Format">
            <summary>returns the format string.
            </summary>
        </member>
        <member name="T:wx.DateTimeValueChangedEvent">
            <summary>A simple event that fires after a value has been changed.
            </summary>
        </member>
        <member name="M:wx.DateTimeValueChangedEvent.#ctor">
            <summary>The value has been set to <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.DateTimeValueChangedEvent.NewValue">
            <summary>Returns the new value that caused this event.
            The result may be <c>null</c> if this indicated the removal of a value.</summary>
        </member>
        <member name="T:wx.DateTimeValueChangedEventHandler">
            <summary>This is the type of the handlers of a DateTimeValueChangedEvent.
            </summary>
        </member>
        <member name="T:wx.DateTimeCtrl">
            <summary>This is a combination if the <c>wx.MaskedEdit.DateTimeEdit</c> and the <c>wx.CalendarCtrl</c>.
            You may use this to put in full time date information with calendar support.
            </summary>
        </member>
        <member name="M:wx.DateTimeCtrl.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.DateTime,System.String,System.DateTime,System.DateTime)">
            <summary>CTor of the control
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of class <c>wx.MaskedEdit.DateTimeEdit</c> for further remarks on this.
            \param minValue is a lower bound or the input.
            \param maxValue is an upper bound of the input.
            All other arguments follow the standard  wx.NET CTors.
            Please note, that this control always has a value. Use <c>wx.MaskedEdit.DateTimeEdit</c> instead if you want
            to allow optional input of data.</summary>
        </member>
        <member name="M:wx.DateTimeCtrl.#ctor(wx.Window,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.DateTime,System.String,System.DateTime,System.DateTime)">
            <summary>CTor of the control</summary>
            <param name="startValue"> is an optional value that will be displayed on start.</param>
            <param name="textMask"> is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of class <c>wx.MaskedEdit.DateTimeEdit</c> for further remarks on this.</param>
            <param name="minValue"> is a lower bound or the input.</param>
            <param name="maxValue"> is an upper bound of the input.</param>
            <remarks>
            All other arguments follow the standard  wx.NET CTors.
            Please note, that this control always has a value. Use <c>wx.MaskedEdit.DateTimeEdit</c> instead if you want
            to allow optional input of data.
            </remarks>
        </member>
        <member name="F:wx.DateTimeCtrl.OnValueChanged">
            <summary>This will be called after the value of the control changed.</summary>
        </member>
        <member name="M:wx.DateTimeCtrl.SetHolidayColours(wx.Colour,wx.Colour)">
            <summary>This defines the colours to be used in the calendar control on holidays.</summary>
        </member>
        <member name="P:wx.DateTimeCtrl.Value">
            <summary>Read or write the value that will be displayed by this control.</summary>
        </member>
        <member name="P:wx.DateTimeCtrl.SpecialDays">
            <summary>Holidays that will be displayed in the calendar control.</summary>
        </member>
        <member name="T:wx.VisualComponent.TopLevelWindow">
            <summary>
            Represents a top level window, i.e. Create() will create a wx.Frame or
            a wx.Dialog. Instances of this class represent out of the box dialogs or
            frames: 
            </summary>
        </member>
        <member name="T:wx.NetMacros.Generator">
            <summary>
            Base class of all visual components. This class simply represents a call to the 
            constructor of a class. You may add a sequence of setter calls to modify the created instance.
            You may add a sequence of method calls to modify the created instance.
            </summary>
        </member>
        <member name="M:wx.NetMacros.Generator.#ctor(System.Type,System.Object[])">
            <summary>
            Creates an instance of this class providing a type and an array of arguments for a constructor.
            </summary>
            <param name="type">This ís a factory that will create instances of this type. This must not be an
            abstract type.</param>
            <param name="ctorArgs">Arguments to the ctor of <c>type</c> that shall be used.</param>
        </member>
        <member name="M:wx.NetMacros.Generator.#ctor(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            This will create an instance using the provided method.
            If the method descriptor designates a static method, the arguments will be passed to
            this method as provided to this ctor. If the method descriptor designated a non-static
            method, this method will be called at the first element of the argument list. The rest of
            the argument list will be passed as arguments to the called method.
            </summary>
            <param name="mi">Descriptor of the method that creates the instance.</param>
            <param name="methodArgs">Argument list that will be passed to the designated method.</param>
        </member>
        <member name="M:wx.NetMacros.Generator.#ctor(System.Type)">
            <summary>
            Creates an instance of this class providing a type. The created instance will implement a
            factory using the default ctor to create instances.
            </summary>
            <param name="type">This ís a factory that will create instances of this type. This must not be an
            abstract type.</param>
        </member>
        <member name="M:wx.NetMacros.Generator.AddSetter(wx.NetMacros.SetterCall)">
            <summary>
            Adds a new assignment that shall be executed immediately after the new instance has been created.
            The declaring type of the property of the setter shall be if the same class as the instance
            that has been created by this generator. Setters will run in the order in which they have been added
            before the modifiers. The SetterCall.Self member will be ignored. Please note, that side effects on this
            property might happen while executing the generator.
            </summary>
            <param name="sc"></param>
        </member>
        <member name="M:wx.NetMacros.Generator.AddModifier(wx.NetMacros.MethodCall)">
            <summary>
            Adds a method that will be called in <c>Create</c> immediately after creating the instance.
            This makes only sense if this method is a modifier. The added modifiers will be called in the
            order  in which they have been added. Modifiers will be evaluated after the setters have been executed.
            The SetterCall.Self member will be ignored. Please note, that side effects on this
            property might happen while executing the generator.
            </summary>
            <param name="mc"></param>
        </member>
        <member name="P:wx.NetMacros.Generator.DeclaringType">
            <summary>
            This instance will create an instance of this type.
            </summary>
            <seealso cref="!:Create"/>
        </member>
        <member name="P:wx.NetMacros.Generator.Args">
            <summary>
            This will try to create an instance of <c>CreateInstanceOfType</c>
            using these arguments.
            </summary>
        </member>
        <member name="P:wx.NetMacros.Generator.Modifiers">
            <summary>
            Modifiers that will be called in <c>Create</c> immediately after the instance has been created.
            </summary>
        </member>
        <member name="M:wx.VisualComponent.TopLevelWindow.#ctor">
            <summary>
            Creates an instance representing a wx.Frame created by the default ctor.
            </summary>
        </member>
        <member name="M:wx.VisualComponent.TopLevelWindow.#ctor(System.Type,System.Object[])">
            <summary>
            Creates an instance of this class providing a type and an array of arguments for a constructor.
            </summary>
            <param name="type">This ís a factory that will create instances of this type. This must not be an
            abstract type.</param>
            <param name="ctorArgs">Arguments to the ctor of <c>type</c> that shall be used.</param>
        </member>
        <member name="M:wx.VisualComponent.TopLevelWindow.#ctor(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            This will create an instance using the provided method.
            If the method descriptor designates a static method, the arguments will be passed to
            this method as provided to this ctor. If the method descriptor designated a non-static
            method, this method will be called at the first element of the argument list. The rest of
            the argument list will be passed as arguments to the called method.
            </summary>
            <param name="mi">Descriptor of the method that creates the instance.</param>
            <param name="methodArgs">Argument list that will be passed to the designated method.</param>
        </member>
        <member name="T:wx.TreeItemData">
            <summary>Analogously to SystemObjectClientData this holds a reference to an object that represents the client data.
             Use instance of this class to wrapp .NET data that shall be used as client data of a tree node in a wx.TreeCtrl.
            </summary>
        </member>
        <member name="T:wx.ClientData">
            <summary>Base class of all classes encapsulating client data.
             All classes deriving from wx.EvtHandler (such as all controls and App)
             can hold arbitrary data which is here referred to as "client data". This
             is useful e.g. for scripting languages which need to handle shadow objects
             for most of wxWidgets' classes and which store a handle to such a shadow
             class as client data in that class. This data can either be of type void
             - in which case the data container does not take care of freeing the data
             again or it is of type wxClientData or its derivatives. In that case the
             container (e.g. a control) will free the memory itself later. Note that
             you must not assign both void data and data derived from the
             ClientData class to a container.
            
             Some controls can hold various items and these controls can additionally
             hold client data for each item. This is the case for Choice, ComboBox
             and ListBox. TreeCtrl has a specialized class TreeItemData for each item
             in the tree.
             
             Refer to SystemObjectClientData for an opportunity to add .NET objects as client
             as client data.</summary>
        </member>
        <member name="M:wx.TreeItemData.#ctor(System.IntPtr)">
            <summary>
            For internal use only: Creates a registered wrapper of the provided native tree node instance.
            </summary>
            <param name="wxObject">Pointer to the tree node isntance that shall be wrapped.</param>
        </member>
        <member name="M:wx.TreeItemData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            For insternal use only.
            </summary>
            <param name="wxObject">Pointer to a native tree item data instance</param>
            <param name="memOwn">requires with <c>true</c> that the native tree node data instance shall be deleted on finaliation.</param>
        </member>
        <member name="M:wx.TreeItemData.#ctor">
            <summary>
            Creates an instance encapsulating the <c>null</c> reference.
            </summary>
        </member>
        <member name="M:wx.TreeItemData.#ctor(System.Int32)">
            Creates an instance encapsulating the provided index that shall annotate a tree node.
            <param name="clientData">The index that shall be associated with a tree node.</param>
        </member>
        <member name="M:wx.TreeItemData.#ctor(System.Object)">
            Creates an instance encapsulating the provided object as client data.
            <param name="clientData">The data that shall be associated with a tree node.</param>
        </member>
        <member name="P:wx.TreeItemData.Data">
            <summary>Returns or sets the data that has been attached to the node.</summary>
        </member>
        <member name="M:wx.TreeItemId.#ctor(wx.ClientData)">
            <summary>Creates an instance encapsulating the provided client data.
            Please note, that this will take ownership of the C++ instance wrapped by <c>pItem</c>.
            So, do not provide instances for <c>pItem</c> that have already been used.
            This will raise an exception in that case.</summary>
        </member>
        <member name="T:wx.TreeCtrl">
            <summary>This is the wrapper of the tree control <c>wxTreeCtrl</c>.
             </summary>
             <remarks>
             \image html treectrlsmall.png
             
             The tree control displays its items in a tree like structure. Each item has its own (optional) icon and
             a label. An item may be either collapsed (meaning that its children are not visible) or expanded
             (meaning that its children are shown). Each item in the tree is identified by its itemId which is of 
             opaque data type wxTreeItemId. You can test whether an item is valid by calling wx.TreeItemId.IsOk.
            
             The items text and image may be retrieved and changed with GetItemText/SetItemText and GetItemImage/SetItemImage.
             In fact, an item may even have two images associated with it: the normal one and another one for selected state
             which is set/retrieved with SetItemSelectedImage/GetItemSelectedImage functions, but this functionality might be
             unavailable on some platforms.
            
             Tree items have several attributes: an item may be selected or not, visible or not, bold or not. It may also be
             expanded or collapsed. All these attributes may be retrieved with the corresponding functions: IsSelected, IsVisible,
             IsBold and IsExpanded. Only one item at a time may be selected, selecting another one (with SelectItem) automatically
             unselects the previously selected one.
            
             In addition to its icon and label, a user-specific data structure may be associated with all tree items.
             If you wish to do it, you should derive a class from wxTreeItemData which is a very simple class having only one
             function GetId() which returns the id of the item this data is associated with. This data will be freed by the
             control itself when the associated item is deleted (all items are deleted when the control is destroyed), so you
             shouldn't delete it yourself (if you do it, you should call SetItemData(NULL) to prevent the tree from deleting
             the pointer second time). The associated data may be retrieved with GetItemData() function.
            
             Working with trees is relatively straightforward if all the items are added to the tree at the moment of its creation.
             However, for large trees it may be very inefficient. To improve the performance you may want to delay adding the items
             to the tree until the branch containing the items is expanded: so, in the beginning, only the root item is created
             (with AddRoot). Other items are added when EVT_TREE_ITEM_EXPANDING event is received: then all items lying immediately
             under the item being expanded should be added, but, of course, only when this event is received for the first time for
             this item - otherwise, the items would be added twice if the user expands/collapses/re-expands the branch.
             
             The tree control provides functions for enumerating its items. There are 3 groups of enumeration functions: for the
             children of a given item, for the sibling of the given item and for the visible items (those which are currently shown
             to the user: an item may be invisible either because its branch is collapsed or because it is scrolled out of view).
             Child enumeration functions require the caller to give them a cookie parameter: it is a number which is opaque to the
             caller but is used by the tree control itself to allow multiple enumerations to run simultaneously (this is explicitly
             allowed). The only thing to remember is that the cookie passed to GetFirstChild and to GetNextChild should be the same
             variable (and that nothing should be done with it by the user code).
            
             Among other features of the tree control are: item sorting with SortChildren which uses the user-defined comparison
             function OnCompareItems (by default the comparison is the alphabetic comparison of tree labels), hit testing 
             (determining to which portion of the control the given point belongs, useful for implementing drag-and-drop in the tree)
             with HitTest and editing of the tree item labels in place (see EditLabel).
             Finally, the tree control has a keyboard interface: the cursor navigation (arrow) keys may be used to change the current
             selection. "HOME" and "END" are used to go to the first/last sibling of the current item. '+', '-' and '*' expand,
             collapse and toggle the current branch. Note, however, that "DEL" and "INS" keys do nothing by default, but it is
             common to associate them with deleting an item from a tree and inserting a new one into it.
             
             Please note a serious problem with the tree control: The control does not like changes in its layout or selections
             on processing events. In such cases, I sometimes encountered access violations. The reason is unknown.
             Consider, that you want to react on leaving a text in a window in such a way, that a tree control changes the
             selected node or the tree has to be rebuilt. You leave the text control moving the mouse, the desired actions
             are conducted but suddenly the runtime environment reports a severe C++ exception.
             Fortunately, such problems can apparently be avoided using pending events as described in \ref custom_events.
             Use a custom command event type to conduct your actions after processing the mouse events.
             </remarks>
        </member>
        <member name="F:wx.TreeCtrl.wxTR_DEFAULT_STYLE">
            <summary>This is the default style for tree controls.
            </summary>
        </member>
        <member name="M:wx.TreeCtrl.AddRoot(System.String)">
            <summary>
            Adds the root node to the tree, returning the new item.
            </summary>
            <param name="text">The name of the root node</param>
        </member>
        <member name="M:wx.TreeCtrl.AddRoot(System.String,System.Int32)">
            <summary>
            Adds the root node to the tree, returning the new item.
            </summary>
            <param name="text">The name of the root node</param>
            <param name="image">The index of the image that shall be presented with the node.</param>
        </member>
        <member name="M:wx.TreeCtrl.AddRoot(System.String,System.Int32,System.Int32)">
            <summary>
             Adds the root node to the tree, returning the new item.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to
             use for unselected and selected items, respectively. If <c>image > -1</c> and <c>selImage is -1</c>, the same image is
             used for both selected and unselected items.
             </summary>
             <param name="text">The name of the root node</param>
             <param name="image">The index of the image that shall be presented with the node.</param>
             <param name="selImage">The index of the image that shall be presented with the node if the node is selected.</param>
        </member>
        <member name="M:wx.TreeCtrl.AddRoot(System.String,System.Int32,System.Int32,wx.TreeItemData)">
            <summary>
             Adds the root node to the tree, returning the new item.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to
             use for unselected and selected items, respectively. If <c>image > -1</c> and <c>selImage is -1</c>, the same image is
             used for both selected and unselected items.
             
             This method reflects the  wxWidgets 2.6 requirement that <c>data</c> must not be <c>null</c> on hidden roots.
             Do not provide already used instances for <c>data</c>. This method will raise exceptions in that cases.
             </summary>
             <param name="text">The name of the root node</param>
             <param name="image">The index of the image that shall be presented with the node.</param>
             <param name="selImage">The index of the image that shall be presented with the node if the node is selected.</param>
        </member>
        <member name="M:wx.TreeCtrl.AppendItem(wx.TreeItemId,System.String)">
            <summary>
            Appends an item to the end of the branch identified by parent, return a new item id.
            
            Please note, that an appended item may not be visible because the parent is not expanded.
            </summary>
            <param name="parentId">The parent node that will get a new child.</param>
            <param name="text">The label text of the new node.</param>
            <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:wx.TreeCtrl.AppendItem(wx.TreeItemId,System.String,System.Int32)">
            <summary>
            Appends an item to the end of the branch identified by parent, return a new item id.
            
            The specified image will be used to display the node if selected or unselected.
            
            Please note, that an appended item may not be visible because the parent is not expanded.
            </summary>
            <param name="parentId">The parent node that will get a new child.</param>
            <param name="text">The label text of the new node.</param>
            <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
            <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:wx.TreeCtrl.AppendItem(wx.TreeItemId,System.String,System.Int32,System.Int32)">
             <summary>
             Appends an item to the end of the branch identified by parent, return a new item id.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to use for
             unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both
             selected and unselected items.
             
             Please note, that an appended item may not be visible because the parent is not expanded.
             </summary>
             <param name="parentId">The parent node that will get a new child.</param>
             <param name="text">The label text of the new node.</param>
             <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
             <param name="selImage">An index in the image list of the control representing the icon of the node if selected or -1.
             </param>
             <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:wx.TreeCtrl.AppendItem(wx.TreeItemId,System.String,System.Int32,System.Int32,wx.TreeItemData)">
             <summary>
             Appends an item to the end of the branch identified by parent, return a new item id.
            
             The <c>image</c> and <c>selImage</c> parameters are an index within the normal image list specifying the image to use for
             unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both
             selected and unselected items.
             
             Please note, that an appended item may not be visible because the parent is not expanded.
             </summary>
             <param name="parentId">The parent node that will get a new child.</param>
             <param name="text">The label text of the new node.</param>
             <param name="image">An index in the image list of the control representing the icon of the node or -1.</param>
             <param name="selImage">An index in the image list of the control representing the icon of the node if selected or -1.
             </param>
             <param name="data">Additional data that is associated with the node or <c>null</c>.</param>
             <returns>The identifier of the new node.</returns>
        </member>
        <member name="M:wx.TreeCtrl.AssignImageList(wx.ImageList)">
            <summary>
            Assigns an image list to the control containing the icons of the nodes.
            </summary>
            <param name="imageList">The image list containing the icons.</param>
        </member>
        <member name="M:wx.TreeCtrl.DeleteAllItems">
            <summary>
            Deletes all items in the control.
            Note that this may not generate EVT_TREE_DELETE_ITEM events under some Windows versions although
            normally such event is generated for each removed item.
            </summary>
        </member>
        <member name="M:wx.TreeCtrl.IsSelected(wx.TreeItemId)">
            <summary>
            True if the argument is a selected item.
            </summary>
            <param name="item">The item of interest.</param>
            <returns>True iff the provided item is selected.</returns>
        </member>
        <member name="M:wx.TreeCtrl.SelectItem(wx.TreeItemId)">
            <summary>
            SWets the selected item.
            </summary>
            <param name="item">The item that will be selected.</param>
        </member>
        <member name="M:wx.TreeCtrl.SetItemText(wx.TreeItemId,System.String)">
            <summary>
            Set the text associated with the tree item.
            </summary>
            <param name="item">designator of the tree item.</param>
            <param name="text">Text that will be associated with the tree item.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetItemText(wx.TreeItemId)">
            <summary>
            Returns the text that has been associated with this tree item.
            </summary>
            <param name="item">Designator of the tree item.</param>
        </member>
        <member name="M:wx.TreeCtrl.SetItemData(wx.TreeItemId,wx.TreeItemData)">
            <summary>Sets the client data for the provided item.
            This will raise an exception if <c>data</c> is already in use with other tree items.
            </summary>
            <param name="item">Designates the tree item that will be associated with data.</param>
            <param name="data">Is the data that will be associated with the designated tree item.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetItemData(wx.TreeItemId)">
            <summary>
            Returns the item data that has been stored for the designated tree item.
            </summary>
            <param name="item">Designates  the tree node whose data is requested.</param>
            <returns>The tree item data instance of <c>null</c>.</returns>
        </member>
        <member name="M:wx.TreeCtrl.FindLabels(System.String,wx.TreeCtrl.LabelMatch)">
            <summary>
            Returns an array of tree item identifiers designating those tree items with labels matching the provided string. 
            </summary>
            <param name="requestString">The string that shall be searched in item labels.</param>
            <param name="labelMatch">The method for comparing labels and request string.</param>
        </member>
        <member name="M:wx.TreeCtrl.FindFirstWithLabel(System.String,wx.TreeCtrl.LabelMatch)">
            <summary>
            Finds the first tree item whose label matches the provided request string.
            </summary>
            <param name="requestString">The string that shall be searched in item labels.</param>
            <param name="labelMatch">The method for comparing labels and request string.</param>
            <returns>The id of a matching tree item or <c>null</c> if nothing matches.</returns>
        </member>
        <member name="M:wx.TreeCtrl.GetItemParent(wx.TreeItemId)">
            <summary>
            The parent of the designated tree node. The result may be invalid of the argument is the root.
            </summary>
            <param name="item">The tree node.</param>
            <returns></returns>
        </member>
        <member name="M:wx.TreeCtrl.GetFirstChild(wx.TreeItemId,System.IntPtr@)">
            <summary>
            Returns the first child of the designated tree node. Creates a cookie representing this enumeration.
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <param name="cookie">This designates the enumeration. The cookie represents a state of enumeration.</param>
            <see cref="M:wx.TreeCtrl.GetChildren(wx.TreeItemId)"/>
        </member>
        <member name="M:wx.TreeCtrl.GetNextChild(wx.TreeItemId,System.IntPtr@)">
            <summary>
            Returns the next child of the designated tree node..
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <param name="cookie">This designates the enumeration. The cookie represents a state of enumeration.</param>
            <see cref="M:wx.TreeCtrl.GetChildren(wx.TreeItemId)"/>
        </member>
        <member name="M:wx.TreeCtrl.GetLastChild(wx.TreeItemId)">
            <summary>
            Returns the last child of the designated tree node.
            </summary>
            <param name="item">This method will collect children of this tree node.</param>
            <see cref="M:wx.TreeCtrl.GetChildren(wx.TreeItemId)"/>
        </member>
        <member name="M:wx.TreeCtrl.GetChildren(wx.TreeItemId)">
            <summary>An array comprising all direct children of the argument or <c>null</c> if argument designates a
            leaf node.</summary>
            <param name="item">This method will collect the children of this tree node.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetNextSibling(wx.TreeItemId)">
             <summary>
             Returns the next sibling of the specified item; call wx.TreeCtrl.GetPrevSibling() for the next sibling.
            
             Returns an invalid tree item if there are no further children.
             </summary>
        </member>
        <member name="M:wx.TreeCtrl.GetPrevSibling(wx.TreeItemId)">
             <summary>
             Returns the previous sibling of the specified item; call wx.TreeCtrl.GetNextSibling() for the next sibling.
            
             Returns an invalid tree item if there are no further children.
             </summary>
        </member>
        <member name="M:wx.TreeCtrl.GetFirstVisibleItem">
            <summary>
            Returns the first visible item.
            </summary>
            <seealso cref="M:wx.TreeCtrl.GetNextVisible(wx.TreeItemId)"/>
            <seealso cref="M:wx.TreeCtrl.GetPrevVisible(wx.TreeItemId)"/>
            <seealso cref="M:wx.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:wx.TreeCtrl.GetNextVisible(wx.TreeItemId)">
            <summary>
            Returns the next visible item following the argument.
            </summary>
            <param name="item">This will return the next item following this one.</param>
            <seealso cref="!:GetFirstVisible"/>
            <seealso cref="M:wx.TreeCtrl.GetPrevVisible(wx.TreeItemId)"/>
            <seealso cref="M:wx.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:wx.TreeCtrl.GetPrevVisible(wx.TreeItemId)">
            <summary>
            Returns the previsous visible item.
            </summary>
            <param name="item">This will return the next item following this one.</param>
            <seealso cref="!:GetFirstVisible"/>
            <seealso cref="M:wx.TreeCtrl.GetNextVisible(wx.TreeItemId)"/>
            <seealso cref="M:wx.TreeCtrl.GetVisibleItems"/>
        </member>
        <member name="M:wx.TreeCtrl.GetVisibleItems">
            <summary>An array comprising all visible tree node items or <c>null</c> if nothing is visible.</summary>
            <param name="item">This method will collect the children of this tree node.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetAllItems">
            <summary>
            Returns the IDs of all nodes that have been added to the control beginning with the root node.
            The result will be <c>null</c> iff this is empty.
            </summary>
        </member>
        <member name="M:wx.TreeCtrl.Expand(wx.TreeItemId)">
            <summary>
            Expands the designated tree node.
            </summary>
            <param name="item">The node to be expanded.</param>
        </member>
        <member name="M:wx.TreeCtrl.Collapse(wx.TreeItemId)">
            <summary>
            Collapses the designated tree node.
            </summary>
            <param name="item">The node to be collapsed.</param>
        </member>
        <member name="M:wx.TreeCtrl.EnsureVisible(wx.TreeItemId)">
            <summary>
            Ensures by node expansion and scrolling that the designated item is visible.
            </summary>
            <param name="item">The item that shall be visible.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetChildrenCount(wx.TreeItemId)">
            <summary>Get number of direct and indirect (recursively found) children.
            </summary>
            <param name="item">Designator of the root node. This method will return 0 if this is not OK.</param>
        </member>
        <member name="M:wx.TreeCtrl.GetChildrenCount(wx.TreeItemId,System.Boolean)">
            <summary>Get the number of direct (<c>recursively</c> is false) or also of children of children etc.
            </summary>
            <param name="item">Designator of the root node. This method will return 0 if this is not OK.</param>
            <param name="recursively">This will also count children of children of <c>item</c> iff true.</param>
        </member>
        <member name="M:wx.TreeCtrl.InsertItem(wx.TreeItemId,wx.TreeItemId,System.String,System.Int32,System.Int32,wx.TreeItemData)">
            <summary>Inserts a new item into the tree.
            Please note, that the tree control will take ownership of the C++ instance wrapped by <c>data</c>.
            So, do not use an instance for <c>data</c> that has already been used.</summary>
        </member>
        <member name="P:wx.TreeCtrl.Selection">
            <summary>Get or set the selection.
            The result will not be OK if nothing is selected.
            </summary>
        </member>
        <member name="P:wx.TreeCtrl.RootItem">
            <summary>
            The root node of the presented tree.
            </summary>
        </member>
        <member name="P:wx.TreeCtrl.Count">
            <summary>
            The number of the contained nodes.
            </summary>
        </member>
        <member name="T:wx.TreeCtrl.HitTestFlags">
            <summary>Flags representing possible classifications of wx.TreeCtrl.HitTest().</summary>
        </member>
        <member name="F:wx.TreeCtrl.HitTestFlags.NONE">
            <summary>This simply indicates nothing.
            Useful to initialize. This is the 0.
            </summary>
        </member>
        <member name="T:wx.TreeCtrl.LabelMatch">
            <summary>
            Method to detect matching labels in FindLabels().
            </summary>
        </member>
        <member name="F:wx.TreeCtrl.LabelMatch.Exact">
            <summary>
            Exact match. Only equal labels match.
            </summary>
        </member>
        <member name="F:wx.TreeCtrl.LabelMatch.Contains">
            <summary>
            All labels containing the request string match.
            </summary>
        </member>
        <member name="F:wx.TreeCtrl.LabelMatch.EqualsIgnoreCase">
            <summary>
            All labels match that are equal to the request string ignoring the difference between upper and lower case letters.
            </summary>
        </member>
        <member name="F:wx.TreeCtrl.LabelMatch.ContainsIgnoreCase">
            <summary>
            All labels containing the request string ignoring the case match.
            </summary>
        </member>
        <member name="T:wx.ReflectConfig">
            <summary>Class providing some methods to check availability of conditional code and compatiblity of <c>wx.NET.dll</c> and <c>wx-c.dll</c>.
            
            This class provides some static methods but is also an attribute of the assembly.
            So, laoders of this assembly may analyse this before use.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.#ctor">
            <summary>This generates an attribute where the provided text is followed by a description of the conditional compilation.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.AssertWxWinVersion28">
            <summary>Raises an exception of those features introduced with  wxWidgets 2.8.0 are not available.
            Cf. CheckWxWinVersion28().</summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckWxWinVersion28">
            <summary>Tests whether the features introduced with  wxWidgets 2.8.0 are available.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckWxGTK">
            <summary>Test for availability of code particular for <c>__WXGTK__</c>.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckWxMSW">
            <summary>Test for availability of code particular for <c>__WXMSW__</c>.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckWxMAC">
            <summary>Test for availability of code particular for <c>__WXMAC__</c>.
             This is in fact rather a query whether code shall be avoided that cannot be provided
             for Apple Macintosh computers.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckWxNetDisplay">
            <summary>Test for availability of <c>WXNET_DISPLAY</c> code.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckStyledTextCtrl">
            <summary>This tests for the availability of STC ( define <c>WXNET_STYLEDTEXTCTRL</c> ).
             This shows availability of StyledTextCtrl.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckUseTabDialog">
            <summary>Checks for the availability of the TabCtrl class.
            This class is currently only available with CheckWxMSW().
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckUseUnicode">
            <summary>Checks for the availability of Unicode support in the linked  wxWidgets library.
            Currently, native Unicode support in <c>wxString</c> will not be used for conditional
            compilation but might be interest for if-then conditions in some code.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckCompatibility">
            <summary>Runtime-check: Tests whether <c>wx.NET</c> does not require more features than <c>wx-c.dll</c> provides.
             Please note that unfortunately this cannot be tested for defines of <c>wx.NET</c> that do not have
             an equivalent in <c>wxWidgets</c>. These defines have the prefix <c>WXNET_</c> .
             
             If this is <c>false</c> then several classes cannot be used since they
             require functions in the <c>wx-c.dll</c> according to the <c>wx.NET</c> configuration
             that have not been compiled due to the configuration of the used  wxWidgets
             system.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.CheckInternalUseUTF8">
            <summary>This is <c>true</c> iff the  wx.NET is configured for internal use of UTF 8 strings.
            This option is for instance relevant to the PNET implementation of the .NET framework.
            </summary>
        </member>
        <member name="M:wx.ReflectConfig.ConfigurationString">
            <summary>Returns an english string describing the configuration.
            </summary>
        </member>
        <member name="P:wx.ReflectConfig.Version28">
            \name These are the properties that one can read from the attribute.
            Instances of this class provide possibles attributes of this assembly.
            These properties define the information rovided by this attribute.
            Additionally, we have a ToString() method here that returns the
            ConfigurationString().
        </member>
        <member name="T:wx.RadioBox">
            <summary>This control throws exceptions on creating instances without providing choices.
            According to the wxWidgets documentation, this is a control with items but it is not.
            You can neither add items dynamically not associate items with client data.
            </summary>
        </member>
        <member name="P:wx.KeyEvent.KeyCode">
            <summary>The keycode with values from Enumeration KeyCode. Refer also to KeyCodeSymbol.</summary>
        </member>
        <member name="P:wx.KeyEvent.RawKeyCode">
            <summary>Returns the raw, uninterpreted, platform dependent key code.
            </summary>
        </member>
        <member name="P:wx.KeyEvent.RawKeyFlags">
            <summary>Returns the low level key flags for this event.
            The flags are platform-dependent and should only be used in advanced applications.</summary>
        </member>
        <member name="P:wx.KeyEvent.UnicodeChar">
            <summary>Returns the wide character equivalent to the pressed key.
            This only works correctly if either  wxWidgets has been built with Unicode support or if an ASCII key
            has been pressed. Otherwise, the result will be a 0.</summary>
        </member>
        <member name="M:wx.ImageHandler.CanRead(System.Byte[])">
            <summary>Returns true iff this handler can read the provided stream.
            </summary>
        </member>
        <member name="M:wx.ImageHandler.CanRead(System.String)">
            <summary>Returns true iff this handler can read the file of the provided name.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.Image" ignoriert -->
        <member name="M:wx.Image.BufferFromZipResource(System.String,System.String)">
            <summary>Helper reading a byte buffer from a zip resource.</summary>
        </member>
        <member name="M:wx.Image.#ctor(System.String,System.String)">
            <summary>CTor for ZipResource support.</summary>
                     * <remarks>
                     * This will load image <c>resourceName</c> from ZipResource file or directory <c>archiveName</c>.
                     * \code
                     wx.ZipResource.AddCatalogLookupPrefix(@"..\Utils\MemLogDisplay");
                     wx.Image img=new wx.Image("archiveName.zrs", "iconname.png");
                     \endcode
                     * </remarks>
        </member>
        <member name="M:wx.Image.RemoveHandler(System.String)">
            <summary>Removes the image handler of the provided name.
             The handler is not deleted. So, please ensure that the designated
             handler has a wx.NET wrapper for instancestoring a reference to
             FindHandler().
            </summary>
        </member>
        <member name="P:wx.Image.MaskColour">
            <summary>
            Get or set the colour defining the mask. The mask colour will be shown transparent.
            This will return <c>null</c> if not <c>this.Mask</c>.
            </summary>
        </member>
        <member name="T:wx.DirDialog">
            <summary>A dialog to ask for either one or many directories.</summary>
            <remarks>
            If appropriate, you may use the DirSelector instead.
            Available styles:
            <list type="table">
            <item><term>wx.WindowStyles.DD_DEFAULT_STYLE</term><description>Equivalent to a combination of wxDEFAULT_DIALOG_STYLE and wxRESIZE_BORDER (the last one is not used under wxWinCE).</description></item>
            <item><term>wx.WindowStyles.DD_DIR_MUST_EXIST</term><description>The dialog will allow the user to choose only an existing folder. When this style is not given, a "Create new directory" button is added to the dialog (on Windows) or some other way is provided to the user to type the name of a new folder.</description></item>
            <item><term>wx.WindowStyles.DD_CHANGE_DIR</term><description>Change the current working directory to the directory chosen by the user.</description></item>
            </list>
            NB: on Windows the new directory button is only available with recent versions of the common dialogs.
            </remarks>
        </member>
        <member name="P:wx.DirDialog.Path">
            <summary>
            The path that has been selected.
            </summary>
        </member>
        <member name="T:wx.Button">
            <summary>Class of buttons with text labels. Refer also to wx.BitmapButton.
            Style flags (enumeration wx.WindowStyles) applying to this class of control
            in particular start with BU_ as prefix.</summary>
        </member>
        <member name="P:wx.ToolTip.Enabled">
            <summary>Enables or disables tolltips globally.
            May not be supported on all platforms (eg. <c>wxCocoa)</c>.</summary>
        </member>
        <member name="P:wx.ToolTip.Delay">
            <summary>Set the delay after which the tooltip appears in milliseconds.
            May not be supported on all platforms (eg. <c>wxCocoa)</c>.</summary>
        </member>
        <member name="T:wx.NetMacros.TypeDescriptor">
            <summary>
            Simply a component containing  
            a namespace name, and a type name. The are the properties of a type
            that will be serialized.
            </summary>
        </member>
        <member name="M:wx.NetMacros.TypeDescriptor.#ctor">
            <summary>
            Creates a representation of type System.Object. 
            This ctor is meant to be used on deserialization.
            </summary>
        </member>
        <member name="M:wx.NetMacros.TypeDescriptor.CompareTo(System.Object)">
            <summary>
            Compares Name and Namespace.
            </summary>
            <param name="obj">The object to compare with.</param>
            <returns></returns>
        </member>
        <member name="M:wx.NetMacros.TypeDescriptor.Parse(System.String)">
            <summary>
            Parses a string and creates a type descriptor.
            </summary>
            <param name="str">A string like "M:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="M:wx.NetMacros.TypeDescriptor.SetFromString(System.String)">
            <summary>
            Parses a string and sets the properties of this instance accordingly.
            </summary>
            <param name="str">A string like "M:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="T:wx.NetMacros.MemberType">
            <summary>
            Used to define in instances of member descriptor whether this is
            a method or a property.
            </summary>
        </member>
        <member name="T:wx.NetMacros.MemberDescriptor">
            <summary>
            Instances of this class combine a TypeDescriptor with an additional
            member name. Instances will be used to designate members of classes,
            properties or methods.
            </summary>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.#ctor">
            <summary>
            Default ctor creating a reference to the member Name of this class.
            This is a dummy that will be used be deserialization.
            </summary>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.#ctor(wx.NetMacros.MemberType,wx.NetMacros.TypeDescriptor,System.String)">
            <summary>
            Creates an instance of the specified properties.
            </summary>
            <param name="membertype">The type of member (method or property)</param>
            <param name="type">The type declaring the member.</param>
            <param name="membername">the name of the member.</param>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Creates an instance designating the provided property.
            </summary>
            <param name="pi">Information on a property</param>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Creates an instance designating the provided method.
            </summary>
            <param name="mi">Information on a method</param>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.Parse(System.String)">
            <summary>
            This will parse strings of the form <c>"M:Namespace.ClassName.MemberName"</c>.
            </summary>
            <param name="str">The properties of the returned instance as string.</param>
            <returns></returns>
        </member>
        <member name="M:wx.NetMacros.MemberDescriptor.SetFromString(System.String)">
            <summary>
            Parses a string and sets the properties of this instance accordingly.
            </summary>
            <param name="str">A string like "T:wx.Object" or "wx.Object".</param>
            <returns></returns>
        </member>
        <member name="T:wx.NetMacros.MethodDescriptor">
            <summary>
            A member descriptor with attached signature - list of types in a parameter list. 
            </summary>
        </member>
        <member name="M:wx.NetMacros.MethodDescriptor.#ctor">
            <summary>
            Crates empty data. Use this e.g. for serialization.
            </summary>
        </member>
        <member name="M:wx.NetMacros.MethodDescriptor.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Creates an instance describing the provided method.
            </summary>
            <param name="mi"></param>
        </member>
        <member name="M:wx.NetMacros.MethodDescriptor.Parse(System.String)">
            <summary>
            Creates an instance referring to the provided string.
            This will expect a string of the format
            <c>"M:Namespace.Classname.Methodname(Namespace.TypeOfArg0,Namespace.TypeOfArg1)"</c>
            </summary>
            <param name="str"></param>
            <exception cref="T:System.FormatException">Thrown if string is of an unknown format.</exception>
        </member>
        <member name="M:wx.NetMacros.MethodDescriptor.SetFromString(System.String)">
            <summary>
            Loads the properties of this instance according to the provided string.
            This will expect a string of the format
            <c>"M:Namespace.Classname.Methodname(Namespace.TypeOfArg0,Namespace.TypeOfArg1)"</c>
            </summary>
            <param name="str"></param>
            <exception cref="T:System.FormatException">Thrown if string is of an unknown format.</exception>
        </member>
        <member name="P:wx.NetMacros.MethodDescriptor.Generalized">
            <summary>
            Generalized form without argument list. An unspecific designation of
            all implementations of the method.
            </summary>
        </member>
        <member name="T:wx.NetMacros.MethodCall">
            <summary>
            Represents a call to a method.
            </summary>
        </member>
        <member name="M:wx.NetMacros.MethodCall.#ctor">
            <summary>
            Used for serializaton. Produces a call to System.Object.ToString().
            </summary>
        </member>
        <member name="M:wx.NetMacros.MethodCall.#ctor(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Creates a call of method <c>mi</c> of object <c>self</c> with parameters <c>args</c>.
            This ctor will not test the consistency of hte arguments, i.e. whether this is of the
            declaring type of the method.
            </summary>
            <param name="mi">This is the method that will be called.</param>
            <param name="self">This is the object where the method will be called. This parameter will be ignored on static
            methods.</param>
            <param name="args">These objects will be passed as parameters to the method.</param>
        </member>
        <member name="P:wx.NetMacros.MethodCall.Method">
            <summary>
            Descriptor of the method that will be called.
            </summary>
        </member>
        <member name="P:wx.NetMacros.MethodCall.Self">
            <summary>
            This is the object that implements the method. The method will be called at this object.
            This will be <c>null</c> on static methods.
            </summary>
        </member>
        <member name="P:wx.NetMacros.MethodCall.Args">
            <summary>
            The arguments that will be passed to the method as parameters. this shall be <c>null</c>
            for methods without arguments.
            </summary>
        </member>
        <member name="P:wx.NetMacros.MethodCall.IsStatic">
            <summary>
            True iff the called method is static.
            </summary>
        </member>
        <member name="T:wx.NetMacros.SetterCall">
            <summary>
            Represents the assignment to a property. Properties are: A descriptor of the property and the
            assigned value.
            </summary>
        </member>
        <member name="M:wx.NetMacros.SetterCall.#ctor(System.Reflection.PropertyInfo,System.Object,System.Object)">
            <summary>
            Represents setting the value from the parameters to the property designated by the property info.
            </summary>
            <param name="pi">The property that will be set.</param>
            <param name="self">The object that exhibits this property and that will be changed on setting a value.</param>
            <param name="value">The value that will be set.</param>
        </member>
        <member name="M:wx.NetMacros.SetterCall.#ctor">
            <summary>
            This will be used by the XmlSerializer - a dumy action: Assigning 0 to property Value
            of this class.
            </summary>
        </member>
        <member name="P:wx.NetMacros.SetterCall.Self">
            <summary>
            The object that exhibits this property and that will be changed on setting a value.
            </summary>
        </member>
        <member name="P:wx.NetMacros.SetterCall.Value">
            <summary>
            The value that will be assigned.
            </summary>
        </member>
        <member name="P:wx.NetMacros.SetterCall.Property">
            <summary>
            The property that will get a new value on evaluating this. Only assign members of correct
            member type.
            </summary>
        </member>
        <member name="T:wx.NetMacros.RuntimeEnv">
            <summary>
            A very simple execution environment for runable components of the .NET macro collection.
            </summary>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.#ctor(System.Reflection.Assembly[])">
            <summary>
            Creates a runtime environment where all public ctors, methods, and properties 
            of the listed assemblies can be called.
            </summary>
            <param name="callableAssembles">A collection of assemblies. All ctors, methods, and properties of these 
            assemblies can be called/executed in this runtime environment.</param>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.GetType(wx.NetMacros.TypeDescriptor)">
            <summary>
            Finds the type designated by the descriptor in the parameter list.
            </summary>
            <param name="ti">Name and namespace of the type to return.</param>
            <returns>The designated type or <c>null</c> if non of the callable assemblies
            knows a type of the requested name.</returns>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.GetMethod(wx.NetMacros.MemberDescriptor)">
            <summary>
            Returns information on the method designated by the argument.
            </summary>
            <param name="mi">A member designator that is expected to designate a method.</param>
            <returns>Information on the designated method or <c>null</c> if hte method has not been found.</returns>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.GetProperty(wx.NetMacros.MemberDescriptor)">
            <summary>
            Returns information on the property designated by the argument.
            </summary>
            <param name="mi">A member designator that is expected to designate a property.</param>
            <returns>Information on the designated method or <c>null</c> if hte property has not been found.</returns>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.Invoke(wx.NetMacros.MethodCall)">
            <summary>
            Executes a mathod.
            </summary>
            <param name="mc">The method to be executed.</param>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
            <returns>The object that results from the call. This is <c>null</c> for <c>void</c> methods.</returns>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.Invoke(wx.NetMacros.SetterCall)">
            <summary>
            Executes a setter.
            </summary>
            <param name="sc">The setter (assignment to a property) that will be executed.</param>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
        </member>
        <member name="M:wx.NetMacros.RuntimeEnv.CreateInstance(wx.NetMacros.Generator)">
            <summary>
            Creates an instance following the instructions included in the provided generator.
            This method will change MethodCall.Self and SetterCall.Self of all stters and modifiers
            of the generator: Self will be set to the newly created instance.
            </summary>
            <param name="generator">Activator call and subsequent setter and modifier calls that shall be executed to create
            the desired instance.</param>
            <returns>The created instance.</returns>
            <exception cref="!:System.ArgumentExeption">This will be thrown if some necessary properties of the method call are missing.
            This exception will arise for instance if the type is unknown.</exception>
        </member>
        <member name="P:wx.NetMacros.RuntimeEnv.CallableAssemblies">
            <summary>
            Returns a read-only collection of those assemblies forming the runtime environment.
            All public ctors, methods, and properties of these assembles my be accessed by actions
            executed by this runtime environment.
            </summary>
        </member>
        <member name="T:wx.MessageDialog">
            <summary>This class represents a dialog that shows a single or multi-line message, with a choice of OK, Yes, No and Cancel buttons.</summary>
        </member>
        <member name="M:wx.MessageDialog.#ctor(wx.Window,System.String)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
        </member>
        <member name="M:wx.MessageDialog.#ctor(wx.Window,System.String,System.String)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
        </member>
        <member name="M:wx.MessageDialog.#ctor(wx.Window,System.String,System.String,wx.WindowStyles)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
        </member>
        <member name="M:wx.MessageDialog.#ctor(wx.Window,System.String,System.String,wx.WindowStyles,System.Drawing.Point)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
        </member>
        <member name="M:wx.MessageDialog.#ctor(wx.Window,wx.wxString,wx.wxString,wx.WindowStyles,System.Drawing.Point)">
            <summary>
            Creates a message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
        </member>
        <member name="M:wx.MessageDialog.ShowModal">
            <summary>Shows the dialog, returning one of wx.ShowModalResult.</summary>
        </member>
        <member name="M:wx.MessageDialog.ShowModal(System.String,System.String,wx.WindowStyles)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.ShowModal(wx.Window,System.String,System.String,wx.WindowStyles)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.ShowModal(wx.Window,System.String,System.String,wx.WindowStyles,System.Drawing.Point)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.ShowModal(wx.Window,wx.wxString,wx.wxString,wx.WindowStyles,System.Drawing.Point)">
            <summary>
            Shows a modal message dialog.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.MessageBox(System.String)">
            <summary>
            Displays a dialog with cation "Message" (or a translation of "Message") and style wx.WindowStyles.DIALOG_OK.
            </summary>
            <param name="msg">The text to be desplayed.</param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.MessageBox(System.String,System.String)">
            <summary>
            Displays a message dialog.
            </summary>
            <param name="msg">The text to be desplayed.</param>
            <param name="caption">The caption that will be display in the dialog's window decorator.</param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.MessageBox(System.String,System.String,wx.WindowStyles)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DIALOG_OK.
            </summary>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.MessageBox(System.String,System.String,wx.WindowStyles,wx.Window)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DIALOG_OK.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <returns></returns>
        </member>
        <member name="M:wx.MessageDialog.MessageBox(System.String,System.String,wx.WindowStyles,wx.Window,System.Drawing.Point)">
            <summary>
            Displays a dialog with style wx.WindowStyles.DIALOG_OK.
            </summary>
            <param name="parent">the parent of the dialog. This may be <c>null</c>, but typically this is the window implementing
            the action that triggered the display action. This dialog will be (de-)iconified and closed together with
            its parent.</param>
            <param name="msg">The text message that will be displayed in the dialog.</param>
            <param name="caption">The caption of the dialog that will be displayed in the decorator of the dialog window.</param>
            <param name="style">Typically defines icons and buttons of the dialog like <c>WindowStyles.DIALOG_OK | WindowStyles.ICON_INFORMATION</c>
            </param>
            <param name="pos">Dialog position. Currently ignored by wxWidgets implementation at least on Windows</param>
            <returns></returns>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellDateTimeRenderer">
            <summary>Wrapper of the <c>wxGridCellDateTimeRenderer</c>.
            This editor uses format strings according to  wxWidgets convention for output.
            Refer to GridCellDateTimeMaskRenderer / GridCellDateTimeMaskEditor for more .NET
            like implementations.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellStringRenderer">
            <summary>This renderer draws strings.
            You may overload some methods to change the appearance.
            Overridung is supported.</summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellEnumRenderer">
            <summary>Renders an enumeration.
            Enumerations are specified either as comma separated list or as an array of strings.
            However, also this array will be passed to the renderer as comma separated list so avoid
            comma in items.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellEnumRenderer.#ctor(System.String)">
            <summary>Argument is a comma separated list.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellEnumRenderer.#ctor(wx.wxString)">
            <summary>Argument is a comma separated list.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellEnumRenderer.SetParameters(System.String)">
            <summary>The <c>parameter</c> is a comma separated list of the items to be rendered.</summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellEnumEditor">
            <summary>Editor for an enumeration.
            Enumerations are specified either as comma separated list or as an array of strings.
            However, also this array will be passed to the renderer as comma separated list so avoid
            comma in items.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEnumEditor.#ctor(System.String)">
            <summary>Argument is a comma separated list of items.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellEnumEditor.#ctor(wx.wxString)">
            <summary>Argument is a comma separated list of items.</summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellAutoWrapStringEditor">
            <summary>String editor for potentially longer strings containing blanks.
            You may input explicit line breaks using the CTRL key in conjunctions
            with the return or enter key.</summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellTextEditor">
            <summary>Editor for string.
            You may use the wx.GridCellAutoWrapStringEditor alternatively.</summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellAutoWrapStringRenderer">
            <summary>String renderer for potentially longer strings containing blanks.
            Texts rendered by instances of this class will not overlap into empty cells
            in the neighbourhood. Longer strings will be displayed wrapped instead.</summary>
        </member>
        <member name="T:wx.Doc.TypeDoc">
            <summary>
            Instances are document entries for types.
            </summary>
        </member>
        <member name="M:wx.Doc.TypeDoc.#ctor(wx.NetMacros.TypeDescriptor,System.String)">
            <summary>
            Creates a document entry.
            </summary>
            <param name="t">The documented type.</param>
            <param name="summary">The summary description of the type (XML).</param>
        </member>
        <member name="P:wx.Doc.TypeDoc.Type">
            <summary>
            The documented type.
            </summary>
        </member>
        <member name="P:wx.Doc.TypeDoc.Summary">
            <summary>
            The content of the summary tag.
            </summary>
        </member>
        <member name="P:wx.Doc.TypeDoc.SeeAlso">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="P:wx.Doc.TypeDoc.See">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="T:wx.Doc.PropertyDoc">
            <summary>
            Instances are document entries for properties of classes.
            </summary>
        </member>
        <member name="M:wx.Doc.PropertyDoc.#ctor(wx.NetMacros.MemberDescriptor,System.String)">
            <summary>
            Creates a document entry.
            </summary>
            <param name="pi">The documented property.</param>
            <param name="summary">The summary description of the property (XML).</param>
        </member>
        <member name="P:wx.Doc.PropertyDoc.Property">
            <summary>
            The documented type.
            </summary>
        </member>
        <member name="P:wx.Doc.PropertyDoc.Summary">
            <summary>
            The content of the summary tag.
            </summary>
        </member>
        <member name="P:wx.Doc.PropertyDoc.SeeAlso">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="P:wx.Doc.PropertyDoc.See">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="T:wx.Doc.MethodDoc">
            <summary>
            Class to represent document entries on methods.
            </summary>
        </member>
        <member name="M:wx.Doc.MethodDoc.#ctor(wx.NetMacros.MemberDescriptor,System.String)">
            <summary>
            Creates a dosumentation entry describing a method.
            </summary>
            <param name="methodName">Designator of the documented method.</param>
            <param name="summary">Summary text.</param>
        </member>
        <member name="M:wx.Doc.MethodDoc.AddParameter(System.String,System.String)">
            <summary>
            Adds documentation for a parameter.
            </summary>
            <param name="parametername">The name of the parameter.</param>
            <param name="parameterdoc">The documentation of the parameter (content of PARAM tag).</param>
        </member>
        <member name="P:wx.Doc.MethodDoc.MethodName">
            <summary>
            The name of the documented method. This is an instance of MethodDescriptor if the documentation
            shall be used for a particular implementation of the method (depending on the types of the parameters).
            </summary>
        </member>
        <member name="P:wx.Doc.MethodDoc.DocOnParameters">
            <summary>
            Returns a collection of pairs of parameter names and documentation on the parameter.
            </summary>
        </member>
        <member name="P:wx.Doc.MethodDoc.Summary">
            <summary>
            Content of the summary tag.
            </summary>
        </member>
        <member name="P:wx.Doc.MethodDoc.Returns">
            <summary>
            The content of the RETURNS tag.
            </summary>
        </member>
        <member name="P:wx.Doc.MethodDoc.SeeAlso">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="P:wx.Doc.MethodDoc.See">
            <summary>
            List of references (serializations of TypeDesciptor, MemberDescriptor, or MethodDescriptor)
            pointing at the documentation of another code element
            </summary>
        </member>
        <member name="T:wx.Doc.AssemblyDocBase">
            <summary>
            Includes the documentation entries for one assembly.
            </summary>
        </member>
        <member name="M:wx.Doc.AssemblyDocBase.NormalizeStringContent(System.String)">
            <summary>
            Normalization of string content. Remove line breaks and multible blanks.
            Remove * if preceeded by line break and blanks.S
            </summary>
            <param name="original"></param>
            <returns></returns>
        </member>
        <member name="M:wx.Doc.AssemblyDocBase.GetTypeDoc(wx.NetMacros.TypeDescriptor)">
            <summary>
            Returns the documentation of the designated type if one has been loaded.
            </summary>
            <param name="t">The type whose documentation is requested</param>
            <returns></returns>
        </member>
        <member name="M:wx.Doc.AssemblyDocBase.GetMethodDoc(wx.NetMacros.MemberDescriptor)">
            <summary>
            Returns the documentation of the designated method if one has been loaded.
            </summary>
            <param name="m">Designates the method whose documentation is requested. If this is a MethodDescriptor,
            then this will also search for a documentation to MethodDescriptor.Generalized.</param>
            <returns></returns>
            <seealso cref="T:wx.NetMacros.MethodDescriptor"/>
        </member>
        <member name="M:wx.Doc.AssemblyDocBase.GetPropertyDoc(wx.NetMacros.MemberDescriptor)">
            <summary>
            Returns the documentation of the designated property if one has been loaded.
            </summary>
            <param name="p">Designates the property whose documentation is requested.</param>
            <returns></returns>
        </member>
        <member name="P:wx.Doc.AssemblyDocBase.Error">
            <summary>
            This is an error message if something went wrong on loading.
            This is <c>null</c> if everything is OK.
            </summary>
        </member>
        <member name="P:wx.Doc.AssemblyDocBase.Filename">
            <summary>
            The source of the documentation.
            </summary>
        </member>
        <member name="P:wx.Doc.AssemblyDocBase.AssemblyName">
            <summary>
            The name of the assembly as read from the documentation file. This may be <c>null</c> on read errors.
            </summary>
        </member>
        <member name="P:wx.Brush.TheBrushList">
            <summary>This is synonym to wx.BrushList.TheBrushList.</summary>
        </member>
        <member name="T:wx.Brush.Styles">
            <summary>Styles for brushes.</summary>
        </member>
        <member name="T:wx.StaticBox">
            <summary>A static box is a rectangle drawn around other panel items to denote a logical grouping of items.
            
             Please note that a static box should not be used as the parent for the controls it contains,
             instead they should be siblings of each other. Although using a static box as a parent might
             work in some versions of wxWidgets, it results in a crash under, for example, <c>wxGTK</c>. 
            
             Also, please note that because of this, the order in which you create new controls is important.
             Create your <c>wx.StaticBox</c> control before any siblings that are to appear inside the <c>wx.StaticBox</c> in order
             to preserve the correct Z-Order of controls.</summary>
        </member>
        <member name="T:wx.SpinCtrl">
            <summary>wx.SpinCtrl combines wx.TextCtrl and wx.SpinButton in one control.</summary>
        </member>
        <member name="P:wx.PrintData.PrintMode">
            <summary>Setting this property requires compatibility mode with  wxWidgets 2.4.</summary>
        </member>
        <member name="T:wx.GridCtrl.GridSelectionMode">
            <summary>This will defines what cell will be selected when pointing with the mouse at the grid.
            You may alternatively use the wx.WindowStyles wx.WindowStyles.GRID_SELECT_CELLS,
            wx.WindowStyles.GRID_SELECT_ROWS, or wx.WindowStyles.GRID_SELECT_COLUMNS.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.Editors.GridCellBoolEditor">
            <summary>This editor displays a check box producing string values according to wx.GridCtrl.Editors.GridCellBoolEditor.UseStringValues.</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellBoolEditor.UseStringValues(System.String,System.String)">
            <summary>Defines the string representation of the <c>true</c> and the <c>false</c> value that can be used by editors of this class.
            Default values are "1" for <c>true</c> and the empty string "" for <c>false</c>.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellBoolEditor.UseStringValues(wx.wxString,wx.wxString)">
            <summary>Defines the string representation of the <c>true</c> and the <c>false</c> value that can be used by editors of this class.
            Default values are "1" for <c>true</c> and the empty string "" for <c>false</c>.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue(System.String)">
            <summary>Returns <c>true</c> iff <c>value</c> is the string representation of <c>true</c> according to UseStringValues().</summary>
        </member>
        <member name="M:wx.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue(wx.wxString)">
            <summary>Returns <c>true</c> iff <c>value</c> is the string representation of <c>true</c> 
            according to UseStringValues().
            </summary>
        </member>
        <member name="T:wx.GridCtrl.GridTableRequest">
            <summary>IDs for messages sent from grid table to view.
             Refer to class GridTableMessage.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.GridTableMessage">
            <summary>Class to inform displaying Grid controls of any changes in the displayed GridTableBase.</summary>
                 * <remarks>
                 * This method implements an often vital directions of passing information in data binding that
                 * is often missing: The data model can use this method to inform displaying controls of changes.
                 * Refer to Grid.ProcessTableMessage().
                 * 
                 * Instances of this class combine a request for an action or message ID with two integer
                 * arguments. The best waay to exemplify the effect of such messages is to list their use
                 * in the standard  wxWidgets table model as given by class <c>wxStringTable</c>.
                 * The following items list modifying methods of this table model followed by the
                 * table message that is used to communicate the effect to the grid.
                 * 
                 * \code wxGridStringTable::InsertRows( size_t pos, size_t numRows ) \endcode generates
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NOTIFY_ROWS_INSERTED,
                                            pos,
                                            numRows );
                 \endcode
                 *
                 * \code wxGridStringTable::AppendRows( size_t numRows ) \endcode
                 * posts
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NOTIFY_ROWS_APPENDED,
                                            numRows );
                 \endcode
                 * 
                 * Finally, \code wxGridStringTable::DeleteRows( size_t pos, size_t numRows ) \endcode
                 * demands processing of
                 * \code
                    wxGridTableMessage msg( this,
                                            wxGRIDTABLE_NOTIFY_ROWS_DELETED,
                                            pos,
                                            numRows );
                 \endcode
                 * Get message IDs from enumeration <c>wx.GridTableRequest</c>.
                 * </remarks>
        </member>
        <member name="T:wx.GridCtrl.Grid">
             <summary>wxGrid and its related classes are used for displaying and editing tabular data.
             </summary>
             <remarks>
             \image html grid.png
             Getting started: a simple example
             For simple applications you need only refer to the wxGrid class in your code. This example shows how you might
             create a grid in a frame or dialog constructor and illustrates some of the formatting functions. 
            
             Create a wx.Grid object
             <code>
             grid = new wx.Grid( this,
                                 -1,
                                 wxPoint( 0, 0 ),
                                 wxSize( 400, 300 ) );
             
              // Then we call CreateGrid to set the dimensions of the grid
              // (100 rows and 10 columns in this example)
             grid.CreateGrid( 100, 10 );
              
              // We can set the sizes of individual rows and columns
              // in pixels
             grid.SetRowSize( 0, 60 );
             grid.SetColSize( 0, 120 );
             
              // And set grid cell contents as strings
             grid.SetCellValue( 0, 0, "wxGrid is good" );
             
              // We can specify that some cells are read-only
             grid.SetCellValue( 0, 3, "This is read-only" );
             grid.SetReadOnly( 0, 3 );
             
              // Colours can be specified for grid cell contents
             grid.SetCellValue(3, 3, "green on grey");
             grid.SetCellTextColour(3, 3, wx.Colour.wxGREEN);
             grid.SetCellBackgroundColour(3, 3, wx.Colour.wxLIGHT_GREY);
             
              // We can specify the some cells will store numeric 
              // values rather than strings. Here we set grid column 5 
              // to hold floating point values displayed with width of 6 
              // and precision of 2
             grid.SetColFormatFloat(5, 6, 2);
             grid.SetCellValue(0, 6, "3.1415");
             </code>
             </remarks>
        </member>
        <member name="M:wx.GridCtrl.Grid.OnGridEditorShown(System.Object,wx.Event)">
            <summary>Work around a  wxWidgets error (reported on 2.8.9).
            Ensure that grid editors will loose focus before they will be closed.</summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.OnClose(System.Object,wx.Event)">
            <summary>Work around a  wxWidgets bug: Close an eventually shown editor before closing the grid.
            Closing a grid with an open editor causes Access Violations in  wxWidgets.</summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.CreateGrid(System.Int32,System.Int32)">
             <summary>
             Creates a grid with the specified initial number of rows and columns.
             Call this directly after the grid constructor. When you use this function wx.Grid will create and manage a 
             simple table of string values for you. All of the grid data will be stored in memory.
            
             For applications with more complex data types or relationships, or for dealing with very large datasets,
             you should derive your own grid table class and pass a table object to the grid with wx.Grid.SetTable.
             </summary>
             <param name="numRows">Number of rows</param>
             <param name="numCols">Number of columns</param>
             <seealso cref="M:wx.GridCtrl.Grid.SetTable(wx.GridCtrl.GridTableBase)"/>
        </member>
        <member name="M:wx.GridCtrl.Grid.SetTable(wx.GridCtrl.GridTableBase)">
            <summary>Set the provided <c>table</c> as table model in cell selection mode without taking ownership.</summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.ProcessTableMessage(wx.GridCtrl.GridTableMessage)">
            <summary>Method for instances of GridTableBase to inform displaying grid controls of any changes.
             This method implements an often vital directions of passing information in data binding that
             is often missing: The data model can use this method to inform displaying controls of changes.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.DeleteAllRows">
            <summary>Deletes all rows.</summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.DeleteRows">
            <summary>Deletes row 0.</summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.DeleteRows(System.Int32)">
            <summary>Deletes row at pos <c>pos</c>.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.GetRowLabelAlignment">
            <summary>
            Returns the alignment information on row labels as an array of flags.
            The first element of the array will be on the horizontal alignment,
            the second on the vertical alignment.
            </summary>
            <returns>An array containing 2 alignment flags</returns>
        </member>
        <member name="M:wx.GridCtrl.Grid.GetColLabelAlignment">
            <summary>
            Returns the alignment information on column labels as an array of flags.
            The first element of the array will be on the horizontal alignment,
            the second on the vertical alignment.
            </summary>
            <returns>An array containing 2 alignment flags</returns>
        </member>
        <member name="M:wx.GridCtrl.Grid.SetRowLabelAlignment(wx.Alignment,wx.Alignment)">
            <summary>
            Sets the horizontal and vertical alignment of column label text.
            </summary>
            <param name="horiz">Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT.</param>
            <param name="vert">Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.</param>
        </member>
        <member name="M:wx.GridCtrl.Grid.SetColLabelAlignment(wx.Alignment,wx.Alignment)">
            <summary>
            Sets the horizontal and vertical alignment of column label text.
            </summary>
            <param name="horiz">Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT.</param>
            <param name="vert">Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.</param>
        </member>
        <member name="M:wx.GridCtrl.Grid.AutoSizeColumns">
             <summary>
             Automatically sizes all columns to fit their contents. The computed column widths will also be
             saved as minimal column widths.
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
        </member>
        <member name="M:wx.GridCtrl.Grid.AutoSizeColumns(System.Boolean)">
             <summary>
             Automatically sizes all columns to fit their contents. 
            
             Note:
             wx.Grid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.
             </summary>
             <param name="setAsMin">If this argument is true the calculated widths will also be set as the minimal widths for the columns.</param>
        </member>
        <member name="M:wx.GridCtrl.Grid.SetCellRenderer(System.Int32,System.Int32,wx.GridCtrl.Renderers.GridCellRenderer)">
            <summary>This will set the editor for a particular cell.
            Alternatively, you may set the editor to be used by a wx.GridCellAttr or
            you may assign a value to property wx.Grid.DefaultEditor.</summary>
        </member>
        <member name="P:wx.GridCtrl.Grid.Table">
            <summary>Get or set the table.
            This will use <c>SetTable(value)</c> for setting the table model, i.e. this operations does not
            take ownership of the table model and the selection mode will be cell selection.
            </summary>
        </member>
        <member name="P:wx.GridCtrl.Grid.DefaultRowSize">
            <summary>Gets or sets the default row size.
            Setting a value to this property always disables resizing (also
            the default in wxWidgets). Use SetDefaultRowSize() to enable resizing
            of rows.</summary>
        </member>
        <member name="P:wx.GridCtrl.Grid.DefaultColSize">
            <summary>Gets or sets the default column size.
            Setting a value to this property always disables resizing (also
            the default in wxWidgets). Use SetDefaultColSize() to enable resizing
            of rows.</summary>
        </member>
        <member name="P:wx.GridCtrl.Grid.DefaultRenderer">
            <summary>Get or set the default renderer.
            Please note, that the grid will gain ownership of the wrapped C++ instance of the editor.
            This will raise an exception, if you try to set an editor that is already in use.</summary>
        </member>
        <member name="P:wx.GridCtrl.Grid.DefaultEditor">
            <summary>Get or set the default editor.
            Please note, that the grid will gain ownership of the wrapped C++ instance of the editor.
            This will raise an exception, if you try to set an editor that is already in use.</summary>
        </member>
        <member name="T:wx.GridCtrl.GridCellCoordsArray">
            <summary>This is an array of GridCellCoords.</summary>
        </member>
        <member name="M:wx.GridCtrl.GridCellCoordsArray.SafeNew(System.IntPtr)">
            <summary>Creates a new ArrayInt. However, if <c>ptr</c> is <c>IntPtr.Zer</c>, then the result is <c>null</c>.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.GridCellAttr">
            <summary>
            Represents a set of attributes to display grid cells including (optional) special renderers and editors.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridCellAttr.#ctor(wx.Colour,wx.Colour,wx.Font,wx.Alignment,wx.Alignment)">
            <summary>
            In contrast to the correlated C++ CTor, this one accepts partially defined arguments.
            </summary>
            <param name="colText">Text colour to use in the cell or <c>null</c>.</param>
            <param name="colBack">Background colour to use in the cell or <c>null</c>.</param>
            <param name="font">font to use in the cell or <c>null</c>.</param>
            <param name="hAlign">Horizontal alignment of the text in the cell.</param>
            <param name="vAlign">Vertical alignment of the text in the cell.</param>
        </member>
        <member name="M:wx.GridCtrl.GridCellAttr.IncRef">
            <summary>
            This class is ref counted: it is created with ref count of 1, so calling DecRef() once will delete it.
            Calling IncRef() allows to lock it until the matching DecRef() is called
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridCellAttr.DecRef">
            <summary>
            Unlock an instance that has been locked with IncRef()
            </summary>
            <seealso cref="M:wx.GridCtrl.GridCellAttr.IncRef"/>
        </member>
        <member name="M:wx.GridCtrl.GridCellAttr.GetAlignment">
            <summary>
            Returns information on the defined alignment of text. First entry of the result
            will specify the horizintal alignment. The second entry will provide the vertical
            alignment.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellNumberRenderer">
            <summary>Renderer for numbers.
            Overriding is supported.</summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellFloatRenderer">
            <summary>Renderer for numbers.
            Overriding is supported.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellFloatRenderer.#ctor">
            <summary>A renderer of default precision and width.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellFloatRenderer.#ctor(System.Int32)">
            <summary>A renderer of default precision.</summary>
        </member>
        <member name="M:wx.GridCtrl.Renderers.GridCellFloatRenderer.#ctor(System.Int32,System.Int32)">
            <summary>Creates a renderer using the provided precision and width to display floating point numbers.</summary>
        </member>
        <member name="T:wx.GridCtrl.Renderers.GridCellBoolRenderer">
            <summary>This renderer shows a check box interpreting string according to wx.GridCtrl.Editors.GridCellBoolEditor.IsTrueValue.
            Overriding s not supported.</summary>
        </member>
        <member name="T:wx.GridCtrl.GridTableBase">
            <summary>Abstract data model for grids.
            Refer also to class GridTableMessage.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.GetNumberRows">
            <summary>
            Defines the number of rows in the table.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.GetNumberCols">
            <summary>
            Defines the number of columns in the table.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.IsEmptyCell(System.Int32,System.Int32)">
            <summary>
            Defines whether a cell can contain dat or not.
            </summary>
            <param name="row">The row of the requested cell</param>
            <param name="col">The column index of the requested cell</param>
            <returns>True iff the cell is empty.</returns>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.CanHaveAttributes">
            <summary>
            Does this table allow attributes? Default implementation creates a wxGridCellAttrProvider if necessary.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.GetAttr(System.Int32,System.Int32,wx.GridCtrl.GridCellAttr.AttrKind)">
            <summary>
            Returns grid cell attributes relevant to the cell as specified by the provided row
            and column index.
            
            Note:
            Grid cell attributs contain elements like fonts that often have a reduced address space
            (like handles in Windows). So, it is usually not a good idea to create grid cell attributes
            when they are needed. A better practice stores all required grid cell attributes in member
            variables. However, grid cell attributes wrapp C++ instances using reference counting. 
            So, you will have to increment the reference counter by GridCellAttr.IncRef().
            </summary>
            <param name="row">The row index.</param>
            <param name="col">The column index.</param>
            <param name="kind">A value indicating the intended use of the attributes.</param>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.SetRowAttr(wx.GridCtrl.GridCellAttr,System.Int32)">
            <summary>The standard implementation simply calls the  wxWidgets implementation and passes memory ownership to  wxWidgets.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridTableBase.SetColAttr(wx.GridCtrl.GridCellAttr,System.Int32)">
            <summary>The standard implementation simply calls the  wxWidgets implementation and passes memory ownership to  wxWidgets.
            </summary>
        </member>
        <member name="T:wx.GridCtrl.GridStringTable">
            <summary>Simplest type of data table for a grid for small tables of strings that are stored in memory:
            This is the default model of grids.
            </summary>
        </member>
        <member name="M:wx.GridCtrl.GridCellAttrProvider.GetAttr(System.Int32,System.Int32,wx.GridCtrl.GridCellAttr.AttrKind)">
            <summary>
            Returns grid cell attributes relevant to the cell as specified by the provided row
            and column index.
            
            Note:
            Grid cell attributs contain elements like fonts that often have a reduced address space
            (like handles in Windows). So, it is usually not a good idea to create grid cell attributes
            when they are needed. A better practice stores all required grid cell attributes in member
            variables. However, grid cell attributes wrapp C++ instances using reference counting. 
            So, you will have to increment the reference counter by GridCellAttr.IncRef().
            </summary>
            <param name="row">The row index.</param>
            <param name="col">The column index.</param>
            <param name="kind">A value indicating the intended use of the attributes.</param>
        </member>
        <member name="T:wx.DC">
            <summary>A device context for painting.
            Please note, that you have to dispose this context as soon as you
            stop drawing explicitely. In C++  wxWidgets this is done explicitely
            when creating objects of this class in a local scope. The object will
            be deleted when leaving this scope implicitely. However, .NET implements
            an implicit destruction of objects using a garbage collector. So, 
            you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
            to delete a DC immediately after using it.</summary>
        </member>
        <member name="M:wx.DC.GetTextExtent(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@,wx.Font)">
            <summary>Gets the dimensions of the string using the currently selected font.
            <c>str</c> is the text string to measure, <c>w</c> and <c>h</c> are the total width and height
            respectively, <c>descent</c> is the dimension from the baseline of the font to the bottom of the descender,
            and <c>externalLeading</c> is any extra vertical space added to the font by the font designer (usually is zero).
            The parameter font specifies an alternative to the currently selected font:
            but note that this does not yet work under Windows, so you need to set a font for the device context first.</summary>
        </member>
        <member name="M:wx.DC.GetTextExtent(System.String)">
            <summary>Returns width and height of string <c>str</c> using the font of the <c>this</c>.
            </summary>
        </member>
        <member name="M:wx.DC.GetTextExtent(System.String,wx.Font)">
            <summary>Returns width and height of string <c>str</c> using the designated font.
            </summary>
        </member>
        <member name="P:wx.DC.BackgroundMode">
            <summary>Returns or defines the background mode of the window.</summary>
        </member>
        <member name="T:wx.ClientDC">
            <summary>A device context for the region of a window.
            Please note, that you have to dispose this context as soon as you
            stop drawing explicitely. In C++  wxWidgets this is done explicitely
            when creating objects of this class in a local scope. The object will
            be deleted when leaving this scope implicitely. However, .NET implements
            an implicit destruction of objects using a garbage collector. So, 
            you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
            to delete a DC immediately after using it.</summary>
        </member>
        <member name="T:wx.PaintDC">
            <summary>A device context for painting.
            Please note, that you have to dispose this context as soon as you
            stop drawing explicitely. In C++  wxWidgets this is done explicitely
            when creating objects of this class in a local scope. The object will
            be deleted when leaving this scope implicitely. However, .NET implements
            an implicit destruction of objects using a garbage collector. So, 
            you have either to use the key word <c>using</c> or the ethod wx.Object.Dispose()
            to delete a DC immediately after using it.</summary>
        </member>
        <member name="T:wx.ComponentModel.ValueChangedEvent">
            <summary>Event class to indicate a value change.
            This event is used by all data models to indicate a value change.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.ValueChangedEvent.NewValue">
            <summary>Gets the new value whose assignment raised this event.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.ValueChangedEvent.OldValue">
            <summary>Get the old value that has been replaced by <c>NewValue</c>.
            Both are equal iff either a data model ends initialization or a data model has been
            told to propagate its value.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.ValueChangedHandler">
            <summary>Handler of the ValueChangedEvent.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.PropertyChangedEvent">
            <summary>
            This event indicates the change of a property. this is a specialization of
            ValueChangedEvent. The new and the old value property of the instances of this class
            are the old and the new value of the changed property.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyChangedEvent.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Creates an instance.
            </summary>
            <param name="propertyName">The property that changed.</param>
            <param name="newValue">The new value of the property.</param>
            <param name="oldValue">The old value of the property.</param>
        </member>
        <member name="P:wx.ComponentModel.PropertyChangedEvent.PropertyName">
            <summary>
            The name of the property that changed.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.PropertyChangedHandler">
            <summary>
            Handles a PropertyChangedEvent. A property of the sender has been changed.
            </summary>
            <param name="sender">The object where a property changed.</param>
            <param name="evt">The event data</param>
        </member>
        <member name="T:wx.ComponentModel.RaisesChangeEventAttribute">
            <summary>Use this to annotate a property that raises an event on changing its value.
            Use this in combination with a PropertyModel to declare that the annotated property
            raises a particular event on changing its value (of type ValueChangedHandler). If you create a property model for
            such a property, this property model will install itself as a handler of this event.
            
            Usually, property models like field models cannot guarantee to propagate all changes
            of the managed property or field since they simply will not be informed of a changed value.
            However, the  wx.NET component model allows for programmers to specify some events that will
            be fired in case of value change.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.RaisesChangeEventAttribute.#ctor(System.String)">
            <summary>Indicates that the annotated property raises an event named <c>eventName</c> on changing its value.</summary>
        </member>
        <member name="P:wx.ComponentModel.RaisesChangeEventAttribute.EventName">
            <summary>Name of the event that will be raised on changing the annotated property.</summary>
        </member>
        <member name="T:wx.ComponentModel.FormItemAttribute">
            <summary>This attribute indicates that a property or field shall be visible in a GenericFormPanel.
            You may declare a neutral name and comment and, if you like, translations of these into specific cultures.
            These names and remarks will be displayed in the generic field if appropriate. Additionally, you may declare
            the property as  read  only. You may also assign a criterion for sorting the items in the form.</summary>
        </member>
        <member name="M:wx.ComponentModel.FormItemAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>Creates an attribute defining a string that shall be used as a title on presenting the field.</summary><remarks>
                     * \param name is the neutral name of the property to be shown in the form if this has not been translated into the current culture.
                     * \param comment is the neutral comment of the property to be displayed if a better translation is not available.
                     * \param triplesCanonicalNamePlusPropNamePlusComment is a sequence of triples canonical culture name (like "de-DE"), translated
                     *        name, translated comment.
                     * 
                     * Example: Use this to declare a property of a form
                     * \code
                     class FormData
                     {
                     [FormItemAttribute("Valuation", "A value to be used for valuation.",
                                        "de", "Bewertung", "Ein Wert zur Bewertung.")]
                     int _valuation;
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:wx.ComponentModel.FormItemAttribute.Name">
            <summary>Name of this property in the dialog.</summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemAttribute.Comment">
            <summary>This is a text that describes the meaning of this form field.
            Usually this will be displayed as tool tip.</summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemAttribute.IsReadOnly">
            <summary>True iff this shall be presented read-only.</summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemAttribute.Sort">
            <summary>If possible, items will be sorted according to this parameter.</summary>
        </member>
        <member name="T:wx.ComponentModel.FormItemGroupAttribute">
            <summary>Use this attribute to define groups of form items.
            Use this attributes to define item groups to be displayed together. Users may hide item groups and make them
            visible again as long as the group is not declared to be statically visible.
            Groups have a name/label and optionally a comment. You may provide additional translations of names and comments.
            
            The neutral (not translated) name of the group serves as a key. Usually, you will provide one instance of this
            attribute with full data and additional instances only comprising a neutral name to designate additional items
            that shall join the group. The form will choose one definition of the group to provide all the data.</summary>
        </member>
        <member name="M:wx.ComponentModel.FormItemGroupAttribute.#ctor(System.String)">
            <summary>Creates an instance without data.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.FormItemGroupAttribute.#ctor(System.String,System.String,System.String[])">
            <summary>Creates an instance including data.
                     * </summary>
                     * <remarks>
                     * This attribute makes only sence if used together with FormItemAttribute.
                     * 
                     * Even if you provide <c>null</c> as comment, this instance will be considered as a definition of
                     * the item group providing full data.
                     * 
                     * \param name is the neutral name of the property to be shown in the form if this has not been translated into the current culture.
                     * \param comment is the neutral comment of the property to be displayed if a better translation is not available.
                     * \param triplesCanonicalNamePlusPropNamePlusComment is a sequence of triples canonical culture name (like "de-DE"), translated
                     *        name, translated comment.
                     * 
                     * Example: Use this to declare a property of a form
                     * \code
                     class FormData
                     {
                     [FormItemGroupAttribute("Valuation Factors", "Some factors for valuation.",
                                             "de", "Bewertungsangaben", "Angaben zur Bewertung.")]
                     [FormItemAttribute("Factor 1", "A value to be used for valuation.",
                                        "de", "Faktor 1", "Bewertungsfaktor 1.", Sort=1)]
                     int _factor1;
            
                     [FormItemGroupAttribute("Valuation Factors")]
                     [FormItemAttribute("Factor 2", "Another value to be used for valuation.",
                                        "de", "Faktor 1", "Bewertungsfaktor 2.", Sort=2)]
                     int _factor2;
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:wx.ComponentModel.FormItemGroupAttribute.Id">
            <summary>The untranslated name of this group that also serves as a key to designate the group.</summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemGroupAttribute.Name">
            <summary>The name of the item group and its translations.</summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemGroupAttribute.Comment">
            <summary>The comment on this item group and its translations.
            This may be <c>null</c> if this instance does not contain data.
            The form will choose one of the instances of this attribute on the same group where this property
            is not <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemGroupAttribute.IsStatic">
            <summary>True to require this attribute to be statically visible in the form (without scrolling).
            Please do not use this too often, because this might cause large and ugly looking forms.
            This is meant for fields like Name, affected year etc., that are something like a headline
            for the rest of the form.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.FormItemGroupAttribute.Sort">
            <summary>If possible, item groups will be sorted according to this parameter.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.ItemRowDesignatorAttribute">
            <summary>This attribute declares a particular form item to join the designated row in the form.
             This attribute makes only sence if used together with FormItemAttribute.
             
             Use instances of this attribtue to declare that two or more form items shall join the same 
             row. The sort criterion of the form items will be used to determine the order in which the items appear
             in the row. The sort criterion of this designator will be used to determine the place that
             the designated row occupies in the form.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.ItemRowDesignatorAttribute.#ctor(System.Int32)">
            <summary>The provided integer is the designator of the row as well as the criterion for sorting.</summary>
        </member>
        <member name="P:wx.ComponentModel.ItemRowDesignatorAttribute.Id">
            <summary>Returns the designator if the form row.</summary>
        </member>
        <member name="P:wx.ComponentModel.ItemRowDesignatorAttribute.Sort">
            <summary>Returns or sets the sorting index.</summary>
        </member>
        <member name="T:wx.ComponentModel.MessageClass">
            <summary>Classification of messages.</summary>
        </member>
        <member name="F:wx.ComponentModel.MessageClass.Error">
            <summary>The message is an error.
            The latest input cannot be accepted by the system and will be rejected.</summary>
        </member>
        <member name="F:wx.ComponentModel.MessageClass.Warning">
            <summary>This is a warning message.
            The latest input will be accepted but another the system recommends to
            think this over.</summary>
        </member>
        <member name="F:wx.ComponentModel.MessageClass.Info">
            <summary>This is a message simply for information.</summary>
        </member>
        <member name="T:wx.ComponentModel.IErrorHandler">
            <summary>Interface of means to display errors, warnings, or messages in response to value changes.
            Refer also to ErrorMessageException.</summary>
        </member>
        <member name="M:wx.ComponentModel.IErrorHandler.ShowMessage(wx.ComponentModel.MessageClass,System.String,System.Object[])">
            <summary>This tells the error handler to show the message of the provided properties.
            \param msgClass is the message class, typically wx.MessageClass.Error.
            \param msgFormat is a messge string that may contain wild cards like "{0}" or "{1}" that will be
                             replaced by the string form of the designated object. Typically, a translation
                             of <c>msgFormat</c> into the current culture or locale will be shown. However, this is left
                             to the error handler.
            \param objects is a sequence of objects that either occur in <c>msgFormat</c> or may serve as a structured information
                           on the error. The interpretation of such objects are left to the error handler. For instance, a
                           handler using the calendar control may use a <c>System.DateTime</c> object to determine the day
                           that is affected by the error.</summary>
        </member>
        <member name="T:wx.ComponentModel.ErrorMessageException">
            <summary>This exception represents an error message that shall be caught and passed to an error handler.
            All built in data models will catch this and pass it to an error handler.</summary>
        </member>
        <member name="M:wx.ComponentModel.ErrorMessageException.Show(wx.ComponentModel.IErrorHandler)">
            <summary>Display this on the provided error handler.
            If the argument is <c>null</c>, this will use a standard error handler (message dialog).</summary>
        </member>
        <member name="T:wx.ComponentModel.ErrorMessageDialog">
            <summary>Shows an error using the wx.MessageDialog.
            Opens at most one dialog non-modal.</summary>
        </member>
        <member name="M:wx.ComponentModel.ErrorMessageDialog.#ctor">
            <summary>Creates an instance without parent.</summary>
        </member>
        <member name="M:wx.ComponentModel.ErrorMessageDialog.#ctor(wx.Window)">
            <summary>Creates an instance with parent that will be used to determine the position of the dialog.</summary>
        </member>
        <member name="M:wx.ComponentModel.ErrorMessageDialog.ShowMessage(wx.ComponentModel.MessageClass,System.String,System.Object[])">
            <summary>Closing and destroying the old message box if one exists and open a new one.</summary>
        </member>
        <member name="P:wx.ComponentModel.ErrorMessageDialog.Parent">
            <summary>Returns the parent.
            The result may be <c>null</c>.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.IDataModel">
            <summary>Interface of nodes in the dependency network.</summary>
        </member>
        <member name="M:wx.ComponentModel.IDataModel.BeginSetValue(System.Object)">
            <summary>This will assign <c>newValue</c> and assign value propagation.
            Call EndSetValue() to end this transaction.
            
            Please note, that this will raise a <c>System.ApplicationException</c> if BeginSetValue() has been run without
            a following EndSetValue() and both values differ. This is to avoid non-terminating recursions.
            Please note, that dependency networks shall have the form of acyclic graphs. In acyclic graphs, propagation
            of dependencies is known to terminate.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.IDataModel.EndSetValue(System.Boolean)">
            <summary>Ends transaction safe setting of a value that has been initialized by BeginSetValue().</summary>
            <param name="commitOrRollback"> is <c>true</c> if the changes shall be committed and <c>false</c> if this shall rollback all changes since the
                   last BeginSetValue().</param>
            
        </member>
        <member name="M:wx.ComponentModel.IDataModel.BeginInit">
            <summary>All events will be deferred until EndInit() is called.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.IDataModel.EndInit">
            <summary>Fires events that have been deferred by BeginnInit().
            However, redundant events will not fire. Example: If this changes its value twice
            after BeginInit(), only the final assignment will be communicated by events.
            
            This is usually the same as PropagateValue() but additionally ends BeginnInit().
            </summary>
        </member>
        <member name="M:wx.ComponentModel.IDataModel.PropagateValue">
            <summary>Create events as if the current value has been set.
            The corresponding change event will have the current value as old value as well as 
            new value.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.IDataModel.Value">
            <summary>Read or change the encapsulated model.</summary><remarks>
                     * Writing this value is always equivalent to
                     * \code
                     IDataModel m=...;
                     m.Value=value; // this is equivalent to the following
                     
                     if (this._referenceType.IsInstanceOfType(value))
                     {
                         try
                         {
                            m.BeginSetValue(value);
                            m.EndSetValue(true);
                         }
                         catch (ErrorMessageException exc)
                         {
                            exc.Show(m.ErrorHandler);
                            m.EndSetValue(false);
                         }
                         catch (Exception exc)
                         {
                            m.EndSetValue(false);
                            throw exc;
                         }
                     }
                     else
                       throw new ArgumentException();
                     \endcode
                     * 
                     * The compatibility with the reference type is often tested in <c>BeginSetValue()</c> instead.
                     * 
                     * Please note, that this property is required to return the new value while propagating a change.</remarks>
        </member>
        <member name="P:wx.ComponentModel.IDataModel.ReferenceType">
            <summary>This is the reference type.
            This contraints assignments to <c>Value</c>.
            If reflection is used to define labale texts or visible parts of the model,
            then this type will be used.
            </summary>
        </member>
        <member name="E:wx.ComponentModel.IDataModel.OnValueChange">
            <summary>This will be called on any change to <c>Value</c>.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.IDataModel.PropagatesChanges">
            <summary>True iff all models, that this depends on, fire an event for changing a value.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.IDataModel.ErrorHandler">
            <summary>This is the used error handler. 
            This may be <c>null</c>.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.DataModelBase">
            <summary>Base class that helps to implement data models.
            This basically implements propagation of changes over depending models.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.#ctor(System.Type)">
            <summary>Create an instance of the provided reference type.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.#ctor">
            <summary>Create an instance of reference type <c>System.Object</c>.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.SetValue(System.Object)">
            <summary>Override this to change the represented value without propagation of dependencies.
            This MUST work without exceptions of IsConsistentValue() returns true.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.IsConsistentValue(System.Object)">
            <summary>True iff <c>value</c> may be assigned by <c>SetValue()</c> without error.
            This is also allowed to throw an <c>ErrorMessageException</c> in order to provide full
            information for an error handler.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.GetValue">
            <summary>Override this to read the represented value.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.PropagateChange(System.Object,System.Object)">
            <summary>This will raise <c>OnValueChange</c>.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.BeginSetValue(System.Object)">
            <summary>Initializes value changing transaction.
            This will change the value and</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.EndSetValue(System.Boolean)">
            <summary>Ends the transaction for setting a new value.
            This throws a <c>System.ApplitionException()</c>, if <c>BeginSetValue()</c> has not been called before.
            
            If <c>commitOrRollback</c> is <c>true</c>, then assign the new value. Otherwise, reset to the original value.</summary>
        </member>
        <member name="M:wx.ComponentModel.DataModelBase.PropagateValue">
            <summary>Propagate the current value raising <c>OnValueChange</c> as if the current value replaces the current value.</summary>
        </member>
        <member name="P:wx.ComponentModel.DataModelBase.Value">
            <summary>Get or set the encapsulated value.</summary>
        </member>
        <member name="P:wx.ComponentModel.DataModelBase.ReferenceType">
            <summary>The configured reference type of the value.</summary>
        </member>
        <member name="E:wx.ComponentModel.DataModelBase.OnValueChange">
            <summary>This event will be called on changing the value.</summary>
        </member>
        <member name="P:wx.ComponentModel.DataModelBase.PropagatesChanges">
            <summary>Overload this to declare whether this model is really able to detect and propagate all changes of the value.</summary>
        </member>
        <member name="P:wx.ComponentModel.DataModelBase.ErrorHandler">
            <summary>Get or set the error handler.</summary>
        </member>
        <member name="T:wx.ComponentModel.ValueModel">
            <summary>A Value model encapsulates an object. This object will be the value.</summary>
        </member>
        <member name="M:wx.ComponentModel.ValueModel.#ctor(System.Object,System.Type)">
            <summary>Creates a model of the provided value using type information from <c>referenceType</c>.
            Ths will raise an System.ArgumentException, if <c>value</c> is not an instance of <c>referenceType</c>.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.ValueModel.Value">
            <summary>
            Get or set the value.
            </summary>
        </member>
        <member name="P:wx.ComponentModel.ValueModel.PropagatesChanges">
            <summary>True, if this safely detects all changes of the encapsulated value.
            Unfortunately, this is not able to notice any change within the value if this is a class.
            However, on value types, the only way to change this is to call <c>SetValue</c>. Of course, this
            will be noticed and this change will be propagated.
            </summary>
        </member>
        <member name="T:wx.ComponentModel.PropertyModel">
            <summary>A data model observing a certain property of a structured value of a data model.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.#ctor(System.String,wx.ComponentModel.IDataModel)">
            <summary>Creates an instance encapsulating property <c>propertyName</c> of the value of <c>data</c>.
            If <c>data</c> does not have this property, this will be <c>null</c>.
            
            This will look for an <c>RaisesChangeEventAttribute</c> of the property in the reference
            type if <c>data</c> to determine, whether this propagates all changes. So, this will fail
            to keep track of changes if the property or the <c>RaisesChangeEventAttribute</c> is not declared
            in the reference type of the data source.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.OnChangingProperty(System.Object,wx.ComponentModel.ValueChangedEvent)">
            <summary>Propagate the change.</summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.AddChangeEventHandlerToObject(System.Object)">
            <summary>Adds this as listener to the event named <c>_propagatorEventName</c> in value.</summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.OnChangingDataSource(System.Object,wx.ComponentModel.ValueChangedEvent)">
            <summary>Makes sure that this listens to changes in the new value (if possible) and propagates <c>OnValueChange</c> events.</summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.ReadPropertyFromValue(System.Object)">
            <summary>Reads the property of interest of the provided value.
            If the property does not exist, return <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.ComponentModel.PropertyModel.GetValue">
            <summary>Reads property from the current data source value.</summary>
        </member>
        <member name="P:wx.ComponentModel.PropertyModel.PropagatesChanges">
            <summary>True if the data source propagates changes and this listens to an event that indicates changes of the encapsulated property of the current value that can be read from the data source.</summary>
        </member>
        <member name="T:wx.CloseEvent">
            <summary>
            This event class contains information about window and session close events.
            
            The handler function for EVT_CLOSE is called when the user has tried to close a a frame or dialog box using the
            window manager (X) or system menu (Windows). It can also be invoked by the application itself programmatically,
            for example by calling the wx.Window.Close() function.
            
            You should check whether the application is forcing the deletion of the window using wx.CloseEvent.CanVeto.
            If this is false, you must destroy the window using wx.Window.Destroy. If the return value is true, it is up to
            you whether you respond by destroying the window.
            
            If you don't destroy the window, you should call wx.CloseEvent.Veto to let the calling code know that you did
            not destroy the window. This allows the wx.Window.Close() function to return true or false depending on whether the
            close instruction was honoured or not.
            
            Please do not forget to skip the event after processing. wxWidgets may stop closig down the application
            if the event has not been skipped.
            </summary>
        </member>
        <member name="M:wx.CloseEvent.Veto">
            <summary>Listeners of this event may veto the closing sequence if they are not ready for closing.
            Do not forget to skip of not vetoed.
            </summary>
        </member>
        <member name="M:wx.CloseEvent.Veto(System.Boolean)">
            <summary>Listeners of this event may veto the closing sequence if they are not ready for closing.
            Do not forget to skip of not vetoed.
            </summary>
            <param name="veto">True if you want to vetoe, false otherwise.</param>
        </member>
        <member name="P:wx.CloseEvent.LoggingOff">
            <summary>
            Returns true if the user is just logging off or false if the system is shutting down.
            This method can only be called for end session and query end session events, it doesn't make sense for
            close window event.
            </summary>
        </member>
        <member name="P:wx.CloseEvent.CanVeto">
            <summary>
            Returns true if you can veto a system shutdown or a window close event. Vetoing a window close event is not possible
            if the calling code wishes to force the application to exit, and so this function must be called to check this.
            </summary>
        </member>
        <member name="T:wx.NotebookEvent">
            <summary>This event will be raised on selecting tabs in notebooks.</summary>
        </member>
        <member name="P:wx.NotebookEvent.Selection">
            <summary>Returns the currently selected page, or -1 if none was selected.
            NB: under Windows, <c>Selection</c> will return the same value as <c>OldSelection</c> when called from
            <c>EVT_NOTEBOOK_PAGE_CHANGING</c> handler and not the page which is going to be selected.
            Also note that the values of selection and old selection returned for an event generated in
            response to a call to wx.Notebook.SetSelection shouldn't be trusted as they are currently inconsistent
            under different platforms (but in this case you presumably don't need them anyhow as you already
            have the corresponding information).</summary>
        </member>
        <member name="T:wx.Notebook">
             <summary>
             This class represents a notebook control, which manages multiple windows with associated tabs.
            
             To use the class, create a wx.Notebook object and call AddPage or InsertPage, passing a window to be
             used as the page. Do not explicitly delete the window for a page that is currently managed by wx.Notebook.
             </summary>
             <remarks>
             \image html notebooksmall.png
             </remarks>
        </member>
        <member name="M:wx.Notebook.GetPage(System.Int32)">
            <summary>
            The window representing the page.
            </summary>
            <param name="page">Zero-based index</param>
        </member>
        <member name="P:wx.Notebook.Selection">
            <summary>
            The zero-based index of the currently selected page. Use this property
            to read or set the currently selected note.
            </summary>
        </member>
        <member name="F:wx.wxImageList.wxIMAGE_LIST_NORMAL">
            <summary>Normal size icons.</summary>
        </member>
        <member name="F:wx.wxImageList.wxIMAGE_LIST_SMALL">
            <summary>Small size icons</summary>
        </member>
        <member name="F:wx.wxImageList.wxIMAGE_LIST_STATE">
            <summary>Not yet implemented.
            Refer to  wxWidgets documentation.</summary>
        </member>
        <member name="F:wx.wxImageList.Normal">
            <summary>Normal size icons
            Same as wxIMAGE_LIST_NORMAL().</summary>
        </member>
        <member name="F:wx.wxImageList.Small">
            <summary>Small size icons
            Same as wxIMAGE_LIST_SMALL().</summary>
        </member>
        <member name="T:wx.ImageList">
            <summary>
            An image list is a list of images that may have transparent areas.
            The class helps an application organise a collection of images so that they can be
            referenced by integer index instead of by pointer.
            </summary>
        </member>
        <member name="M:wx.ImageList.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            The mask will be created for all images.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
        </member>
        <member name="M:wx.ImageList.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
            <param name="mask">true if masks should be created for all images (default).</param>
        </member>
        <member name="M:wx.ImageList.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Constructor specifying the image size, whether image masks should be created, and the initial size of the list.
            </summary>
            <param name="width">Width of the images in the list.</param>
            <param name="height">Height of the images in the list.</param>
            <param name="mask">true if masks should be created for all images.</param>
            <param name="initialCount">The initial size of the list.</param>
        </member>
        <member name="M:wx.ImageList.Add(wx.Bitmap)">
            <summary>
            Adds a new image or images using a bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:wx.ImageList.Add(wx.Bitmap,wx.Bitmap)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <param name="mask">Monochrome mask bitmap, representing the transparent areas of the image. </param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:wx.ImageList.Add(wx.Icon)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="icon">Icon to use as the image.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:wx.ImageList.Add(wx.Bitmap,wx.Colour)">
            <summary>
            Adds a new image or images using a bitmap and optional mask bitmap.
            </summary>
            <param name="bitmap">Bitmap representing the opaque areas of the image.</param>
            <param name="maskColour">Colour indicating which parts of the image are transparent.</param>
            <returns>The zero-based image index of the new bitmap.</returns>
        </member>
        <member name="M:wx.ImageList.GetBitmap(System.Int32)">
            <summary>
            Returns the bitmap of the provided zero-based index.
            </summary>
            <param name="index">The index of the bitmap to be returned</param>
        </member>
        <member name="P:wx.ImageList.Count">
            <summary>
            Number of images.
            </summary>
        </member>
        <member name="P:wx.ImageList.ImageCount">
            <summary>
            Number of images
            </summary>
        </member>
        <member name="P:wx.ImageList.Item(System.Int32)">
            <summary>
            Synonym for GetBitmap().
            </summary>
            <param name="index">The zero-based index of the bitmap to return.</param>
        </member>
        <member name="T:wx.Html.Help.HtmlHelpController">
            <summary>
            The help controller.
            </summary>
            <remarks>
            \image html htmlhelpsmall.png
            </remarks>
        </member>
        <member name="M:wx.Html.Help.HtmlHelpController.AddBook(System.String)">
            <summary>Adds the book at the provided file name.
            In contrast to the  wxWidgets version, this method
            silently installs the  wx file handler for zip file
            entries. The file system is currently not wrapped since
            the .NET framework implements most of the provided functions.
            However, handling of zip-archives is required to deal with
            hyper text books (HTB), so this ability will be installed on
            using it.</summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpController.TitleFormat">
            <summary>This property is for writing only and set the title format.</summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpController.TempDir">
            <summary>Write-only property to set the directory for temporary files (option for better performance).</summary>
        </member>
        <member name="T:wx.Html.Help.HtmlHelpController.Style">
            <summary>Some style flags for the HtmlHelpController.</summary>
        </member>
        <member name="T:wx.CannotChangeReadonly">
            <summary>
            This exception will be thrown if modifiers of readonly (ICanBeMadeReadonly) objects are used.
            </summary>
        </member>
        <member name="T:wx.ColourDatabase">
            <summary>The database of colours.
            Use whenever possible a database of colours.
            Property <c>TheColourDatabase</c> provides access to  wxWidget's standard colour database.</summary>
        </member>
        <member name="P:wx.ColourDatabase.TheColourDatabase">
            <summary>The standard database.
            The standard database contains at least the following colours:
            AQUAMARINE, BLACK, BLUE, BLUE VIOLET, BROWN, CADET BLUE, CORAL, CORNFLOWER BLUE, CYAN, DARK GREY,
            DARK GREEN, DARK OLIVE GREEN, DARK ORCHID, DARK SLATE BLUE, DARK SLATE GREY DARK TURQUOISE,
            DIM GREY, FIREBRICK, FOREST GREEN, GOLD, GOLDENROD, GREY, GREEN, GREEN YELLOW, INDIAN RED, KHAKI,
            LIGHT BLUE, LIGHT GREY, LIGHT STEEL BLUE, LIME GREEN, MAGENTA, MAROON, MEDIUM AQUAMARINE, MEDIUM BLUE,
            MEDIUM FOREST GREEN, MEDIUM GOLDENROD, MEDIUM ORCHID, MEDIUM SEA GREEN, MEDIUM SLATE BLUE,
            MEDIUM SPRING GREEN, MEDIUM TURQUOISE, MEDIUM VIOLET RED, MIDNIGHT BLUE, NAVY, ORANGE, ORANGE RED,
            ORCHID, PALE GREEN, PINK, PLUM, PURPLE, RED, SALMON, SEA GREEN, SIENNA, SKY BLUE, SLATE BLUE,
            SPRING GREEN, STEEL BLUE, TAN, THISTLE, TURQUOISE, VIOLET, VIOLET RED, WHEAT, WHITE, YELLOW,
            YELLOW GREEN.</summary>
        </member>
        <member name="T:wx.PenList">
            <summary>Wrapper for <c>wxPenList</c>.
            Whenever possible use static property <c>ThePenList() </c>.
            </summary>
        </member>
        <member name="M:wx.PenList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="P:wx.PenList.ThePenList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:wx.BrushList">
            <summary>Wrapper for <c>wxBrushList</c>.
            Whenever possible use static property <c>TheBrushList()</c>.
            </summary>
        </member>
        <member name="M:wx.BrushList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="P:wx.BrushList.TheBrushList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:wx.FontList">
            <summary>Wrapper for <c>wxFontList</c>.
            Whenever possible use property TheFontList() to retrieve fonts.
            </summary>
        </member>
        <member name="M:wx.FontList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="M:wx.FontList.FindOrCreateWithFamily(wx.Font,wx.FontFamily)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>family</c>.
            </summary>
        </member>
        <member name="M:wx.FontList.FindOrCreateWithWeight(wx.Font,wx.FontWeight)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>weight</c>.
            </summary>
        </member>
        <member name="M:wx.FontList.FindOrCreateWithStyle(wx.Font,wx.FontStyle)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>style</c>.
            </summary>
        </member>
        <member name="M:wx.FontList.FindOrCreateWithSize(wx.Font,System.Int32)">
            <summary>Get a font with all properties from <c>prototype</c> but of the given <c>size</c>.
            </summary>
        </member>
        <member name="M:wx.FontList.FindOrCreateUnderlined(wx.Font,System.Boolean)">
            <summary>Get a font with all properties from <c>prototype</c> but underlined according to <c>isUnderlined</c>.
            </summary>
        </member>
        <member name="P:wx.FontList.TheFontList">
            <summary>The global font list.
             Use this whenever possible to retrieve fonts.
            </summary>
        </member>
        <member name="T:wx.BitmapList">
            <summary>
            List of bitmaps that can be used in controls (ListCtrl) to associate data with icons.
            </summary>
        </member>
        <member name="M:wx.BitmapList.Dispose">
            <summary>\internal HMaH: Needs to be disposed explcitley since non-virtual but also non-trivial DTor.</summary>
        </member>
        <member name="T:wx.DataObject">
            <summary>wx.DataObject represents a piece of data which knows which formats it
             supports and knows how to render itself in each of them - <c>GetDataHere()</c>,
             and how to restore data from the buffer (SetData()).
            
             Although this class may be used directly (i.e. custom classes may be
             derived from it), in many cases it might be simpler to use either
             wx.DataObjectSimple or wxDataObjectComposite classes.
            
             A data object may be "read only", i.e. support only GetData() functions or
             "read-write", i.e. support both GetData() and SetData() (in principle, it
             might be "write only" too, but this is rare). Moreover, it doesn't have to
             support the same formats in Get() and Set() directions: for example, a data
             object containing JPEG image might accept BMPs in GetData() because JPEG
             image may be easily transformed into BMP but not in SetData(). Accordingly,
             all methods dealing with formats take an additional "direction" argument
             which is either SET or GET and which tells the function if the format needs
             to be supported by SetData() or GetDataHere().</summary>
        </member>
        <member name="T:wx.FileDataObject">
             <summary>
             wx.FileDataObject is a specialization of wxDataObject for file names.
             The program works with it just as if it were a list of absolute file names,
             but internally it uses the same format as Explorer and other compatible programs
             under Windows or GNOME/KDE filemanager under Unix which makes it possible to receive
             files from them using this class.
            
             Warning: Under all non-Windows platforms this class is currently "input-only", i.e.
             you can receive the files from another application, but copying (or dragging) file(s)
             from a wxWidgets application is not currently supported. PS: GTK2 should work as well.
             </summary>
        </member>
        <member name="T:wx.DataObjectComposite">
            <summary>wx.DataObjectComposite is the simplest way to implement wx.DataObject supporting multiple formats.
             It contains several wx.DataObjectSimple and
             supports all formats supported by any of them.
            
             This class shouldn't be (normally) derived from, but may be used directly.
             If you need more flexibility than what it provides, you should probably use
             wxDataObject directly.
             </summary>
        </member>
        <member name="M:wx.DataObjectComposite.Add(wx.DataObjectSimple,System.Boolean)">
            <summary>Add data object (it will be deleted by wx.DataObjectComposite).
            </summary>
            <param name="preferred"> specifies with <c>true</c>, that the format of <c>newPart</c> will become the preferred one.
            </param>
        </member>
        <member name="M:wx.DataObjectComposite.Add(wx.DataObjectSimple)">
            <summary>Add data object (it will be deleted by wx.DataObjectComposite).
            The format of <c>newPart</c> will become the preferred one.</summary>
        </member>
        <member name="M:wx.DataObjectComposite.GetReceivedFormat">
            <summary>Report the format passed to the SetData method.
            This should be the
            format of the data object within the composite that recieved data from
            the clipboard or the DnD operation.  You can use this method to find
            out what kind of data object was recieved.</summary>
        </member>
        <member name="T:wx.FontCtrl">
            <summary>This is a control to put in fonts that may be used within forms or tables.
            This is a panel composed of a masked edit control allowing for the input of plattform indpendent font attributes and
            a button, that will rise a font dialog if pressed. 
            
            Use the styles wx.WindowStyles.FONTCTRL_EDIT_POINT_SIZE, wx.WindowStyles.FONTCTRL_EDIT_FONT_FAMILY,
            wx.WindowStyles.FONTCTRL_EDIT_FONT_WEIGHT, wx.WindowStyles.FONTCTRL_EDIT_FONT_STYLE, and wx.WindowStyles.FONTCTRL_EDIT_FONT_COLOUR
            to customize the input fields</summary>
        </member>
        <member name="E:wx.FontCtrl.OnChanged">
            <summary>This will be called immediately after a value has been changed.</summary>
        </member>
        <member name="T:wx.FontCtrl.OnChangedEvent">
            <summary>Argument of change event handlers.</summary>
        </member>
        <member name="T:wx.FontCtrl.OnChangedHandler">
            <summary>Handler of the "value changed" event.</summary>
        </member>
        <member name="T:wx.ColourCtrl">
            <summary>This is a control to put in colours that may be used within forms or tables.
            This is a panel composed of a masked edit control allowing for the input of RGB and Alpha values and
            a button, that will rise a colour dialog if pressed. The button will be coloured in the specified
            colour.</summary>
        </member>
        <member name="E:wx.ColourCtrl.OnChanged">
            <summary>This will be called immediately after a value has been changed.</summary>
        </member>
        <member name="P:wx.ColourCtrl.Colour">
            <summary>This is for reading the colour input.</summary>
        </member>
        <member name="T:wx.ColourCtrl.OnChangedEvent">
            <summary>Argument of change event handlers.</summary>
        </member>
        <member name="T:wx.ColourCtrl.OnChangedHandler">
            <summary>Handler of the "value changed" event.</summary>
        </member>
        <member name="T:wx.BitmapButton">
            <summary>Button showing a bitmap.
            Special style flag: wx.WindowStyles.BU_AUTODRAW.</summary>
        </member>
        <member name="T:wx.SashWindow">
            <summary>
            SashWindow allows any of its edges to have a sash which can be dragged to resize the window.
            The actual content window will be created by the application as a child of SashWindow. The window
            (or an ancestor) will be notified of a drag via a wxSashEvent notification.
            </summary>
            <remarks>
            \image html sashwindow.png
            </remarks>
        </member>
        <member name="M:wx.SashWindow.SetSashVisible(wx.SashEdgePosition,System.Boolean)">
            <summary>
            Call this function to make a sash visible or invisible on a particular edge.
            </summary>
            <param name="edge">The sash that shall be set or reset.</param>
            <param name="sash">true to make the sash visible, false to make it invisible.</param>
        </member>
        <member name="M:wx.SashWindow.GetSashVisible(wx.SashEdgePosition)">
            <summary>
            Returns true if a sash is visible on the given edge, false otherwise.
            </summary>
            <param name="edge">The edge that shall be reported</param>
        </member>
        <member name="T:wx.EventListener">
            <summary>A delegate calling handlers for instances of wx.Event.</summary>
        </member>
        <member name="T:wx.Drag">
            <summary> Flags to define the drag operation in wx.DragSource.DoDragDrop().</summary>
            <remarks>Cf. \ref drag-and-drop.</remarks>
        </member>
        <member name="T:wx.DropSource">
            <summary>
            This class represents a source for a drag and drop operation.
            </summary>
            <remarks>Cf. \ref drag-and-drop</remarks>
        </member>
        <member name="M:wx.DropSource.#ctor(System.IntPtr)">
            <summary>
            For internal use only
            </summary>
            <param name="wxObject">Pointer to a native C++ instance</param>
        </member>
        <member name="M:wx.DropSource.#ctor(wx.Window)">
            <summary>
            Creates a drop source referring to the provided window as data source.
            </summary>
            <param name="win">The source of the dropped data.</param>
        </member>
        <member name="M:wx.DropSource.#ctor(wx.DataObject,wx.Window)">
            <summary>
            Creates a drop source referring to a window provising the data and the dragged data.
            </summary>
            <param name="dataObject">The dragged data.</param>
            <param name="win">The source of the dropped data.</param>
        </member>
        <member name="M:wx.DropSource.DoDragDrop(wx.Drag)">
            <summary>
            Do it (call this in response to a mouse button press, for example).
            This starts the drag-and-drop operation which will terminate when the user releases the mouse.
            </summary>
            <param name="flags">Describes the drag operation.
            If wx.Drag.wxDrag_AllowMove is included in the flags, data may be moved and not only copied (default).
            If wx.Drag.wxDrag_DefaultMove is specified (which includes the previous flag), this is even the default 
            operation.</param>
            <returns>Returns the operation requested by the user, may be wx.Drag.wxDragCopy, wx.Drag.wxDragMove,
            wx.Drag.wxDragLink, wx.Drag.wxDragCancel, or wx.Drag.wxDragNone if an error occurred.</returns>
        </member>
        <member name="T:wx.DropTarget">
             <summary>
             This class represents a target for a drag and drop operation. A wx.DataObject can be associated with it and by default,
             this object will be filled with the data from the drag source, if the data formats supported by the data object match
             the drag source data format.
            
             There are various virtual handler functions defined in this class which may be overridden to give visual feedback or
             react in a more fine-tuned way, e.g. by not accepting data on the whole window area, but only a small portion of it.
             The normal sequence of calls is OnEnter(), possibly many times OnDragOver(), OnDrop() and finally OnData().
             </summary>
             <remarks>
             Cf. \ref drag-and-drop.
             </remarks>
        </member>
        <member name="M:wx.DropTarget.OnDragOver(System.Int32,System.Int32,wx.DragResult)">
            <summary>
            Called when the mouse is being dragged over the drop target.
            By default, this calls functions return the suggested return value "def".
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
        </member>
        <member name="M:wx.DropTarget.OnDrop(System.Int32,System.Int32)">
            <summary>
            Called when the user drops a data object on the target. Return false to veto the operation.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="M:wx.DropTarget.OnData(System.Int32,System.Int32,wx.DragResult)">
            <summary>
            Called after OnDrop() returns true. By default this will usually GetData() and will return the suggested default
            value def.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
        </member>
        <member name="M:wx.DropTarget.GetData">
            <summary>
            This method may only be called from within wx.DropTarget.OnData.
            By default, this method copies the data from the drop source to the wx.DataObject associated
            with this drop target, calling its wx.DataObject.SetData method.
            </summary>
        </member>
        <member name="M:wx.DropTarget.OnEnter(System.Int32,System.Int32,wx.DragResult)">
            <summary>
            Called when the mouse enters the drop target. By default, this calls OnDragOver().
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="def">Suggested default for return value. Determined by SHIFT or CONTROL key states.</param>
            <returns>Returns the desired operation or wxDragNone. This is used for optical feedback from the
            side of the drop source, typically in form of changing the icon.</returns>
        </member>
        <member name="M:wx.DropTarget.OnLeave">
            <summary>
            Called when the mouse leaves the drop target.
            </summary>
        </member>
        <member name="P:wx.DropTarget.DataObject">
            <summary>
            Sets the data wxDataObject associated with the drop target and deletes any previously associated data object.
            </summary>
        </member>
        <member name="T:wx.TextDropTarget">
            <summary>
            A predefined drop target for dealing with text data.
            </summary>
            <remarks>
            Cf. \ref drag-and-drop.
            </remarks>
        </member>
        <member name="M:wx.TextDropTarget.OnDropText(System.Int32,System.Int32,System.String)">
            <summary>
            Override this function to receive dropped text.
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="text">The data being dropped: a string.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="T:wx.FileDropTarget">
            <summary>
            This is a drop target which accepts files e.g. dragged from File Manager or Explorer
            (\ref drag-and-drop).
            </summary>
        </member>
        <member name="M:wx.FileDropTarget.OnDropFiles(System.Int32,System.Int32,System.String[])">
            <summary>Called if files are dropped on this target.</summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <param name="filenames">Names of the files to be dropped</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="M:wx.FileDropTarget.OnDrop(System.Int32,System.Int32)">
            <summary>
            See wx.DropTarget.OnDrop. This function is implemented appropriately for files, and calls wx.FileDropTarget.OnDropFiles().
            </summary>
            <param name="x">The x coordinate of the mouse.</param>
            <param name="y">The y coordinate of the mouse.</param>
            <returns>Return true to accept the data, false to veto the operation.</returns>
        </member>
        <member name="T:wx.SashLayoutWindow">
             <summary>
             SashLayoutWindow responds to <c>OnCalculateLayout</c> events generated by LayoutAlgorithm.
             It allows the application to use simple accessors to specify how the window should be laid out,
             rather than having to respond to events. The fact that the class derives from SashWindow allows
             sashes to be used if required, to allow the windows to be user-resizable.
            
             The documentation for LayoutAlgorithm explains the purpose of this class in more detail.
             </summary>
             <remarks>
             \image html sashwindow.png
             </remarks>
        </member>
        <member name="T:wx.LayoutAlgorithm">
             <summary>
             wxLayoutAlgorithm implements layout of subwindows in MDI or SDI frames. It sends a CalculateLayoutEvent
             event to children of the frame, asking them for information about their size. For MDI parent frames, the
             algorithm allocates the remaining space to the MDI client window (which contains the MDI child frames).
             For SDI (normal) frames, a 'main' window is specified as taking up the remaining space.
             </summary>
             <remarks>
             Because the event system is used, this technique can be applied to any windows, which are not necessarily
             'aware' of the layout classes (no virtual functions in wxWindow refer to wxLayoutAlgorithm or its events).
             However, you may wish to use wxSashLayoutWindow for your subwindows since this class provides handlers for
             the required events, and accessors to specify the desired size of the window. The sash behaviour in the base
             class can be used, optionally, to make the windows user-resizable.
            
             LayoutAlgorithm is typically used in IDE (integrated development environment) applications, where there are
             several resizable windows in addition to the MDI client window, or other primary editing window. Resizable
             windows might include toolbars, a project window, and a window for displaying error and warning messages.
            
             When a window receives an OnCalculateLayout event, it should call SetRect in the given event object, to be the
             old supplied rectangle minus whatever space the window takes up. It should also set its own size accordingly. 
             SashLayoutWindow::OnCalculateLayout generates an OnQueryLayoutInfo event which it sends to itself to determine
             the orientation, alignment and size of the window, which it gets from internal member variables set by the application.
            
             The algorithm works by starting off with a rectangle equal to the whole frame client area. It iterates through
             the frame children, generating OnCalculateLayout events which subtract the window size and return the remaining 
             rectangle for the next window to process. It is assumed (by SashLayoutWindow.OnCalculateLayout) that a window
             stretches the full dimension of the frame client, according to the orientation it specifies. For example, a
             horizontal window will stretch the full width of the remaining portion of the frame client area. In the other
             orientation, the window will be fixed to whatever size was specified by OnQueryLayoutInfo. An alignment setting
             will make the window 'stick' to the left, top, right or bottom of the remaining client area. This scheme implies
             that order of window creation is important. Say you wish to have an extra toolbar at the top of the frame, a
             project window to the left of the MDI client window, and an output window above the status bar. You should therefore
             create the windows in this order: toolbar, output window, project window. This ensures that the toolbar and output
             window take up space at the top and bottom, and then the remaining height in-between is used for the project window.
             
             LayoutAlgorithm is quite independent of the way in which OnCalculateLayout chooses to interpret a window's size
             and alignment. Therefore you could implement a different window class with a new OnCalculateLayout event handler,
             that has a more sophisticated way of laying out the windows. It might allow specification of whether stretching
             occurs in the specified orientation, for example, rather than always assuming stretching. (This could, and probably
             should, be added to the existing implementation).
            
             \par Note
             LayoutAlgorithm has nothing to do with LayoutConstraints. It is an alternative way of specifying layouts for which
             the normal constraint system is unsuitable.
             </remarks>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            Will ask you to <c>_("Choose a file")</c>.
            </summary>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String,System.String,System.String,System.String)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String,System.String,System.String,System.String,wx.WindowStyles)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,System.String,System.String,System.String,System.String,wx.WindowStyles,System.Drawing.Point)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.
            </summary>
            <param name="message">Message string</param>
            <param name="defaultDir">Displays files in this path first</param>
            <param name="defaultFile">The default filename</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="pos">The position of this dialog</param>
        </member>
        <member name="M:wx.FileDialog.#ctor(wx.Window,wx.wxString,wx.wxString,wx.wxString,wx.wxString,wx.WindowStyles,System.Int32,System.Int32)">
            <summary>Use this CTor with dialog style. 
            Specific style flags start with prefix FD_.</summary>
        </member>
        <member name="M:wx.FileDialog.ShowModal">
            <summary>
            This will show the dialog, wait for an input and return ShowModalResult.OK on successful userinput.
            On cancelled input, the result will be ShowModalResult.CANCEL.
            Read <c>Filename</c> or <c>Filenames</c> for the results.
            </summary>
        </member>
        <member name="P:wx.FileDialog.Directory">
            <summary>
            The directory where the files have been selected.
            </summary>
        </member>
        <member name="P:wx.FileDialog.Filename">
            <summary>
            Returns the file that has been selected without directory.
            </summary>
        </member>
        <member name="P:wx.FileDialog.Path">
            <summary>
            Returns the path that has been selected - directory and filename.
            </summary>
        </member>
        <member name="P:wx.FileDialog.Paths">
            <summary>
            Returns the paths that have been selected - directory and filename.
            </summary>
        </member>
        <member name="P:wx.FileDialog.Filenames">
            <summary>
            Returns an array of the selected filenames (without directory).
            </summary>
        </member>
        <member name="T:wx.ConfigStyle">
            <summary>Style flags for the wx.Config class.
            </summary>
        </member>
        <member name="F:wx.ConfigStyle.USE_DEFAULT_STYLE">
            <summary>This will read and store the configuration from and to the default location.
            If  wxWidgets has been compiled with <c>wxUSE_CONFIG_NATIVE</c>, this is usually
            the registry (using <c>wxRegConfig</c>).</summary>
        </member>
        <member name="F:wx.ConfigStyle.USE_LOCAL_FILE">
            <summary>
            Use this to use a local file (within the home of the user) rather than a global file or HKCU rather than HKLM 
            in the registry base of Windows. This may be specified in conjunction with USE_GLOBAL_FILE. In that case,
            the configuration class will search for locally defined values first and consider the global file or HKLM if
            the local configuration does not define the value.
            </summary>
        </member>
        <member name="F:wx.ConfigStyle.USE_GLOBAL_FILE">
            <summary>
            Use this to use a global file rather than a local file (within the home of the user) or HKLM rather than HKCU 
            in the registry base of Windows. This may be specified in conjunction with USE_LOCAL_FILE. In that case,
            the configuration class will search for locally defined values first and consider the global file or HKLM if
            the local configuration does not define the value. However, the configuration will always be saved locally.
            This implementation does not provide any means to write global configurations.
            </summary>
        </member>
        <member name="F:wx.ConfigStyle.USE_RELATIVE_PATH">
            <summary>Only relevant if using a file for reading/writing the configuration.
            </summary>
        </member>
        <member name="F:wx.ConfigStyle.USE_NO_ESCAPE_CHARACTERS">
            <summary>This will turn off character escaping for the values of entries stored in the config file.
            For example a foo key with some backslash characters will be stored as <c>foo=C:\mydir</c> instead
            of the usual storage of <c>foo=C:\\mydir</c>. For <c>wxRegConfig</c>, this flag refers to HKLM,
            and provides read-only access.
            The <c>USE_NO_ESCAPE_CHARACTERS</c> style can be helpful if your config file must be read or
            written to by a non-wxWidgets program (which might not understand the escape characters).
            Note, however, that if <c>USE_NO_ESCAPE_CHARACTERS</c> style is used, it is is now your
            application's responsibility to ensure that there is no newline or other illegal
            characters in a value, before writing that value to the file.
            </summary>
        </member>
        <member name="T:wx.XmlSerializer">
            <summary>Service class that implements serialization of colours and fonts into XML.</summary><remarks>
                 * Create an instance encapsulating a font or a colour to serialize or call ReadXml()
                 * to deserialize. Example:
                 * \code
                 // This writes a font before writing a colour into an xmlWriter.
                 XmlSerializer serializer=new XmlSerializer(font);
                 serializer.WriteXml(xmlWriter);
                 serializer.Colour=colour;
                 serializer.WriteXml(xmlWriter);
                 
                 // this reads a colour after a font from an xmlReader.
                 serializer.ReadXml(xmlReader);
                 font=serializer.Font;
                 serializer.ReadXml(xmlReader);
                 colour=serializer.Colour;
                 \endcode
                 * </remarks>
        </member>
        <member name="M:wx.XmlSerializer.#ctor">
            <summary>Creates an instance without data.
            Serialization will be a NOP.</summary>
        </member>
        <member name="M:wx.XmlSerializer.#ctor(wx.Font)">
            <summary>Creates an instance referring to a font for serialization.</summary>
        </member>
        <member name="M:wx.XmlSerializer.#ctor(wx.Colour)">
            <summary>Creates an instance referring to a colour for serialization.</summary>
        </member>
        <member name="M:wx.XmlSerializer.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:wx.XmlSerializer.ReadXml(System.Xml.XmlReader)">
            <summary>This will either read a colour or a font from <c>reader</c> and provide the result as <c>Colour</c> or <c>Font</c>.
            If <c>reader</c> does not provide an appropriate serialization, then <c>Colour</c> and <c>Font</c> will be <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.XmlSerializer.WriteXml(System.Xml.XmlWriter)">
            <summary>Writes the data to <c>writer</c>.
            The data may either be a colour or a font that has been set by the CTor
            or assignment to an appropriate property. Data <c>null</c> will cause this to be
            a NOP.
            </summary>
        </member>
        <member name="P:wx.XmlSerializer.Font">
            <summary>Gets or sets a font as data.
            Use this property to retrieve a font that has been read by ReadXml()
            or to set a font to be written by WriteXml().</summary>
        </member>
        <member name="P:wx.XmlSerializer.Colour">
            <summary>Gets or sets a colour as data.
            Use this property to retrieve a Colour that has been read by ReadXml()
            or to set a font to be written by WriteXml().</summary>
        </member>
        <member name="T:wx.Config">
            <summary>This is the class for writing and reading configuration parameters via wxWidgets <c>wxConfigBase</c> implementations.
            
             The idea of  wxWidgets configuration class is to provide an interface that allows
             applications to manage configuration data without regard to the method of storing the
             information. Configurations may either be stored in a global or local file, or into the
             registry database. The syntax of the files is according to the good old Ini-files as
             common to 16-Bit Windows.
             
             This class only maintains (writes to) user specific configurations.
             </summary>
             <remarks>
             This interface might be extended in the future to provide some additional styles that
             implement the standard way of configuring .NET applications (XML file <c>myApp.exe.config</c> for
             application <c>myApp.exe</c> read by class System.Configuration.Configuration).
             
             Although <c>wxConfig</c> is not derived from <c>wxObject</c>, this class is derived from wx.Object since
             the main concern of wx.Object is to manage pointers to C++ objects.
             Use Config.Get() to get an instance.
             
             The original C++ implementation uses Method <c>Read</c> with many, many signatures. Since this may lead to
             some confusion (at least I have been confused on using this class), this class implements <c>Read</c>
             functionality in two flavours: Returning the value or a default as method result and loading a
             reference with the value from the configuration if this has been found. Methods of the first flavour
             still are called <c>Read</c> whereas methods of the second flavour contain the data type as part of their name
             like wx.Config.ReadInt(). 
             
             In the past, both flavours were named simply <c>Read</c>. Hence, programmers that missed to use the small
             C# keyword <c>ref</c> accidentally turned an intended call of flavour 2 into one of flavour 1.
             
             A few things have been added to this class going beyond the functions in  wxWidgets: WriteProperties()
             and ReadProperties() will write and read public properties and fields using reflection.
             
             \b Problems:
             There is some evidence that reading strings for non-existing keys using a default value
             might lead to memory corruption at least in some cases.
            </remarks>
        </member>
        <member name="M:wx.Config.#ctor(System.String,System.String,System.String,System.String,wx.ConfigStyle)">
            <summary>Use this CTor and call Set() to create a configuration of a particular style.</summary>
            <param name="appName"> The application name. If this is empty, the class will normally use
                   wx.App.GetAppName to set it. The application name is used in the registry key on
                   Windows, and can be used to deduce the local filename parameter if that is missing.
                   </param>
            <param name="vendorName"> The vendor name. If this is empty, it is assumed that no vendor name is
                   wanted, if this is optional for the current config class. The vendor name is
                   appended to the application name for <c>wxRegConfig</c>.
                   </param>
            <param name="localName"> Some config classes require a local filename. If this is not
                   present, but required, the application's name will be used instead.
                   </param>
            <param name="globalName"> Some config classes require a global filename. If this is not
                   present, but required, the application's name will be used instead.
                   </param>
            <param name="style"> Can be one of <c>USE_LOCAL_FILE</c> and <c>USE_GLOBAL_FILE</c>. The style interpretation
                   depends on the config class and is ignored by some. For <c>wxFileConfig</c>, these
                   styles determine whether a local or global config file is created or used. If
                   the flag is present but the parameter is empty, the parameter will be set to a
                   default. If the parameter is present but the style flag not, the relevant flag
                   will be added to the style. For wxFileConfig you can also add <c>USE_RELATIVE_PATH</c>
                   by logically or'ing it to either of the _FILE options to tell <c>wxFileConfig</c> to
                   use relative instead of absolute paths. For <c>wxFileConfig</c>, you can also add
                   USE_NO_ESCAPE_CHARACTERS which will turn off character escaping for the values
                   of entries stored in the config file.</param>
        </member>
        <member name="M:wx.Config.Set(wx.Config)">
            <summary>This method will set the argument as the current configuration returning the old instance of Config that has been the current configuration before calling this.</summary>
        </member>
        <member name="M:wx.Config.Set(wx.ConfigStyle)">
            <summary>
            Creates a new configuration using the provided style and returns the result. The new configuration
            will be the default instance returned by Get().
            </summary>
            <param name="style">A style describing the new instance.</param>
            <returns></returns>
        </member>
        <member name="M:wx.Config.Get(System.Boolean)">
            <summary>This will get the current configuration of the application.
            If the argument is <c>true</c>, this method will wx.Config.Create() a new configuration
            is required.</summary>
        </member>
        <member name="M:wx.Config.Get">
            <summary>Equivalent to wx.Config.Get(true).</summary>
        </member>
        <member name="M:wx.Config.Create">
            <summary>Create a new configuration according to properties of the application.
            On Windows, the configuration will preferably recorded in the registry database
            within the <c>HKEY_CURRENT_USER</c> section using the vendor's name and the application's name
            to create subkeys. However, this depends on whether <c>wxUSE_CONFIG_NATIVE</c> has been defined
            on compiling  wxWidgets or not. In most other cases, this will use a file of the application
            name in the current working directory. Refer also to wx.App.AppName and wx.App.VendorName.</summary>
        </member>
        <member name="M:wx.Config.GetFirstGroup(System.String@,System.Int32@)">
            <summary>
            Gets the first group in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first group.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:wx.Config.GetEnumeratorOfGroups"/>
        </member>
        <member name="M:wx.Config.GetNextGroup(System.String@,System.Int32@)">
            <summary>
            Gets the next group in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the next group.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:wx.Config.GetEnumeratorOfGroups"/>
        </member>
        <member name="M:wx.Config.GetEnumeratorOfGroups">
            <summary>
            Returns an enumerator of all groups.
            </summary>
            <seealso cref="M:wx.Config.GetFirstGroup(System.String@,System.Int32@)"/>
            <seealso cref="M:wx.Config.GetNextGroup(System.String@,System.Int32@)"/>
        </member>
        <member name="M:wx.Config.GetEnumerableGroups">
            <summary>
            Returns an enumerable collection of all contained groups.
            You may use this in <c>foreach</c> loops.
            Please keep care on the <c>Path</c>. The path shall always be the same
            on moving to the next entry.
            </summary>
        </member>
        <member name="M:wx.Config.GetFirstEntry(System.String@,System.Int32@)">
            <summary>
            Gets the first entry in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first entry.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:wx.Config.GetEnumeratorOfEntries"/>
        </member>
        <member name="M:wx.Config.GetNextEntry(System.String@,System.Int32@)">
            <summary>
            Gets the next entry in the configuration.
            </summary>
            <param name="str">Will be assigned with the name of the first entry.</param>
            <param name="lIndex">This is an identifier for the enumeration.</param>
            <returns>True on success.</returns>
            <seealso cref="M:wx.Config.GetEnumeratorOfEntries"/>
        </member>
        <member name="M:wx.Config.GetEnumeratorOfEntries">
            <summary>
            Returns an enumerator of all entries.
            </summary>
            <seealso cref="M:wx.Config.GetFirstEntry(System.String@,System.Int32@)"/>
            <seealso cref="M:wx.Config.GetNextEntry(System.String@,System.Int32@)"/>
        </member>
        <member name="M:wx.Config.GetEnumerableEntries">
            <summary>
            Returns an enumerable collection of all contained groups.
            You may use this in <c>foreach</c> loops.
            Please keep care on the <c>Path</c>. The path shall always be the same
            on moving to the next entry.
            </summary>
        </member>
        <member name="M:wx.Config.Exists(System.String)">
            <summary>
            returns true if either a group or an entry with a given name exists
            </summary>
            <param name="strName">name of an entry or a group</param>
        </member>
        <member name="M:wx.Config.ReadString(System.String,System.String@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="str">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadString(System.String,System.String@,System.String)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="str">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadInt(System.String,System.Int32@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="pl">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadInt(System.String,System.Int32@,System.Int32)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="pl">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadDouble(System.String,System.Double@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadDouble(System.String,System.Double@,System.Double)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadBool(System.String,System.Boolean@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadBool(System.String,System.Boolean@,System.Boolean)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadFont(System.String,wx.Font@)">
            <summary>
            Read a value from the key, returning true if the value was read. If the key was not found, the value will not be changed.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadFont(System.String,wx.Font@,wx.Font)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.ReadColour(System.String,wx.Colour@,wx.Colour)">
            <summary>
            Read a value from the key, returning true if the value was read. Assigns a default value if the key was not found.
            </summary>
            <param name="key">the key</param>
            <param name="val">the value to be read</param>
            <param name="defVal">this will be assigned if the key has not been found</param>
            <returns>true if value has been found and set</returns>
        </member>
        <member name="M:wx.Config.Write(System.String,System.Xml.Serialization.IXmlSerializable)">
            <summary>This will write a serializable object identified by <c>key</c>.
            </summary>
        </member>
        <member name="M:wx.Config.Flush">
            <summary>
            permanently writes all changes (otherwise, they're only written from object's destructor)
            </summary>
        </member>
        <member name="M:wx.Config.Flush(System.Boolean)">
            <summary>
            permanently writes all changes (otherwise, they're only written from object's destructor)
            </summary>
        </member>
        <member name="M:wx.Config.DeleteEntry(System.String)">
            <summary>
            Deletes the specified entry and the group it
            belongs to if it was the last key in it.
            </summary>
            <param name="key">The key of the entry to delete</param>
        </member>
        <member name="M:wx.Config.DeleteEntry(System.String,System.Boolean)">
            <summary>
            Deletes the specified entry and the group it
            belongs to if it was the last key in it and the second parameter is true.
            </summary>
            <param name="key">The key of the entry to delete</param>
            <param name="bDeleteGroupIfEmpty">If true the whole group will be deleted if this deleted the last entry</param>
        </member>
        <member name="M:wx.Config.DeleteGroup(System.String)">
            <summary>
            Delete the group (with all subgroups). If the current path is under the group being deleted it is changed to
            its deepest still existing component. E.g. if the current path is /A/B/C/D and the group C is deleted the
            path becomes /A/B.
            </summary>
            <param name="key">Designator of the group to be deleted</param>
        </member>
        <member name="M:wx.Config.DeleteAll">
            <summary>
            Delete the whole underlying object (disk file, registry key, ...). Primarly for use by uninstallation routine.
            </summary>
        </member>
        <member name="M:wx.Config.WithEnvVarsExpanded(System.String)">
            <summary>This is the equivalent to <c>wxConfig</c>::EnvVarsExpanded().
             This has to be renamed since <c>EnvVarsExpanded</c> is required as name of the property
             for automatic expansion.
            </summary>
        </member>
        <member name="P:wx.Config.ExpandEnvVars">
            <summary>This read/write property defines automatic expansion of environment variables.
             Use WithEnvVarsExpanded() to read a string with expanded environment variables.
            </summary>
        </member>
        <member name="P:wx.Config.RecordDefaults">
            <summary>
            If true, all default values provided with Read() actions will be recorded.
            </summary>
        </member>
        <member name="P:wx.Config.AppName">
            <summary>
            The name of the application.
            </summary>
        </member>
        <member name="P:wx.Config.VendorName">
            <summary>
            The name of the vendor.
            </summary>
        </member>
        <member name="P:wx.Config.Style">
            <summary>
            The style that has been used. You may also change this.
            </summary>
        </member>
        <member name="P:wx.Config.Path">
            <summary>
            Get or set the current path in the configuration:
            On reading the path: Path information is always absolute on reading.
            On setting the path:
            if the first character is '/', it is the absolute path, otherwise it is a relative path. '..' is supported. If strPath doesn't exist it is created.
            </summary>
        </member>
        <member name="T:wx.Config.EntryType">
            <summary>An enumeration representing the data type of an atomic field.
            </summary>
        </member>
        <member name="M:wx.ColourDialog.ShowModal">
            Modal display of the dialog. Returns whether input has been confirmed or cancelled.
        </member>
        <member name="T:wx.CalendarPeriod">
            <summary>An enumeration representing periods within a calendar.
            Refer to Calendar.DaysInPeriod().</summary>
        </member>
        <member name="T:wx.Calendar">
            <summary>Assigns name and attributes to special days.
            These will be displayed in calendar controls if set to the appropriate property.
            
            Add styles to the calendar and asign them to days.
            
            You may either extend this by subclassing or providing event handlers.</summary>
        </member>
        <member name="M:wx.Calendar.DaysInPeriod(System.DateTime,wx.CalendarPeriod,System.DateTime,System.DateTime)">
            <summary>This returns a list of days with a distance referring to <c>repreat</c> to day \ reference within a period of days.
            Example 1: Reference 1st of July 2008 and <c>repeat</c> <c>CalendarPeriod.Monthly</c> within the period starting with the 2nd
            May 2008 ranging to the 2nd Aug. 2008 will return the following <c>DateTime</c> instances: 1st of June, 1st of July,
            1st of August. 
            
            Example 2: The parameters from example 1 but with reference 1st of Jan. 2008 will result into the same result.
            
            Example 3: The parameters from example 1 but with period 2nd of July to 31th of July will result into an empty list.</summary>
        </member>
        <member name="M:wx.Calendar.#ctor">
            <summary>Creates an empty calendar info.
            You may assign this to a calendar control.</summary>
        </member>
        <member name="M:wx.Calendar.LinkToControl(wx.CalendarCtrl)">
            <summary>Adds new listener on selecitons to the argument and returns the used event listener.</summary>
        </member>
        <member name="M:wx.Calendar.AddHoliday(System.DateTime,System.String)">
            <summary>Defines <c>day</c> to be a holiday of the provided <c>name</c>.
            </summary>
        </member>
        <member name="M:wx.Calendar.AddHoliday(System.DateTime)">
            <summary>Defines <c>day</c> to be a holiday.</summary>
        </member>
        <member name="M:wx.Calendar.AddHoliday(System.DateTime,wx.CalendarPeriod)">
            <summary>Defines <c>day</c> to be a holiday that will automatically be repeated periodically.</summary>
        </member>
        <member name="M:wx.Calendar.AddHoliday(System.DateTime,wx.CalendarPeriod,System.String)">
            <summary>Defines <c>day</c> to be a holiday of the provided name that will automatically be repeated periodically.</summary>
        </member>
        <member name="E:wx.Calendar.OnRequestFormat">
            <summary>Called on requesting the format of a particular day.</summary>
        </member>
        <member name="T:wx.Calendar.RequestFormatEventArgs">
            <summary>Argument of a <c>OnRequestFormat</c> event.
            This provides the <c>Day</c> whose presentation format is requested.
            Implementors may set <c>Name</c> and/or <c>Attr</c> that shall be used for presentation.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.CalendarCtrl" ignoriert -->
        <member name="M:wx.CalendarCtrl.GetAttr(System.Int32)">
            <summary>Gets the attributes of the provided day in month (1..31).</summary>
        </member>
        <member name="M:wx.CalendarCtrl.SetAttr(System.Int32,wx.CalendarDateAttr)">
            <summary>Sets the attributes of the provided day in month (1..31).</summary>
        </member>
        <member name="M:wx.CalendarCtrl.SetHoliday(System.Int32)">
            <summary>Declares the designated day in month (1..31) to be a holiday.</summary>
        </member>
        <member name="M:wx.CalendarCtrl.ResetAttr(System.Int32)">
            <summary>Resets the attributes of the designated day in month (1..31) to be a holiday.</summary>
        </member>
        <member name="P:wx.CalendarCtrl.SpecialDays">
            <summary>Returns the current definition of special days and holidays if present.
            Assigning a new calendar to this control will immediately highlight the specified special days
            like holidays etc. So, fill the Calendar first and then assign it to the control.</summary>
        </member>
        <member name="E:wx.CalendarCtrl.OnChangedDate">
            <summary>This will be called on setting <c>Date</c>.
            </summary>
        </member>
        <member name="P:wx.CalendarCtrl.Date">
            <summary>Get or set the currently selected date.
            You may use <c>OnSetDate</c> to be informed of changing this value,</summary>
        </member>
        <member name="T:wx.CalendarDateAttr">
            <summary>Defines the manner that particular days will be presented in CalendarCtrl.</summary>
        </member>
        <member name="T:wx.CalendarEvent">
            <summary>The wx.CalendarEvent class is used together with wx.CalendarCtrl.
            \image html calendar.png "The improved calender control."</summary>
        </member>
        <member name="T:wx.SplitterWindow">
             <summary>
             This class manages up to two subwindows.
             The current view can be split into two programmatically (perhaps from a menu command), and unsplit either 
             programmatically or via the wx.SplitterWindow user interface.
             </summary>
             <remarks>
             The following screenshot shows the appearance of a splitter window with a horizontal split.
            
             \image html splitter.png
             
             The style wx.WindowStyles.SP_3D has been used to show a 3D border and 3D sash.
             </remarks>
        </member>
        <member name="M:wx.SplitterWindow.SplitHorizontally(wx.Window,wx.Window)">
            <summary>
            Initializes the top and bottom panes of the splitter window.
            The child windows are shown if they are currently hidden.
            
            Initially, the sash divides the control into two halfs.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:wx.SplitterWindow.SplitHorizontally(wx.Window,wx.Window,System.Int32)">
            <summary>
            Initializes the top and bottom panes of the splitter window.
            The child windows are shown if they are currently hidden.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <param name="sashPos">The initial position of the sash. If this value is positive,
            it specifies the size of the top pane. If it is negative, it is absolute value gives the
            size of the bottom pane. Finally, specify 0 (default) to choose the default position
            (half of the total window width). </param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:wx.SplitterWindow.SplitVertically(wx.Window,wx.Window)">
            <summary>
            Initializes the left and right panes of the splitter window.
            The child windows are shown if they are currently hidden.
            
            Sash divides the pane initially in the half.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:wx.SplitterWindow.SplitVertically(wx.Window,wx.Window,System.Int32)">
            <summary>
            Initializes the left and right panes of the splitter window.
            The child windows are shown if they are currently hidden.
            </summary>
            <remarks>This should be called if you wish to initially view two panes.
            It can also be called at any subsequent time,
            but the application should check that the window is not currently split using IsSplit.
            </remarks>
            <param name="wnd1">The left pane</param>
            <param name="wnd2">The right pane</param>
            <param name="sashPos">The initial position of the sash. If this value is positive,
            it specifies the size of the left pane. If it is negative, it is absolute value gives the
            size of the right pane. Finally, specify 0 (default) to choose the default position
            (half of the total window width). </param>
            <returns>true if successful, false otherwise (the window was already split).</returns>
        </member>
        <member name="M:wx.SplitterWindow.Unsplit">
            <summary>
            Unsplits the window.
            This call will not actually delete the pane being removed; it calls OnUnsplit() which can be overridden
            for the desired behaviour. By default, the pane being removed is hidden.
            
            This will remove the right or bottom pane.
            </summary>
            <returns>true if successful, false otherwise (the window was not split).</returns>
        </member>
        <member name="M:wx.SplitterWindow.Unsplit(wx.Window)">
            <summary>
            Unsplits the window.
            This call will not actually delete the pane being removed; it calls OnUnsplit() which can be overridden
            for the desired behaviour. By default, the pane being removed is hidden.
            </summary>
            <param name="toRemove">The pane to remove, or <c>null</c> to remove the right or bottom pane.</param>
            <returns>true if successful, false otherwise (the window was not split).</returns>
        </member>
        <member name="P:wx.SplitterWindow.IsSplit">
            <summary>
            True iff the control is currently split.
            this shall be tested before using SplitHorizontally() or SplitVertically().
            </summary>
        </member>
        <member name="P:wx.Pen.ThePenList">
            <summary>This is the synonym to wx.PenList.ThePenList.</summary>
        </member>
        <member name="T:wx.Pen.Styles">
            <summary>Styles for pens.</summary>
        </member>
        <member name="T:wx.MouseEvent">
            <summary>
            
            </summary>
        </member>
        <member name="M:wx.MouseEvent.ButtonDown">
            <summary>If the argument is omitted, this returns true if the event was a mouse button down event.
            Otherwise the argument specifies which button-down event was generated (see Button for the possible values).</summary>
        </member>
        <member name="M:wx.MouseEvent.ButtonDown(wx.MouseButton)">
            <summary>Returns true if the event was a mouse button down event.
            The argument specifies which button-down event was generated (see Button for the possible values).</summary>
        </member>
        <member name="M:wx.MouseEvent.LogicalPosition(wx.DC)">
            <summary>Returns the logical mouse position in pixels
            (i.e. translated according to the translation set for the DC, which usually indicates that the
            window has been scrolled).</summary>
        </member>
        <member name="P:wx.MouseEvent.IsButton">
            <summary>Returns true if the event was a mouse button event
            (not necessarily a button down event - that may be tested using ButtonDown).</summary>
        </member>
        <member name="P:wx.MouseEvent.Position">
            <summary>Returns the physical mouse position in pixels.
            Note that if the mouse event has been artificially generated from a special keyboard combination (e.g.
            under Windows when the "menu'' key is pressed), the returned position is <c>wxDefaultPosition</c>.</summary>
        </member>
        <member name="P:wx.MouseEvent.X">
            <summary>Returns X coordinate of the physical mouse event position.</summary>
        </member>
        <member name="P:wx.MouseEvent.Y">
            <summary>Returns Y coordinate of the physical mouse event position.</summary>
        </member>
        <member name="T:wx.GenericForm.GenericFormPanel">
            <summary>This panel will present data</summary>
        </member>
        <member name="F:wx.GenericForm.GenericFormPanel._specialDays">
            <summary>Data of days that have been declared as holidays or special days.</summary>
        </member>
        <member name="M:wx.GenericForm.GenericFormPanel.#ctor(System.Object,wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles)">
            <summary>This will create a form presenting the data in <c>dataModel</c>.
             This will show all properties that exhibit a FormStylePropertyAttribute or a FormJoinGroupAttribute.
             Properties providing a modifier will be presented in active controls. Properties without a modifer will be
             presented in disabled controls. You may specify a read-only presentation with WindowStyles.GENERICFORM_READONLY.
            </summary>
        </member>
        <member name="M:wx.GenericForm.GenericFormPanel.SetHoliday(System.DateTime)">
            <summary>The designated date is a holiday.</summary>
        </member>
        <member name="M:wx.GenericForm.GenericFormPanel.SetAttributesOfDay(System.DateTime,wx.CalendarDateAttr)">
            <summary>Defines the manner in which the designated day will be presented in a calendar ctrl.</summary>
        </member>
        <member name="M:wx.GenericForm.GenericFormPanel.resetAttributesOfDay(System.DateTime)">
            <summary>Resets the properties associated with the designated day.</summary>
        </member>
        <member name="T:wx.ComboPopup">
            <summary>This interface declares those methods which are required by popups of a <c>ComboCtrl</c>.
            Please note, that in contrast to the original  wxWidgets class hierarchy, this is  not intended as
            a base class that shall be inherited together with <c>wx.Control</c>. In contrast, the control shall be
            a member of this. Refer to wx.DatePicker for an example.
            </summary>
        </member>
        <member name="F:wx.ComboPopup._control">
            <summary>Load this with the popup control that will be shown on popup.
            This may either be set by a CTor or by an implementation of Create().</summary>
        </member>
        <member name="M:wx.ComboPopup.#ctor(wx.Window)">
            <summary>CTor already defining a control that will be poped up.
            \param control is the control that will be shown on popup. Please note, that this is required to implement 2 step contruction
                   since that parent will be delivered calling Create(), not earlier.</summary>
        </member>
        <member name="M:wx.ComboPopup.#ctor">
            <summary>CTor creating a sceleton without defining an instance for the popup window.
            If you use this, use Create() to create the <c>PopupControl</c>.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.Init">
            <summary>This is called immediately after construction finishes. m_combo member
            variable has been initialized before the call.</summary>
        </member>
        <member name="M:wx.ComboPopup.Create(wx.Window)">
            <summary>Create the popup child control.
            Implementors shall set <c>_control</c>.
            Return true for success.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.OnPopup">
            <summary>Called immediately after the popup is shown.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.OnDismiss">
            <summary>Called when popup is dismissed.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.SetStringValue(System.String)">
            <summary>Called just prior to displaying popup.
            Default implementation does nothing.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.GetStringValue">
            <summary>Gets displayed string representation of the value.</summary>
        </member>
        <member name="M:wx.ComboPopup.PaintComboControl(wx.DC,System.Drawing.Rectangle)">
            <summary>This is called to custom paint in the combo control itself (ie. not the popup).
            Default implementation draws value as string.</summary>
        </member>
        <member name="M:wx.ComboPopup.OnComboKeyEvent(wx.KeyEvent)">
            <summary>Receives key events from the parent wxComboCtrl.
            Events not handled should be skipped, as usual.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.OnComboDoubleClick">
            <summary>Implement if you need to support special action when user double-clicks on the parent wx.ComboCtrl.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.GetAdjustedSize(System.Int32,System.Int32,System.Int32)">
            <summary>Return final size of popup.
            Called on every popup, just prior to <c>OnShow</c>.
            </summary>
            <param name="minWidth"> is the preferred minimum width for window</param>
            <param name="prefHeight">is the preferred height. Only applies if larger than 0,</param>
            <param name="maxHeight"> is the max. height for window, as limited by screen size and should only be rounded down, if necessary.
            </param>
        </member>
        <member name="M:wx.ComboPopup.LazyCreate">
            <summary>Return true if you want delay call to Create until the popup is shown for the first time.
            It is more efficient, but note that it is often
            more convenient to have the control created immediately.
            Default returns false.
            </summary>
        </member>
        <member name="M:wx.ComboPopup.Dismiss">
            <summary>Hides the popup.</summary>
        </member>
        <member name="M:wx.ComboPopup.IsCreated">
            <summary>Returns true if Create() has been called.</summary>
        </member>
        <member name="P:wx.ComboPopup.PopupControl">
            <summary>The control that will be shown on popup.
            </summary>
        </member>
        <member name="P:wx.ComboPopup.ComboControl">
            <summary>This is the combo box that will popup this.
            </summary>
        </member>
        <member name="P:wx.ComboPopup.StringValue">
            <summary>Synonym for <c>GetStringValue() </c> and <c>SetStringValue() </c>. </summary>
        </member>
        <member name="T:wx.ComboCtrl">
            <summary>The generic combo control available since wxWidgets 2.8.
            A combo control is a generic combobox that allows totally custom popup.
            In addition it has other customization features. For instance, position and size of the dropdown button can be changed.
            
            <c>ComboCtrl</c> needs to be told somehow which control to use and this is done by <c>SetPopupControl() </c>.
            However, we need something more than just a <c>Control</c> in this method as, for example, we need to call
            <c> SetStringValue("initial text value") </c> and <c>Control</c> doesn't have such a method.
            So we also need a <c>ComboPopup</c>
            which is an interface that must be implemented by a control to be usable as a popup.
            
            Refer to wx.DatePicker for an example.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.#ctor">
            <summary>2-step construction: Step one before Create().</summary>
        </member>
        <member name="M:wx.ComboCtrl.Create(wx.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String)">
            <summary>2-step construction: Step two after calling default CTor.
            Define the properties of this window.</summary>
        </member>
        <member name="M:wx.ComboCtrl.Create(wx.Window,System.Int32,wx.wxString,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,wx.wxString)">
            <summary>2-step construction: Step two after calling default CTor.
            Define the properties of this window.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.OnButtonClick">
            <summary>Override for totally custom combo action.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.ShowPopup">
            <summary>Shows the popup.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.HidePopup">
            <summary>Hides the popup.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.Copy">
            <summary>Calls wx.TextCtrl.Copy() of the associaed text control.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.Cut">
            <summary>Calls wx.TextCtrl.Cut() of the associaed text control.
            </summary>
        </member>
        <member name="M:wx.ComboCtrl.Paste">
            <summary>Calls wx.TextCtrl.Cut() of the associaed text control.
            </summary>
        </member>
        <member name="P:wx.ComboCtrl.IsPopupShown">
            <summary>This is <c>true</c> iff the popup is shown.
            Read only.</summary>
        </member>
        <member name="P:wx.ComboCtrl.PopupControl">
            <summary>Get or set the popup control.</summary>
        </member>
        <member name="P:wx.ComboCtrl.PopupWindow">
            <summary>Reads the window displaying the popup control.</summary>
        </member>
        <member name="P:wx.ComboCtrl.TextControl">
            <summary>Reads the text control that is used to display the combo box value.</summary>
        </member>
        <member name="P:wx.ComboCtrl.Button">
            <summary>Reads the button that opend the popup control.
            Please note, that this is not necessarily a Button or a BitmapButton.
            </summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Enum)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry.
            </summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Enum,System.String,System.String)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry. The provided acceleration code will be appended
            to the name separated by a TAB character. This will enable the menu acceleration function
            of wxWidgets.
            </summary>
            <param name="entry">The command and the label of the new menu item</param>
            <param name="accelCode"> An acceleration code like "F1" or "Alt-X" designating a key
            that can be pressed to raise the command that is also triggered by this menu item.</param>
            <param name="help">A description of the command that will e.g. be displayed in status lines.</param>
        </member>
        <member name="M:wx.MenuBase.Append(System.Object,System.String)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c>
            as command identifier.
            </summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,System.String)">
            <summary>Adds a menu item with an integer value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Enum,System.String)">
            <summary>Adds a menu item of an enumeration value.
            The cast of the enumeration value to <c>int</c> will be the identifier of the command.
            The translation of the enumeration value (refer to wx.Object._() and wx.Globalization)
            will be the title of the menu entry.
            </summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Object,System.String,System.String)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c> as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,System.String,System.String)">
            <summary>Adds a menu item with an integer value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Object,System.String,System.String,wx.ItemKind)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c> as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,System.String,System.String,wx.ItemKind)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,wx.wxString,wx.wxString,wx.ItemKind)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Object,System.String,wx.Menu)">
            <summary>Adds a menu item with an enumeration value or another object that can be casted to <c>int</c>  as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,System.String,wx.Menu)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,System.String,wx.Menu,System.String)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.Append(System.Int32,wx.wxString,wx.Menu,wx.wxString)">
            <summary>Adds a menu item with an enumeration value as command identifier.</summary>
        </member>
        <member name="M:wx.MenuBase.AppendCheckItem(System.Enum)">
            <summary>
            Creates a new check item in the menu. The enumeration value will be used to derive
            the ID for events and to get a text label in the menu via translation.
            </summary>
            <param name="id">Events caused by this item will refer to ID <c>Convert.ToInt32(id)</c>.
            The check box will be labelled with <c>_(id)</c>.</param>
            <returns></returns>
        </member>
        <member name="M:wx.MenuBase.AppendCheckItem(System.Enum,System.String)">
            <summary>
            Creates a new check item in the menu. The enumeration value will be used to derive
            the ID for events and to get a text label in the menu via translation.
            </summary>
            <param name="id">Events caused by this item will refer to ID <c>Convert.ToInt32(id)</c>.
            The check box will be labelled with <c>_(id)</c>.</param>
            <param name="helpText">Will appear in the status line if the mouse os over this check item.</param>
            <returns></returns>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEditFieldValueChangingEvent">
            <summary>This event will be raised whenever the value of a field is modified.
            Handlers may veto or change the value.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditFieldValueChangingEvent.Veto">
            <summary>Veto.
            The communicated change will be rolled back. If an alternative value has been proposed, this proposal will be removed and discarded.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditFieldValueChangingEvent.Change(System.Object)">
            <summary>Change the proposed value.
            A previous veto will be discarded.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditFieldValueChangingEvent.Vetoed">
            <summary>Returns whether a previous handler vetoed the change.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditFieldValueChangingEvent.Changed">
            <summary>Returns true iff event handlers proposed an alternative value to be set.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditFieldValueChangingEvent.Value">
            <summary>Use this to read the value that will be set with the field.
            Reads the <c>ChangedNewValue</c> if <c>Changed</c>, the <c>OriginalValue</c> if <c>Vetoed</c>, and the <c>OriginalNewValue</c> otherwise.</summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEditFieldValueChangingHandler">
            <summary>Handler for the MaskedEditFieldValueChangingEvent.</summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEditFieldValueChangedEvent">
            <summary>Evetns of this class will be fired after the value of a field changed.</summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEditFieldValueChangedHandler">
            <summary>Handler for the MaskedEditFieldValueChangedEvent.
            </summary>
        </member>
        <member name="T:wx.MaskedEdit.EditField">
            <summary>Base class of all field declarations.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField._posStart">
            <summary>Textposition in the masked text.
            This will be maintained by the control.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField._posEnd">
            <summary>Textposition in the masked text.
            This will be maintained by the control.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.MinWidth">
            <summary>Minimal width of a field.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.MaxWidth">
            <summary>Maximal width of a field.
            All input exceeding this number of characters will discarded.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.EmptyChar">
            <summary>Leading characters if this kind will be ignored.</summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.TextAttributes">
            <summary>The text attributes to be used for this field if not <c>null</c>.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.Name">
            <summary>An optional name for this field.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.EditField.DisplayName">
            <summary>This will e.g. appear in the tooltip text if not empty.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.EditField.SetTextValue(System.String)">
            <summary>This will change <c>TextValue</c>.
            Setting this property will start interpretation of the string.
            The result is true on success, i.e. <c>TextValue</c> has been changed.
            This does not necessarily mean, that <c>TextValue</c> equals <c>newTextValue</c>
            because <c>TextValue</c> may contain leading <c>EmptyChar</c> etc.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.EditField.DeleteChar">
            <summary>Delete a character from the text input of the field and return <c>true</c> on success.</summary>
        </member>
        <member name="M:wx.MaskedEdit.EditField.AddChar(System.Char)">
            <summary>Adds a new character to the field assuming explicit input.</summary>
        </member>
        <member name="M:wx.MaskedEdit.EditField.RaiseOnChangedEvent(System.Object)">
            <summary>Helper for calling events after changing a value.
            This will test whether we have listeners to the event and create an event and fire it.
            The event as modified by the listeners will be returned. The result may be <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.PredefinedChoices">
            <summary>If this differs from <c>null</c>, than this property defines a number of predefined choices that may be for instance used in popup menus.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.TextValue">
            <summary>Returns or the text appearance of the current value.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.Object">
            <summary>This returns the data object of the field.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.EmphasizeLength">
            <summary>Result indicates, that the  n characters beginning with <c>EmphasizeStart</c> shall be emphasized.
            This is 0 by default => no emphasize.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.EmphasizeStart">
            <summary>If <c>EmphasizeLength</c> is larger than 0, then this is the first emphasized character.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditField.IsFull">
            <summary>Indicates with <c>true</c> that adding more characters will truncate elder input.
            </summary>
        </member>
        <member name="T:wx.MaskedEdit.EditIntField">
            <summary>Defines a text field containing an integer number.</summary>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.New(System.String)">
            <summary>Creates an instance of a particular name.
            This name may be used to identify the field in event handlers.</summary>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetIn(System.Int32,System.Int32)">
            <summary>Setting <c>MinValue</c> and <c>MaxValue</c>.</summary>
            <returns> this instance </returns>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetMinWidth(System.Int32)">
            <summary>Sets the <c>MinWidth</c>.
            </summary>
            <returns>this instance</returns>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetMaxWidth(System.Int32)">
            <summary>Sets the <c>MaxWidth</c>.
            </summary>
            <returns>this instance</returns>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetWidth(System.Int32)">
            <summary>Sets minimal and maximal width.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetEmptyChar(System.Char)">
            <summary>Sets the <c>EmptyChar</c> to the provided value and return <c>this</c>.
            </summary>
            <remarks>
            Samples:
            \li <c>StringField.New().SetEmptyChar(</c>'_')
            \li <c>StringField.New().SetEmptyChar(</c>'0')
            
            Use decimals es empty character if you want to prevent this field from returning result value <c>null</c>.
            </remarks>
        </member>
        <member name="M:wx.MaskedEdit.EditIntField.SetTextAttributes(wx.TextAttr)">
            <summary>Defines text and background colour.
            Provide <c>null</c> if you do not want to specify text attributes explicitely.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.EditIntField.Value">
            <summary>Return the value of this field.
            Setting the value will raise MaskedEditFieldValueChangingEvent and MaskedEditFieldValueChangedEvent(s).</summary>
        </member>
        <member name="T:wx.MaskedEdit.StringEditField">
            <summary>This is a field containing a string.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.StringEditField._objectConversion">
            <summary>If this is set, this.Object will be converted from the selected string.</summary>
        </member>
        <member name="F:wx.MaskedEdit.StringEditField.AllowedChars">
            <summary>Set this to a string of characters to constrain the used characters.
            If not <c>null</c> only characters mentioned in this string will be allowed in <c>value</c>.
            </summary>
        </member>
        <member name="F:wx.MaskedEdit.StringEditField.Choices">
            <summary>If this is non-null, then this is a number of choices the user may select.
            Insert an empty string (not <c>null)</c> to allow additionally free input.</summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.New">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.New(System.String)">
            <summary>Creates an instance of a particular name.
            This name may be used to identify the field in event handlers.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetWidth(10)</c> is equivalent to StringField.New().SetMinWidth(10).SetMaxWidth(10).
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetMinWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetMinWidth(10).SetMaxWidth(10)</c>
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetMaxWidth(System.Int32)">
            <summary>Sets the width to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetMinWidth(10).SetMaxWidth(10)</c>
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetIn(System.String)">
            <summary>Sets the <c>AllowedChars</c> to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().AllowedChars(</c>"abcdefghijklmnopqrstuvwxyz")
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetEmptyChar(System.Char)">
            <summary>Sets the <c>EmptyChar</c> to the provided value and return <c>this</c>.
            Sample: <c>StringField.New().SetEmptyChar(</c>'_')
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetChoices(System.String[])">
            <summary>Sets availabel choices.
            Add an empty string to allow additionally free text input.
            Sample: <c>StringField.New().SetChoices(</c>"", "one choice", "another choice")
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetChoices(System.Type)">
            <summary>This will set the values of the provided enumeration type as choices.
            This will enumerate the values of the provided enumeration, translate them, and
            include them into the available choices.
            Note: If this has been called, this.Object will return instances of the <c>enumType</c>.
            Note, that this will raise exceptions, is <c>enumType</c> is not an enumeration type.
            </summary>
        </member>
        <member name="M:wx.MaskedEdit.StringEditField.SetTextAttributes(wx.TextAttr)">
            <summary>Defines text and background colour.
            Provide <c>null</c> if you do not want to specify e.g. the background explicitely.</summary>
        </member>
        <member name="P:wx.MaskedEdit.StringEditField.Value">
            <summary>Return the value of this field.
            Setting the value will raise MaskedEditFieldValueChangingEvent and MaskedEditFieldValueChangedEvent(s).
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.StringEditField.PredefinedChoices">
            <summary>This returns <c>Choices</c>.</summary>
        </member>
        <member name="P:wx.MaskedEdit.StringEditField.Object">
            <summary>This is the <c>Value</c> of this field, a string.
            However, if SetChoices() has been called with an enumeration type, this will
            return instances of this type instead.</summary>
        </member>
        <member name="P:wx.MaskedEdit.StringEditField.TextValue">
            <summary><c>Value</c> but expanded to <c>MinWidth</c> und trancated by <c>MaxWidth</c>.</summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEditService">
            <summary>Internal class providing service level for masked text edit.</summary>
        </member>
        <member name="F:wx.MaskedEdit.MaskedEditService._charsAddedToSelectedField">
            <summary>This will be used to count the number of characters that have been added to the current field.
            This will be compared to the maximal width in order to determine whether to switch to the next field.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.StepToFirstField">
            <summary>This is the action triggered by the "Home" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.StepToLastField">
            <summary>This is the action triggered by the "End" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.StepRight">
            <summary>This is the action triggered by the "Cursor right" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.
            Prerequisite: We have a current selection.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.StepLeft">
            <summary>This is the action triggered by the "Cursor left" key: Step to field 0.
            Please note, that this action will use the order of the fields w.r.t. their index.
            Prerequisite: We have a current selection.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.RefreshValue">
            <summary>Updates the text content from the values of the fields-</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.OnChar(System.Object,wx.Event)">
            <summary>This will be called on adding a new character input to the currently selected field.
            This is made public to ease use of masked edits in tables.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.ShowError(wx.MaskedEdit.EditField,System.String)">
            <summary>This will be called by fields on rejecting input.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.ExpandText(System.String,wx.MaskedEdit.EditField[])">
            <summary>Return expanded copy of <c>textMask</c> referring to info from <c>fields</c> and update of positions in the <c>fields</c>.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEditService.SelectField(System.Int32)">
            <summary>Select field <c>i</c> provided that ExpandText() has been done.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditService.Count">
            <summary>Number of fields.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditService.Item(System.Int32)">
            <summary>Gets the field of index <c>i</c>.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEditService.TextMask">
            <summary>The text mask defining the format of the input.</summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedEdit">
            <summary>This is a masked edit control.
            Define a number of instances of EditField and a string mask.
            </summary>
        </member>
        <member name="T:wx.TextCtrl">
             <summary>Control to display and edit text.</summary>
             <remarks>
             <list type="table">
             <item><term>wxTE_PROCESS_ENTER</term><description>The control will generate the event wxEVT_COMMAND_TEXT_ENTER (otherwise pressing Enter key is either processed internally by the control or used for navigation between dialog controls).</description></item>
             <item><term>wxTE_PROCESS_TAB</term><description>  The control will receive wxEVT_CHAR events for TAB pressed - normally, TAB is used for passing to the next control in a dialog instead. For the control created with this style, you can still use Ctrl-Enter to pass to the next control from the keyboard.  </description></item>
             <item><term>wxTE_MULTILINE</term><description>  The text control allows multiple lines.  </description></item>
             <item><term>wxTE_PASSWORD</term><description>  The text will be echoed as asterisks.  </description></item>
             <item><term>wxTE_READONLY</term><description>  The text will not be user-editable.  </description></item>
             <item><term>wxTE_RICH</term><description>  Use rich text control under Win32, this allows to have more than 64KB of text in the control even under Win9x. This style is ignored under other platforms.  </description></item>
             <item><term>wxTE_RICH2</term><description>  Use rich text control version 2.0 or 3.0 under Win32, this style is ignored under other platforms  </description></item>
             <item><term>wxTE_AUTO_URL</term><description>  Highlight the URLs and generate the wxTextUrlEvents when mouse events occur over them. This style is only supported for wxTE_RICH Win32 and multi-line wxGTK2 text controls.  </description></item>
             <item><term>wxTE_NOHIDESEL</term><description>  By default, the Windows text control doesn't show the selection when it doesn't have focus - use this style to force it to always show it. It doesn't do anything under other platforms.  </description></item>
             <item><term>wxHSCROLL</term><description>  A horizontal scrollbar will be created and used, so that text won't be wrapped. No effect under wxGTK1.  </description></item>
             <item><term>wxTE_LEFT</term><description>  The text in the control will be left-justified (default).  </description></item>
             <item><term>wxTE_CENTRE</term><description>  The text in the control will be centered (currently wxMSW and wxGTK2 only).  </description></item>
             <item><term>wxTE_RIGHT</term><description>  The text in the control will be right-justified (currently wxMSW and wxGTK2 only).  </description></item>
             <item><term>wxTE_DONTWRAP</term><description>  Same as wxHSCROLL style: don't wrap at all, show horizontal scrollbar instead.  </description></item>
             <item><term>wxTE_CHARWRAP</term><description>  Wrap the lines too long to be shown entirely at any position (wxUniv and wxGTK2 only).  </description></item>
             <item><term>wxTE_WORDWRAP </term><description> Wrap the lines too long to be shown entirely at word boundaries (wxUniv and wxGTK2 only).  </description></item>
             <item><term>wxTE_BESTWRAP </term><description> Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default).  </description></item>
             <item><term>wxTE_CAPITALIZE </term><description> On PocketPC and Smartphone, causes the first letter to be capitalized.  </description></item>
             </list>
             
             Note that alignment styles (wxTE_LEFT, wxTE_CENTRE and wxTE_RIGHT) can be changed dynamically after control creation
             on wxMSW and wxGTK. wxTE_READONLY, wxTE_PASSWORD and wrapping styles can be dynamically changed under wxGTK but
             not wxMSW. The other styles can be only set during control creation.
            
             wx.TextCtrl text format
            
             The multiline text controls always store the text as a sequence of lines separated by \n characters, i.e. in the
             Unix text format even on non-Unix platforms. This allows the user code to ignore the differences between the 
             platforms but at a price: the indices in the control such as those returned by GetInsertionPoint or GetSelection
             can not be used as indices into the string returned by GetValue as they're going to be slightly off for platforms
             using "\r\n" as separator (as Windows does), for example.
            
             Instead, if you need to obtain a substring between the 2 indices obtained from the control with the help of the
             functions mentioned above, you should use GetRange. And the indices themselves can only be passed to other methods,
             for example SetInsertionPoint or SetSelection.
            
             To summarize: never use the indices returned by (multiline) wxTextCtrl as indices into the string it contains, but
             only as arguments to be passed back to the other wx.TextCtrl methods.
            
             wx.TextCtrl styles
            
             Multi-line text controls support the styles, i.e. provide a possibility to set colours and font for individual
             characters in it (note that under Windows wxTE_RICH style is required for style support). To use the styles you
             can either call SetDefaultStyle before inserting the text or call SetStyle later to change the style of the text
             already in the control (the first solution is much more efficient).
            
             In either case, if the style doesn't specify some of the attributes (for example you only want to set the text
             colour but without changing the font nor the text background), the values of the default style will be used for
             them. If there is no default style, the attributes of the text control itself are used.
            
             So the following code correctly describes what it does: the second call to SetDefaultStyle doesn't change the 
             text foreground colour (which stays red) while the last one doesn't change the background colour (which stays grey):
            
             <code>
             text.SetDefaultStyle(wxTextAttr(wx.Colour.wxRED));
             text.AppendText("Red text\n");
             text.SetDefaultStyle(wx.TextAttr(null, wx.Colour.wxLIGHT_GREY));
             text.AppendText("Red on grey text\n");
             text.SetDefaultStyle(wxTextAttr(wx.Colour.wxBLUE);
             text.AppendText("Blue on grey text\n");
             </code>
             
             Event handling
            
             The following commands are processed by default event handlers in wxTextCtrl: wxID_CUT, wxID_COPY, wxID_PASTE,
             wxID_UNDO, wxID_REDO. The associated UI update events are also processed automatically, when the control has
             the focus.
            
             To process input from a text control, use these event handler macros to direct input to member functions
             that take a wxCommandEvent argument.
             <list type="table">
             <item><term>EVT_TEXT(id, func)</term><description>Respond to a wxEVT_COMMAND_TEXT_UPDATED event, generated when the text changes. Notice that this event will be sent when the text controls contents changes - whether this is due to user input or comes from the program itself (for example, if SetValue() is called); see ChangeValue() for a function which does not send this event.</description></item>
             <item><term>EVT_TEXT_ENTER(id, func)</term><description>Respond to a wxEVT_COMMAND_TEXT_ENTER event, generated when enter is pressed in a text control (which must have wxTE_PROCESS_ENTER style for this event to be generated).</description></item>
             <item><term>EVT_TEXT_URL(id, func)</term><description>A mouse event occurred over an URL in the text control (wxMSW and wxGTK2 only) </description></item> 
             <item><term>EVT_TEXT_MAXLEN(id, func)</term><description>User tried to enter more text into the control than the limit set by SetMaxLength.  </description></item>
             </list>
             </remarks>
        </member>
        <member name="M:wx.TextCtrl.AppendFormat(System.String,System.Object[])">
            <summary>This appends the expanded <c>format</c> to the text as presented by this control.
            The format string is due to <c>string.Format()</c>.</summary>
        </member>
        <member name="M:wx.TextCtrl.AppendText(System.String)">
            <summary>This appends <c>text</c> to the text presented in the control.
            Cf. AppendFormat().</summary>
        </member>
        <member name="M:wx.TextCtrl.AppendText(wx.wxString)">
            <summary>This appends <c>text</c> to the text presented in the control.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEdit.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String,wx.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
            
        </member>
        <member name="M:wx.MaskedEdit.MaskedEdit.#ctor(wx.Window,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.String,wx.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
        </member>
        <member name="M:wx.MaskedEdit.MaskedEdit.#ctor(wx.Window,System.String,wx.MaskedEdit.EditField[])">
            <summary>CTor creating a masked edit of the provided fields. Note, that <c>textMask</c> has to be compatible to the number of fields.
            </summary>
            <param name="textMask"> is the text mask for the input. Like  format strings, the mask contains "{0}" and similar wildcards for each
                   fields. The mask has to provide a wildcard fo each field. Otherwise, this CTor will raise a <c>FormatException</c>.
                   </param>
            <param name="fields"> is an array of field definitions containing an element for each input value. Note, that the provided instances
                   will be used to hold the values. So, you may refer directly to these instances rather than to the provided indexer.
                   Please note, that fields should be provided in the order that shall define the action on pressing HOME, END, Cursor Left, and
                   Cursor Right.
                   </param>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEdit.Count">
            <summary>Number of fields.
            </summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedEdit.Item(System.Int32)">
            <summary>Gets the field of index <c>i</c>.
            </summary>
        </member>
        <member name="T:wx.MaskedEdit.Tokenizer">
            <summary>This class receives a string and a number of separators and will enumerate over all parts of the received string, that are separated by one of the separator.
            </summary>
        </member>
        <member name="T:wx.MaskedEdit.MaskedDateTimeEditService">
            <summary>Service class for DateTime input.</summary>
            <remarks>
            This will manage a masked input if a DateTime. Configure the mask using
            the format strings
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            
            This will use string from the definition of the current culture <c>CultureInfo.CurrentCulture.DateTimeFormat</c>.
            The current  wxWidgets locale does not influence this.
            </remarks>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.EditWildcard(System.Char,System.Int32)">
            <summary>This will return the edit field for wildcard <c>c</c> and <c>cardinality</c>.
            Example: "yyyy" => <c>c</c>='y', <c>cardinality</c>=4 => "{yyyy}".</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.StdMaskToEditMask(System.String)">
            <summary>Turns a standard date mask for example from <c>System.Globalization.CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c> into a string mask for this control.
            Sample: "yyyyMMdd" => "{yyyy}{MM}{dd}".</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.StdMasksToEditMask(System.String)">
            <summary>Turns .NET standard mask into an edit mask as used by the DateTime mask edit control.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.IntToString(System.Int32,System.Char,System.Int32)">
            <summary>This will add a prefix to the string form of <c>number</c> consisting of <c>emptyChar</c> in such a way that the result is of length <c>length</c>.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.ExpandFormatString(System.String,System.DateTime)">
            <summary>Produces a string output of <c>data</c> according to a format string that is compatible to the format specifications of this control.
            This expand the following format strings using <c>data</c>:
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c></summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.CreateMaskEdit(wx.TextCtrl,System.String)">
            <summary>This will transform a <c>DateTimeFormatInfo</c> format string into a format string applicable to this.
            This will always use the current culture info for text patterns.
            
            This will create</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.UpdateFieldValues(wx.MaskedEdit.EditField)">
            <summary>Writes the current value into the fields.
            \param protected is a field that will not be updated</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnEditValueChanged(System.Object,wx.MaskedEdit.MaskedEditFieldValueChangedEvent)">
            <summary>Will update all filds if one changed.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.ResetCurrentValue">
            <summary>Helper to find a standard for the current value of required but not set.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnOverflowField(System.Object,wx.MaskedEdit.EditIntField.OverflowEvent)">
            <summary>Called on overflow in day/month input.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnUnderflowField(System.Object,wx.MaskedEdit.EditIntField.UnderflowEvent)">
            <summary>Called on overflow in day/month input.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnChangingLongYear(System.Object,wx.MaskedEdit.MaskedEditFieldValueChangingEvent)">
            <summary>Called if a field on the full year has changed.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnChangingShortYear(System.Object,wx.MaskedEdit.MaskedEditFieldValueChangingEvent)">
            <summary>Called if a field on the final two digits of the year has changed.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.Select(System.Int32)">
            <summary>Select the edit field of the provided index.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.GetNearest(System.Int32)">
            <summary>Returns the index of the edit field that is as near as possible to the provided text position.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.GetNearest(System.Drawing.Point)">
            <summary>Returns the index of the edit field that is as near as possible to the provided window position.</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.OnChar(System.Object,wx.Event)">
            <summary>Directly calls this method of the masked edit.
            Refer to MaskedEditService.OnChar().</summary>
        </member>
        <member name="M:wx.MaskedEdit.MaskedDateTimeEditService.#ctor(wx.TextCtrl,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>* \param ctrl is the text control that will be used for input.
            \param startValue is the optional initial value.
            \param mask is the string mask. This may be an arbitrary string with format specifiers as listed in the
                   documentation of this class (in curly brackets).
            \param minValue is optional minimal acceptable value.
            \param maxValue is optional maximal acceptable value.
            \param allowNull is true if the user may defer or abort input.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.AMDesignator">
            <summary>This will return an AM designator even iff the current culture does not define one.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.PMDesignator">
            <summary>This will return an AM designator even iff the current culture does not define one.</summary>
        </member>
        <member name="E:wx.MaskedEdit.MaskedDateTimeEditService.OnValueChanged">
            <summary>This will be called immediately after the value has been changed.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.Value">
            <summary>Get or set the current value.
            This may be <c>null</c> of this allows empty input.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.TextMask">
            <summary>Returns the text mask defining the format of the text presentation.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.Count">
            <summary>Returns the number of input fields.</summary>
        </member>
        <member name="P:wx.MaskedEdit.MaskedDateTimeEditService.Item(System.Int32)">
            <summary>Returns the edit field at the provided position.
            Use a number between 0 and this.Count. Otherwise, this will raise exceptions.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="T:wx.MaskedEdit.DateTimeEdit">
            <summary>This is a masked edit control for DateTime input.
            This will manage a masked input if a DateTime.
            </summary>
            <remarks>
            Configure the mask using
            the format strings
            \li \c {dd} specifying the output of the day in month index 1-31,
            \li \c {ddd} specifying the output of an abbreviated name of the day (like "Mon", "Tue", etc),
            \li \c {dddd} specifying the output of the full name of the day,
            \li \c {hh} displays the hour 1-12,
            \li \c {HH} displays the hour 0-23,
            \li \c {mm} displays the minutes 0-59,
            \li \c {MM} displays the month 1-12,
            \li \c {MMM} displays the abbreviated name of the month,
            \li \c {MMMM} displays the full name of the month,
            \li \c {ss} displays the number of seconds,
            \li \c {tt} displays the AM or PM designator,
            \li \c {yy} displays the year with two digits,
            \li \c {yyyy} displays the year with four digits.
            \li \c %d will be replaced by the short date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern</c>.
            \li \c %D will be replaced by the long date pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongDatePattern</c>.
            \li \c %t will be replaced by the short time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.ShortTimePattern</c>.
            \li \c %T will be replaced by the long time pattern according to <c>CultureInfo.CurrentCulture.DateTimeFormat.LongTimePattern</c>.
            \li \c %f is equivalent to "%D %t"
            \li \c %F is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.FullDateTimePattern</c>
            \li \c %g is equivalent to "%d %t"
            \li \c %G is equivalent to "%d %T"
            \li \c %M is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.MonthDayPattern</c>
            \li \c %Y is defined with respect to <c>CultureInfo.CurrentCulture.DateTimeFormatInfo.YearMonthPattern</c>
            
            This will use string from the definition of the current culture <c>CultureInfo.CurrentCulture.DateTimeFormat</c>.
            The current  wxWidgets locale does not influence this.
            </remarks>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>CTor creating a <c>DateTime</c> edit.
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of the class for further remarks on this.
            \param minValue is an optional lower bound or the input.
            \param maxValue is an optional upper bound of the input.
            \param allowNull indicates with <c>true</c> that this may return a <c>null</c>, i.e. that the input is optional.
            \param style this will accept all styles that also fit wx.TextCtrl. We recomment <c>wx.WindowStyles.BORDER_SUNKEN</c>.
            
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.#ctor(wx.Window,System.Drawing.Point,System.Drawing.Size,wx.WindowStyles,System.Nullable{System.DateTime},System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>CTor creating a <c>DateTime</c> edit.
            \param startValue is an optional value that will be displayed on start.
            \param textMask is a string containing format characters according to the class documentation, e.g. "%d". Refer to
                            the documentation of the class for further remarks on this.
            \param minValue is an optional lower bound or the input.
            \param maxValue is an optional upper bound of the input.
            \param allowNull indicates with <c>true</c> that this may return a <c>null</c>, i.e. that the input is optional.
            
            If you tell this edit to process ENTER, the ENTER key will proceed from the currently selected field to the next field.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.#ctor(wx.Window,System.DateTime)">
            <summary>CTor creating a <c>DateTime</c> edit reading a date in localized standard format.
            \param startValue is an optional value that will be displayed on start.</summary>
        </member>
        <member name="F:wx.MaskedEdit.DateTimeEdit.OnValueChanged">
            <summary>This event fires after changing the value of this control.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.Select(System.Int32)">
            <summary>Select the edit field of the provided index.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.GetNearest(System.Int32)">
            <summary>Returns the index of the edit field that is as near as possible to the provided text position.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.GetNearest(System.Drawing.Point)">
            <summary>Returns the index of the edit field that is as near as possible to the provided window position.</summary>
        </member>
        <member name="M:wx.MaskedEdit.DateTimeEdit.OnChar(System.Object,wx.Event)">
            <summary>Directly calls this method of the masked edit.
            Refer to MaskedEditService.OnChar().</summary>
        </member>
        <member name="P:wx.MaskedEdit.DateTimeEdit.Value">
            <summary>Get or set the value.
            The result may be <c>null</c> if this allows empt input.</summary>
        </member>
        <member name="P:wx.MaskedEdit.DateTimeEdit.TextMask">
            <summary>Returns the text mask defining the format of the text presentation.</summary>
        </member>
        <member name="P:wx.MaskedEdit.DateTimeEdit.Count">
            <summary>Returns the number of input fields.</summary>
        </member>
        <member name="P:wx.MaskedEdit.DateTimeEdit.Item(System.Int32)">
            <summary>Returns the edit field at the provided position.
            Use a number between 0 and this.Count. Otherwise, this will raise exceptions.
            Negative numbers will count the fields from the end. So, -1 designates the
            last edit field.</summary>
        </member>
        <member name="M:wx.Choice.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,System.String[],wx.WindowStyles)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:wx.Choice.#ctor(wx.Window,System.Int32,System.Drawing.Point,System.Drawing.Size,System.String[],wx.WindowStyles,System.String)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="P:wx.Choice.CurrentSelection">
            <summary>Read-only property returning the index of the current selection.
             Unlike ControlWithItems.Selection() which only returns the accepted selection value,
             i.e. the selection in the control once the user closes the dropdown
             list, this function returns the current selection. That is, while
             the dropdown list is shown, it returns the currently selected item
             in it. When it is not shown, its result is the same as for the other
             function.
            </summary>
        </member>
        <member name="T:wx.CheckBoxState">
            <summary>
            Possible states of a check in a wx.CheckBox.
            </summary>
        </member>
        <member name="T:wx.CheckBox">
            <summary>
            A checkbox is a labelled box which by default is either on (checkmark is visible) or off (no checkmark).
            Optionally (when the wxCHK_3STATE style flag is set) it can have a third state, called the mixed or undetermined state.
            Often this is used as a "Does Not Apply" state.
            
            Uses style WindowStyles.CHK_2STATE, WindowStyles.CHK_3STATE, and WindowStyles.CHK_ALLOW_3RD_STATE_FOR_USER.
            </summary>
        </member>
        <member name="P:wx.CheckBox.Value">
            <summary>
            This is the 2-state-value.
            Asserts if the control is in 3-state mode.
            </summary>
        </member>
        <member name="P:wx.CheckBox.ThreeStateValue">
            <summary>
            This is the 3-state-value.
            Asserts if the control is in 2-state mode.
            </summary>
        </member>
        <member name="M:wx.XmlResource.SetSubclassDefaults">
            <summary>Sets the default assembly/namespace based on the assembly from
            		   which this method is called (i.e. your assembly!).
            		 
            		   Determines these by walking a stack trace. Normally 
            		   Assembly.GetCallingAssembly should work but in my tests it 
            		   returned the current assembly in the static constructor above.</summary>
        </member>
        <member name="T:wx.ListItemMask">
            <summary>Indicates relevant members of a wx.ListItem.
            Instances of wx.ListItem may be masked, i.e. only some of their
            properties may be valid. These flags define which properties
            of the item are valid and shall be used and which properties
            are irrelevant and shall be ignored.</summary>
        </member>
        <member name="F:wx.ListItemMask.NONE">
            <summary>Nothing is valid.</summary>
        </member>
        <member name="F:wx.ListItemMask.STATE">
            <summary>wx.ListItem.State</summary>
        </member>
        <member name="F:wx.ListItemMask.TEXT">
            <summary>wx.ListItem.Text</summary>
        </member>
        <member name="F:wx.ListItemMask.IMAGE">
            <summary>wx.ListItem.Image</summary>
        </member>
        <member name="F:wx.ListItemMask.DATA">
            <summary>wx.ListItem.Data</summary>
        </member>
        <member name="F:wx.ListItemMask.ITEM">
            <summary>wx.ListItem.Item</summary>
        </member>
        <member name="F:wx.ListItemMask.WIDTH">
            <summary>wx.ListItem.Width</summary>
        </member>
        <member name="F:wx.ListItemMask.FORMAT">
            <summary>wx.ListItem.Format</summary>
        </member>
        <member name="F:wx.ListItemMask.ALL">
            <summary>Denotes all properties of list items.</summary>
        </member>
        <member name="T:wx.ListItemState">
            <summary>Flags for wx.ListCtrl.GetNextItem()</summary>
        </member>
        <member name="T:wx.ListItem">
            <summary>Representation of an item in wx.ListCtrl or wx.ListView.</summary>
        </member>
        <member name="M:wx.ListItem.#ctor(System.String)">
            <summary>Generating an item representing the following text.
            </summary>
        </member>
        <member name="M:wx.ListItem.#ctor(System.String,wx.ListColumnFormat)">
            <summary>Generating an item of the provided text and the specified alignment.</summary>
            <param name="align"> is a constant like wx.ListCtrl.wxLIST_FORMAT_CENTRE
            </param>
        </member>
        <member name="P:wx.ListItem.Align">
            <summary>A constant like wx.ListColumnFormat.CENTRE.</summary>
        </member>
        <member name="P:wx.ListItem.Data">
            <summary>Get or set the client data that is associated with this list item.
            Please note, that the list item will take ownership of the C++ instance of the client data.
            So, this will raise an exception, if the client data is already in use elsewhere.</summary>
        </member>
        <member name="T:wx.ListColumnFormat">
            <summary>Format for list columns.
            This will be used in wx.ListCtrl.Arrange() and wx.ListItem.Align</summary>
        </member>
        <member name="T:wx.ListHitTest">
            <summary>Flags that may result from wx.ListCtrl.HitTest().</summary>
        </member>
        <member name="T:wx.ListCtrl">
            <summary>The list control.
            This is appropriate to display also large lists of data.
            \image html listctrlsmall.png "The list control in report mode."</summary>
        </member>
        <member name="M:wx.ListCtrl.OnGetItemText(System.Int32,System.Int32)">
            <summary>Overload this to provide the name of a virtually represented item.
            The default implementation returns an empty string. So, don't be surprised if
            you get an empty list because you didn't implement this.</summary>
        </member>
        <member name="M:wx.ListCtrl.OnGetItemImage(System.Int32)">
            <summary>Return the index of the icon of the designated item in the used image list.
            Overload this for virtual lists.
            
            This standard implementation will return an undefined index (-1)
            for "do no show any item image".</summary>
        </member>
        <member name="M:wx.ListCtrl.OnGetItemColumnImage(System.Int32,System.Int32)">
            <summary>Return the index of the icon of the designated item and the designated column in the used image list.
            Overload this for virtual lists.
            
            This standard implementation will return an undefined index (-1)
            for "do no show any item image".</summary>
        </member>
        <member name="M:wx.ListCtrl.GetItem(wx.ListItem)">
            <summary>Assigns the item corresponding to the ID, column, and property mask of <c>info</c> to <c>info</c>.
            This is for compatibility to  wxWidgets only. Use the indexer if you prefer
            a more convenient and more standard way to ask for items.
            
            <c>info</c> will be loaded with all properties of item sharing ID and column
            with <c>info</c> as designated by <c>info.Mask</c>.
            </summary>
        </member>
        <member name="M:wx.ListCtrl.SetItem(wx.ListItem)">
            <summary>Assigns item <c>info</c> to the control.
            This will change the properties of the item of this control sharing the ID
            with <c>info</c>. The method will select those properties of <c>info</c> that are
            compatible with the property mask of <c>info</c>.
            This is for compatibility to  wxWidgets only. Use the indexer if you prefer
            the standard way to set for items.
            </summary>
        </member>
        <member name="M:wx.ListCtrl.GetItemState(System.Int32,wx.ListItemState)">
            <summary>Item state. Only the bits of the mask will be queried.</summary><remarks>
                     * \verbatim
                     if (listCtrl.GetItemState(3, ListItemState.SELECTED)==ListItemState.SELECTED)
                        System.Diagnostics.Trace.WriteLine("Item 3 has been selected.");
                     \endverbatim
                     * </remarks>
        </member>
        <member name="M:wx.ListCtrl.IsSetItemStateFlag(System.Int32,wx.ListItemState)">
            <summary>True iff all <c>flags</c> have been set for item <c>item</c>.
                     * </summary>
                     * <remarks>
                     * Is equivalent to 
                     * \verbatim
                     this.GetItemState(item, flags)==flags
                     \endverbatim
                     * </remarks>
        </member>
        <member name="M:wx.ListCtrl.SetImageList(wx.ImageList,wx.wxImageList)">
            <summary>Defines the image list to be used by instances of wx.ImageItem added to this list.</summary>
            <param name="which"> defines which of the internal image lists will be set, e.g. by wx.wxImageList.wxIMAGE_LIST_SMALL.
            </param>
        </member>
        <member name="M:wx.ListCtrl.EnsureVisible(System.Int32)">
            <summary>Ensures visibility of the designated item.</summary>
        </member>
        <member name="M:wx.ListCtrl.AppendItemRow(wx.ListItem[])">
            <summary>This will change the Id of the provided items to the number of known items and then insert them.
            This is a convenience method to append items at the end of the current item list without regarding
            the ID of the items.</summary>
        </member>
        <member name="M:wx.ListCtrl.InsertItemRow(wx.ListItem[])">
            <summary>This will insert a new item assuming each of the arguments to represent a column value.
            The first column item will be used for column 0, the second for column 1, and so forth.
            The method will adjust the column attribute of the arguments.</summary>
        </member>
        <member name="M:wx.ListCtrl.InsertItem(wx.ListItem)">
            <summary>Inserts an item and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:wx.ListCtrl.InsertItem(System.Int32,System.String)">
            <summary>Inserts an item and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:wx.ListCtrl.InsertItem(System.Int32,System.Int32)">
            <summary>Inserts an item presenting an image and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:wx.ListCtrl.InsertItem(System.Int32,System.String,System.Int32)">
            <summary>Inserts an item presenting image and text label and returns the index of the new item or -1 if insertion failed.</summary>
        </member>
        <member name="M:wx.ListCtrl.ScrollList(System.Int32,System.Int32)">
            <summary>Scrolls the list control.
             If in icon, small icon or report view mode, <c>dx</c> specifies the number of
             pixels to scroll. If in list view mode, <c>dx</c> specifies the number of columns
             to scroll. <c>dy</c> always specifies the number of pixels to scroll vertically.
            
             \b NB: This method is currently only implemented in the Windows version.
             
             Try EnsureVisible().</summary>
        </member>
        <member name="M:wx.ListCtrl.SortItems(wx.ListCtrl.wxListCtrlCompare,System.Int32)">
            <summary>Sort the contained list items with respect to <c>fn</c>.
            Refer to remarks on <c>wxListCtrlCompare</c>.
            </summary>
        </member>
        <member name="M:wx.ListCtrl.SortItemsAccordingToClientData(System.Collections.IComparer)">
            <summary>Sort according to the order of client data as specified by the comparer.
            This assumes that all items have assigned client data assigned and that this
            data implements System.IComparable. Missing or non-comparable client data 
            will be replaced by the item's name.</summary>
        </member>
        <member name="M:wx.ListCtrl.GetEnumerator">
            <summary>Returns an enumeration of all nodes.
            Refer to ListCtrlEnumerator.</summary>
        </member>
        <member name="P:wx.ListCtrl.SelectedItems">
            <summary>Returns a list of selected items.</summary>
        </member>
        <member name="P:wx.ListCtrl.Item(System.Int32)">
            <summary>Gets and sets the item at the designated position.
            If you assign an item using this indexer, the ID of this item
            will change to <c>index</c>. The mask will also be set to wx.ListItemMask.ALL.
            </summary>
        </member>
        <member name="P:wx.ListCtrl.ViewRect">
            <summary>This only works in icon mode and returns an unspecific reactangle otherwise.</summary>
        </member>
        <member name="T:wx.ListCtrl.NEXT">
            <summary>Flags for GetNextItem()</summary>
        </member>
        <member name="T:wx.ListCtrl.SymbolicColumnWidth">
            <summary>These are optional symbolic specifications of the column width.
            Refer to wx.ListCtrl.SetColumnWidth().</summary>
        </member>
        <member name="F:wx.ListCtrl.SymbolicColumnWidth.AUTOSIZE">
            <summary>This will resize the column to the length of its longest item.</summary>
        </member>
        <member name="F:wx.ListCtrl.SymbolicColumnWidth.AUTOSIZE_USEHEADER">
            <summary>This will resize the column to the length of the header (Win32) or 80 pixels (other platforms).</summary>
        </member>
        <member name="T:wx.ListCtrl.wxListCtrlCompare">
            <summary>The corresponding  wxWidgets function type uses <c>int</c> data to designate items and sort data.
             However, C typically identifies <c>int</c> and <c>long</c> on 32 bit architectures. Apparently, C# does not so.
             It is apparently unwise to use <c>long</c> in native C interfaces since this data type does not have
             a standard size_t.
            </summary>
        </member>
        <member name="T:wx.ListCtrl.SortCallback">
            <summary>This internal class converts from <c>cbSortItems</c> to <c>wxListCtrlCompare</c>.
            </summary>
        </member>
        <member name="T:wx.ListCtrl.ItemDataComparer">
            <summary>A class comparing the client data of items.</summary>
        </member>
        <member name="M:wx.ListCtrl.ItemDataComparer.Compare(wx.ClientData,wx.ClientData,System.Int32)">
            <summary>Expects the objects to be indices of items in the control and compares associated client data using the comparer.</summary>
        </member>
        <member name="M:wx.ListCtrl.ItemDataComparer.Compare(System.Object,System.Object)">
            <summary>Expects the objects to be instances of ClientData.</summary>
        </member>
        <member name="T:wx.ListCtrl.ItemEnumerator">
            <summary>Enumerator on list items.
            This is an alternative, more C# like interface to wx.ListCtrl.GetNextItem().
            </summary>
        </member>
        <member name="M:wx.ListCtrl.ItemEnumerator.#ctor(wx.ListCtrl)">
            <summary>Iterates all nodes.
            </summary>
        </member>
        <member name="M:wx.ListCtrl.ItemEnumerator.#ctor(wx.ListCtrl,wx.ListItemState)">
            <summary>Iterates all nodes complying with <c>stateFilter</c>.
            </summary>
        </member>
        <member name="P:wx.ListEvent.Data">
            <summary>Returns the client data that has been associated with the item.</summary>
        </member>
        <member name="T:wx.Fullscreen">
            <summary> Flags for Frame.ShowFullScreen.
                 </summary>
        </member>
        <member name="T:wx.SystemObjectClientData">
            <summary>Generate an instance of this class to use an System.Object as client data of choices etc.
             This simply generates an instance of ClientData, which holds a new instance of <c>wxClientData</c>.
             Of course, that <c>wxClientData</c> does not hold any data, but when .NET code refers to client data
             of a Choice or another control, the selector will use this pointer to a <c>wxClientData</c> to
             identify this instance via <c>Object.FindObject()</c>.
            </summary>
        </member>
        <member name="T:wx.Archive.ZipStream">
            <summary>Internal base class for writing or reading into a ZIP stream.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipStream.SetLength(System.Int64)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipStream.Length">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipStream.Position">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveEntry">
            <summary>Describes an entry of an archive.</summary><remarks>
            An entry is a file included into an archive. Instances of this class
            are used as a key to denote particular files for reading and on the
            other hand provide meta information on the file as far as this
            information has been accessable.
            
            Generate instances by wx.ArchiveInput.
            
            \ref archive_formats_such_as_zip</remarks>
        </member>
        <member name="M:wx.Archive.ArchiveEntry.TypeFromName(System.String)">
            <summary>Conludes the archive type from the file name.
             Uses Zip by default.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveEntry.TypeFromName(System.Uri)">
            <summary>Conludes the archive type from the file name.
             Uses Zip by default.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.DateTime">
            <summary>Modifcation time.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.InternalName">
            <summary>The internal representation of the file name of this entry.
             Use this to implement portable comparisons.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.Name">
            <summary>The file name of this entry in native format.
             This can be read and set.
             
             If this is a directory entry, (i.e. if IsDir() is true) then
             Name() returns the name with a trailing path separator.
             Similarly, setting a name with a trailing path separator
             sets IsDir().
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.IsDir">
            <summary>True iff this represents a directory.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.Offset">
            <summary>Returns a numeric value unique to the entry within the archive.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveEntry.Size">
            <summary>The size of the entry's data in bytes.
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveEntry.ArchiveType">
            <summary>
            The type of the archive - compression mode.
            </summary>
        </member>
        <member name="F:wx.Archive.ArchiveEntry.ArchiveType.Zip">
            <summary>
            Uses Zip compression
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveOutput">
            <summary>Writing into an archive file type supported by  wxWidgets.</summary><remarks>
              wxWidgets supports reading, analyzing, and writing archive files. Currently
             only ZIP archives are supported. Corresponding features are only partially
             supported by the standard .NET framework since 2.0.
             
             The interface of this class differs strongly from the  wxWidgets API since
             this API shall be extendable to use standard .NET framework classes where
             possible. Additionally, we cannot inherit from both, wx.Object and Stream.
             
             \ref archive_formats_such_as_zip
            </remarks>
        </member>
        <member name="F:wx.Archive.ArchiveOutput._streamOnEntry">
            <summary>Stream for writing into an entry.
             This is <c>null</c> if entry is closed.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.#ctor(System.Uri)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.#ctor(System.Uri,wx.Archive.ArchiveEntry.ArchiveType)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.PutNextEntry(System.String)">
            <summary>Sets Out() to a fill a new entry of the provided name.
             If Out() has been already non-null before, the previous stream
             on the entry will be closed.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.CopyEntry(wx.Archive.ArchiveEntry,wx.Archive.ArchiveInput)">
            <summary>* Takes ownership of entry and uses it to create a new entry in the archive. Entry is then opened in the input stream stream and its contents copied to this stream.
             For archive types which compress entry data, CopyEntry() is likely to be much more efficient than transferring the data using Read() and Write() since it will copy them without decompressing and recompressing them.
             entry must be from the same archive file that stream is accessing. For non-seekable streams, entry must also be the last thing read from stream.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.CopyArchiveMetaData(wx.Archive.ArchiveInput)">
            <summary>* Some archive formats have additional meta-data that applies to the
             archive as a whole. For example in the case of zip there is a
             comment, which is stored at the end of the zip file.
             CopyArchiveMetaData() can be used to transfer such information
             when writing a modified copy of an archive.
            
             Since the position of the meta-data can vary between the various
             archive formats, it is best to call CopyArchiveMetaData() before
             transferring the entries. The wx.ArchiveOutput will then
             hold on to the meta-data and write it at the correct point in the
             output file.
            
             When the input archive is being read from a non-seekable stream,
             the meta-data may not be available when CopyArchiveMetaData()
             is called, in which case the two streams set up a link and 
             transfer the data when it becomes available.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveOutput.Close">
            <summary>This closes the whole archive and returns true in case of success.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveOutput.Out">
            <summary>This is the stream to write into the current entry of the archive.
             This is <c>null</c> if we do not have an opened entry.
             Entries can be opened by PutNextEntry().
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveOutput.ZipOutStream">
            <summary>Internal class for writing into a ZIP stream on an entry in the archive.
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveInput">
            <summary>Reading from an archive file type supported by  wxWidgets.
              wxWidgets supports reading, analyzing, and writing archive files. Currently
             only ZIP archives are supported. Corresponding features are only partially
             supported by the standard .NET framework since 2.0.
             
             The interface of this class differs strongly from the  wxWidgets API since
             this API shall be extendable to use standard .NET framework classes where
             possible.
            </summary>
        </member>
        <member name="F:wx.Archive.ArchiveInput._streamOnEntry">
            <summary>Stream for writing into an entry.
             This is <c>null</c> if entry is closed.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.#ctor(wx.FileSys.wxInputStreamWrapper,wx.Archive.ArchiveEntry.ArchiveType)">
            <summary>Creates an archive input representation reading compressed data from the provided stream.
            Please note, that this instance will take ownership of the native code instance wrapped by
            the <c>wxInputStreamWrapper</c>.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.#ctor(System.IO.Stream,wx.Archive.ArchiveEntry.ArchiveType)">
            <summary>Generate an instance reading compressed data from the provided stream.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.#ctor(System.IO.Stream)">
            <summary>Generate an instance reading compressed data from the provided stream.
             By default this will interpret the data as a ZIP archive.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.#ctor(System.Uri)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.#ctor(System.Uri,wx.Archive.ArchiveEntry.ArchiveType)">
            <summary>This consumes an URI pointing at a local file.
             Raises currently an <c>ArgumentException</c> if the argument is not a local file name.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.GetNextEntry">
            <summary>* Closes the current entry if one is open, then reads the meta-data for
                     * the next entry and returns it in a wxArchiveEntry object, giving away
                     * ownership. Reading this wx.ArchiveInput.In then returns the entry's
                     * data.
                    *</summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.OpenEntry(wx.Archive.ArchiveEntry)">
            <summary>* Closes the current entry if one is open, then opens the entry specified</summary><remarks>
             by the wxArchiveEntry object.
            
             <c>entry</c> must be from the same archive file that this wx.ArchiveInput is reading,
             and it must be reading it from a seekable stream.
            
             \ref looking_up_an_archive_entry_by_name</remarks>
        </member>
        <member name="M:wx.Archive.ArchiveInput.Close">
            <summary>This closes In() if we have an open entry.
            </summary>
        </member>
        <member name="M:wx.Archive.ArchiveInput.GetInternalName(System.String)">
            <summary>Returns the internal representation of <c>localFilename</c> in the current type of archive.
             Note, that instances of this class may wrap archives of different type, so the internal
             representation depends on the archive type.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveInput.In">
            <summary>This is the stream to read the current entry from.
             This is <c>null</c> if all entries are closed (none has been opened).
            </summary>
        </member>
        <member name="T:wx.Archive.ArchiveInput.ZipInStream">
            <summary>Internal class for writing into a ZIP stream on an entry in the archive.
            </summary>
        </member>
        <member name="P:wx.Archive.ArchiveInput.ZipInStream.CanSeek">
            <summary>Returns <c>true</c> iff you may seek this stream.
            This method currently relies on <c>IsSeekable()</c> if the archive
            stream. Apparently, the ZIP streams do not implement this method
            although they implement <c>Seek()</c>. Anyway, this will return <c>false</c>
            to enable particular heuristics in the IOStreamFSHandler.
            
            Image handlers of  wxWidgets want to seek.</summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.Archive.ZipResource" ignoriert -->
        <member name="F:wx.Archive.ZipResource._archiveNameToDerivates">
            <summary>This maps a KeyArchiveName to a list of derived archive names on the mentioned locale.
            </summary>
        </member>
        <member name="F:wx.Archive.ZipResource._archives">
            <summary>This maps the local file name to the resource archive.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.ComputeDerivates(System.String,System.String,System.String)">
            <summary>Searches all derivates of <c>archiveName</c> whether they are an archive or a directory.
             Returns the name of the first existing derivate.
             \param archiveName is a filename of an archive. On missing extension, _stdSubdir() will be
             added. Note, that tis filename will be extended, so existance of this file is not required.
             \param additionalPrefix is a directory name that is additionally used as a prefix for resource archives.
             (In addition to AddCatalogLookupPrefix()).
             \param canonicalName is the canonical name of a locale. This method will search the resource
             for this locale.
             
             Extends _archiveNameToDerivates() in such a way that it containes all derivates if the provided <c>archiveName</c>.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.InitFromArchive(System.String,System.IO.Stream)">
            <summary>Initializes _dirName or _src and _internalNameToEntry from the archive returned by FindArchive().
             Main purpose: Cache archive entries if required. Possibly, resources cannot be loaded because
             the archive has not been found. In this case, do not throw an exception put set all
             possible sources <c>_dirName</c> and <c>_src</c> to <c>null</c>.
             srcStream may be <c>null</c>. Then it will be generated from the name that will
             be interpreted as a file name.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.#ctor(System.String,System.IO.Stream)">
            <summary>Loads an archive.
             This will call InitFromArchive(). All entries will be read and cached.
             srcStream may be <c>null</c>. Then it will be generated from the <c>archiveName</c> that will
             be interpreted as a file name. If read from the local file system (with <c>srcStream</c> equals
             <c>null)</c>, <c>archiveName</c> may either be a filename of a directory.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.AddCatalogLookupPrefix(System.String)">
            <summary>Add a prefix to be lookup path for loading archives with resources.
             Similar to wx.Locale.AddCatalogLookupPrefix().
             The message catalog files will be looked up under
             <c>prefix/LANG/zrs</c>,
             <c>prefix/LANG</c>, and <c>prefix</c>
             (in this order) where LANG is the canonical name of a locale.
            
             <c>prefix</c> will be expanded using the code base path of the calling assembly
             if necessary. So, the meaning of <c>prefix</c> never relies on the CWD but always
             on the position of the assemblies.
            
             This only applies to subsequent instance creations.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.GetDerivatedArchiveNames(System.String)">
            <summary>Returns the file names derivated from <c>archiveName</c> of the current <c>wx.Locale</c>.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.GetDerivatedArchiveNames(System.String,System.String)">
            <summary>Returns the file names derivated from <c>archiveName</c> assuming the locale <c>canonicalName</c>.
             Use the empty string to denote the neutral locale.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.GetDerivatedResourceNames(System.String)">
            <summary>Returns the resource names derivated from <c>resourceName</c> of the current <c>wx.Locale</c>.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.GetDerivatedResourceNames(System.String,System.String)">
            <summary>Returns the resource names derivated from <c>resourceName</c> assuming locale <c>canonicalName</c>.
             Use the empty string to denote the neutral locale.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.FindResource(System.Reflection.Assembly,System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            
             Non-rooted paths will be rooted with reference to the code base of <c>callingAssembly</c>.
             </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.FindResource(System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            
             Non-rooted paths will be rooted with reference to the code base of the calling assembly.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.ResourceFileCanSeek(System.String,System.String)">
            <summary>Some kinds of data, especially images, require data sources that can seek positions in the stream.
            This will call ResourceFile() and then, if the result cannot seek, load the source directly into
            a memory stream.</summary>
        </member>
        <member name="M:wx.Archive.ZipResource.ResourceFileAppropriateType(System.String,System.String)">
            <summary>This method will produce a stream that can seek (cf. ResourceFileCanSeek) if this seems to be appropriate referring to the mime type.
            At least images need streams as data source that can seek. This method will call ResourceFile() and analyze
            the mime type of the result. If considered to be appropriate, the content of the resource stream will
            be copied into a System.IO.MemoryStream in order to get a stream that can seek positions.
            Refer also to ResourceFileCanSeek().</summary>
        </member>
        <member name="M:wx.Archive.ZipResource.FindResourceFile(System.String,System.String)">
            <summary>Finds a FSFile instance containing a resource of the provided name from the provided archive.
             Refer to FindResource(string, string, string) for details.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.FindResource(System.String,System.String,System.String)">
            <summary>Finds a stream containing a resource of the provided name suitable for the specified locale from the provided archive.
            \param archiveName is a filename describing the archive where the resource has been compiled in. This may also be the name of a resource.
            This method will generate derivates from this name as described below.
            \param resourceName is a native filename (according to the conventions of class Path) describing
            the resource. This method will generate derivates from this name as described below.
            \param canonicalName is the canonical name of the locale that the required resource has to comply with.
            If a locale specific resource cannot be found, the method will load a neutral version. If this is <c>null</c>
            or empty, this method will immediately search for a neutral resource.
            
            If the resources cannot be found, the manifest of the calling assembly will be searched.
            
            This method will return a <c>null</c> if the desired resource cannot be find.</summary>
        </member>
        <member name="M:wx.Archive.ZipResource.FindResourceFile(System.String,System.String,System.String)">
            <summary>Finds a FSFile instance containing a resource of the provided name from the provided archive of a provided locale (culture).
             Refer to FindResource(string, string, string) for details.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipResource.LastFoundResourceName">
            <summary>The last name of a resource that has been found by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipResource.LastSearchedArchiveName">
            <summary>The last name of a resource that has been tried to be loaded by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipResource.LastFoundArchiveName">
            <summary>The last name of a resource that has been found by FindResource(). 
             This may be <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Archive.ZipResource.LastFoundArchive">
            <summary>The last ZipResource found by FindResource().
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.KeyArchiveName.#ctor(System.String,System.String)">
            <summary>Generates a key for the archive and the neutral locale.
            </summary>
        </member>
        <member name="M:wx.Archive.ZipResource.KeyArchiveName.#ctor(System.String,System.String,System.String)">
            <summary>Generates a key for the derivatives of <c>archiveName</c> with the specified locale.
            </summary>
        </member>
        <member name="M:wx.ToolBarTool.Toggle">
            <summary>
            Toggles the tool.
            </summary>
        </member>
        <member name="M:wx.ToolBarTool.Toggle(System.Boolean)">
            <summary>
            Toggles a tool on or off. This does not cause any event to get emitted.
            Only applies to a tool that has been specified as a toggle tool.
            </summary>
            <param name="toggle">If true, toggles the tool on, otherwise toggles it off.</param>
            <seealso cref="!:GetToolState"/>
        </member>
        <member name="T:wx.ToolBar">
             <summary>
             You may also create a toolbar that is managed by the frame, by calling wx.Frame.CreateToolBar(). Under Pocket PC,
             you should always use this function for creating the toolbar to be managed by the frame, so that wxWidgets can use
             a combined menubar and toolbar. Where you manage your own toolbars, create a wxToolBar as usual.
            
             The meaning of a "separator" is a vertical line under Windows and simple space under GTK+.
             </summary>
             <remarks>
             The toolbar family of classes allows an application to use toolbars in a variety of configurations and styles.
            
             The toolbar is a popular user interface component and contains a set of bitmap buttons or toggles.
             A toolbar gives faster access to an application's facilities than menus, which have to be popped up and
             selected rather laboriously.
             
             For each platform, the symbol wxToolBar is defined to be one of the specific toolbar classes.
            
             A toolbar might appear as a single row of images under the menubar, or it might be in a separate frame layout
             in several rows and columns. The class handles the layout of the images, unless explicit positioning is requested.
            
             A tool is a bitmap which can either be a button (there is no 'state', it just generates an event when clicked) or
             it can be a toggle. If a toggle, a second bitmap can be provided to depict the 'on' state; if the second bitmap is
             omitted, either the inverse of the first bitmap will be used (for monochrome displays) or a thick border is drawn
             around the bitmap (for colour displays where inverting will not have the desired result).
            
             The Windows-specific toolbar classes expect 16-colour bitmaps that are 16 pixels wide and 15 pixels high. If you
             want to use a different size, call SetToolBitmapSize as the demo shows, before adding tools to the button bar.
             Don't supply more than one bitmap for each tool, because the toolbar generates all three images (normal,
             depressed and checked) from the single bitmap you give it.
             </remarks>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,System.String,wx.Bitmap)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Enum,wx.Bitmap)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An enumeration value, that defines tool id and label of the new tool.
            The conversion to integer is a kay by which the tool may be identified in subsequent operations.
            The translation will be used as label.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,System.String,wx.Bitmap,wx.Bitmap,wx.ItemKind,System.String,System.String,wx.ClientData)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="bmpDisabled">The bitmap used when the tool is disabled. If it is equal to wx.NullBitmap,
            the disabled bitmap is automatically generated by greing the normal one.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,wx.wxString,wx.Bitmap,wx.Bitmap,wx.ItemKind,wx.wxString,wx.wxString,wx.ClientData)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="bmpDisabled">The bitmap used when the tool is disabled. If it is equal to wx.NullBitmap,
            the disabled bitmap is automatically generated by greing the normal one.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,System.String,wx.Bitmap,System.String,wx.ItemKind)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,wx.wxString,wx.Bitmap,wx.wxString,wx.ItemKind)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns></returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Int32,wx.Bitmap,wx.Bitmap,System.Boolean,wx.ClientData,System.String,System.String)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An integer by which the tool may be identified in subsequent operations.</param>
            <param name="label">String label of the tool.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <returns></returns>
        </member>
        <member name="M:wx.ToolBar.AddTool(System.Enum,wx.Bitmap,System.String)">
            <summary>
            Adds a tool to the toolbar.
            After you have added tools to a toolbar, you must call wx.ToolBar.Realize in order to have the tools appear.
            </summary>
            <param name="toolid">An enumeration value, that defines tool id and label of the new tool.
            The conversion to integer is a kay by which the tool may be identified in subsequent operations.
            The translation will be used as label.</param>
            <param name="bitmap">The primary tool bitmap</param>
            <param name="shortHelpString">A short help string.</param>
            <returns>The added tool</returns>
        </member>
        <member name="M:wx.ToolBar.Realize">
            <summary>
            This function should be called after you have added tools.
            </summary>
        </member>
        <member name="T:wx.StaticText">
            <summary>This displays a static text field.
            These controls consume wx.WindowStyles.ST_NO_AUTORESIZE and the flags on alignment.</summary>
        </member>
        <member name="T:wx.StaticBoxSizer">
            <summary>
            A BoxSizer surrounded by a static box.
            </summary>
        </member>
        <member name="M:wx.StaticBoxSizer.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="M:wx.StaticBoxSizer.#ctor(wx.StaticBox,wx.Orientation)">
            <summary>Creates a layout resuing a predefined static box.</summary>
        </member>
        <member name="M:wx.StaticBoxSizer.#ctor(wx.Orientation,wx.Window)">
            <summary>Creates an instance of the provided orientation without a a label.</summary>
        </member>
        <member name="M:wx.StaticBoxSizer.#ctor(wx.Orientation,wx.Window,System.String)">
            <summary>Creates an instance of the provided orientation with the specified label.</summary>
        </member>
        <member name="M:wx.StaticBoxSizer.#ctor(wx.Orientation,wx.Window,wx.wxString)">
            <summary>Creates an instance of the provided orientation with the specified label.</summary>
        </member>
        <member name="T:wx.PrintPreview">
            <summary>
            Objects of this class manage the print preview process.
            The object is passed a wxPrintout object, and the wx.PrintPreview object itself is passed to a wx.PreviewFrame object.
            Previewing is started by initializing and showing the preview frame. Unlike wx.Printer.Print, flow of control
            returns to the application immediately after the frame is shown.
            </summary>
            <remarks>
            \image html printpreview.png
            </remarks>
        </member>
        <member name="T:wx.MenuBar">
            <summary>
            Class of manu bars. Assign instances to wx.Frame.MenuBar.
            </summary>
        </member>
        <member name="T:wx.Globalization.CultureName">
            <summary>This class represent a normalized name of a culture like de-DE or en-GB.
             The name is composed of at most three components: Language, country, and special.
            </summary>
        </member>
        <member name="M:wx.Globalization.CultureName.#ctor(System.String,System.String,System.String)">
            <summary>A culture name specifying all three levels.
            \param lang defines the language in canonical form, e.g. "en" or "de".
            \param country define the country like "GB" or "US". Use "" as indifferent input.
            \param special is another additional specifiyer. Use "" as indifferent input.</summary>
        </member>
        <member name="M:wx.Globalization.CultureName.FromString(System.String)">
            <summary>Creates an instance from a canonical name like "de-DE" or "de_DE".</summary>
        </member>
        <member name="T:wx.Globalization.IDictionary">
            <summary>An interface for entities allwoing to translate a string.</summary>
        </member>
        <member name="M:wx.Globalization.IDictionary.GetTranslation(wx.Globalization.CultureName,System.String)">
            <summary>This will return a translation for <c>original</c> in the designated <c>culture</c>.
            </summary>
        </member>
        <member name="T:wx.Globalization.Dictionary">
            <summary>A dictionary might hold translations into several languages.
            </summary>
        </member>
        <member name="M:wx.Globalization.Dictionary.#ctor(wx.Globalization.CultureName,System.String,System.String,System.String[])">
            <summary>This is a dictionary containing translation into <c>culture</c>.
            </summary>
            <param name="original">provides the original that shall be translated.</param>
            <param name="translation">is the translation into the specified culture.</param>
            <param name="pairs"> is an optional sequence of an even number of strings. The first one is an original term, the second
                   is the translation of the first, the third is an original term, the forth is the translation of the forth,
                   and so on. If this is an odd number of arugments, the last string will be silently ignored.</param>
        </member>
        <member name="M:wx.Globalization.Dictionary.Add(wx.Globalization.CultureName,System.String,System.String)">
            <summary>This will add <c>translation</c> as translation of <c>original</c> into <c>culture</c>.
            This will raise an argument exception, or <c>original</c> already is translated into <c>culture</c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.Dictionary.AddRange(wx.Globalization.Dictionary)">
            <summary>This will add all translation of <c>alternativeTranslations</c> into this.</summary>
        </member>
        <member name="M:wx.Globalization.Dictionary.GetTranslation(System.String)">
            <summary>This will translate <c>original</c> into the current culture according to <c>System.Globalization.CultureInfo.CurrentCulture </c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.Dictionary.GetTranslation(wx.Globalization.CultureName,System.String)">
            <summary>Tries to translate into <c>culture</c>.
            If special culture name component is set, try to find a translation referring to the full culture name.
            If otherwise or not successful country name component is known, try to find a translation referring to language and culture.
            If failed, try to find a translation into the language as named by <c>culture</c>.
            If even this failed, return <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.Globalization.Dictionary.Item(System.String)">
            <summary>Get or set a translation into the current (referring to <c>System.Globalization)</c> culture.</summary>
        </member>
        <member name="P:wx.Globalization.Dictionary.Item(wx.Globalization.CultureName,System.String)">
            <summary>Get or set a translation into the provided culture.</summary><remarks>
            Gets a translation that is specific to the provided culture  or <c>null</c> if this translation does not exist for the specified culture.
            Example: "reden" is "de" translation of "talk". "snacken" is a more specific translation into "de-DE-KUESTE".
            <code>
            this[CultureName.FromString("de"), "talk"]
            </code>
            will return "reden",
            <code>
            this[CultureName.FromString("de-DE-KUESTE"], "talk")
            </code>
            will return "snacken", and
            <code>
            this[CultureName.FromString("de-DE"), "talk"]
            </code>
            will return <c>null</c>.
            </remarks>
        </member>
        <member name="T:wx.Globalization.StringInCultures">
            <summary>Instances of this classhold translations of one string.</summary>
        </member>
        <member name="M:wx.Globalization.StringInCultures.#ctor(System.String,System.String[])">
            <summary>Creates an instance comprising several translations.</summary><remarks>
                     * \param original is the original string.
                     * \param pairs is a sequence of an even number of strings. The first is the canonical name, the second is the
                     *    translation of <c>original</c> into the locale according to the first string. The third is the canonical name, the forth is the
                     *    translation of <c>original</c> into the locale according to the third string, and so on.
                     * 
                     * Example:
                     * \code
                     StringInCultures("talk", "de", "reden")
                     \endcode
                     * </remarks>
        </member>
        <member name="M:wx.Globalization.StringInCultures.GetTranslation(wx.Language)">
            <summary>Translate into the language as specified by the provided canonical language.
            If the original cannot be translated into the specified culture, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.StringInCultures.GetTranslation(System.String)">
            <summary>Translate into the language as specified by the provided canonical name.
            If the original cannot be translated into the specified culture, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.StringInCultures.GetTranslation(wx.Globalization.CultureName)">
            <summary>This returns the translation of the original string into <c>culture</c>.
            If the original cannot be translated into <c>culture</c>, this will try to translate into language and country
            of culture. If this is also not possible, this will try to translate into the language of culture. If even this
            fails, this method will return <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.StringInCultures.GetTranslation">
            <summary>This will translate into the current culture according to <c>System.Globalization.CultureInfo.CurrentCulture</c>.
            </summary>
        </member>
        <member name="P:wx.Globalization.StringInCultures.Item(wx.Globalization.CultureName)">
            <summary>Returns the translation of the original term into the provided culture if this exists and <c>null</c> otherwise.</summary>
        </member>
        <member name="P:wx.Globalization.StringInCultures.DefaultTranslation">
            <summary>This instance holds the default translation of this string.</summary>
        </member>
        <member name="P:wx.Globalization.StringInCultures.Cultures">
            <summary>This instance holds translations into this cultures.</summary>
        </member>
        <member name="T:wx.Globalization.TypeNameTranslationsAttribute">
            <summary>Use this attribute to provide translations of a class or type name using reflection.
            These names will for instance be used by <c>wx.Object._(Type)</c>.
            </summary>
        </member>
        <member name="M:wx.Globalization.TypeNameTranslationsAttribute.#ctor(wx.Globalization.StringInCultures)">
            <summary>Argument is the name of the type in neutral representation and arbitrary translations.</summary>
        </member>
        <member name="M:wx.Globalization.TypeNameTranslationsAttribute.#ctor(System.String,System.String[])">
            <summary>Creates an instance comprising several translations.</summary><remarks>
                     * \param neutralName is the name in the neutral locale.
                     * \param sequenceOfLocaleTranslationPairs is a sequence of an even number of strings. The first is the canonical name, the second is the
                     *    translation of <c>original</c> into the locale according to the first string. The third is the canonical name, the forth is the
                     *    translation of <c>original</c> into the locale according to the third string, and so on.
                     * 
                     * Example:
                     * \code
                     [TypeNameTranslationsAttribute("Employee", "de", "Mitarbeiter")]
                     class EmployeeDate
                     {
                        ...
                     }
                     \endcode
                     * </remarks>
        </member>
        <member name="P:wx.Globalization.TypeNameTranslationsAttribute.Name">
            <summary>Readonly access to the human readable name of the class or type and its translations.</summary>
        </member>
        <member name="T:wx.Globalization.EnumValueTranslationsAttribute">
            <summary>Use this class to amend enumerations with translations of their value.</summary>
                 * <remarks>
                 * These translations will for instance be used by <c>wx.Object._(Enum)</c>.
                 * Example:
                 \code
                 [EnumValueTranslations(80, "Times")]
                 [EnumValueTranslations(81, "Sans Serif")]
                 [EnumValueTranslations(90, "True Type", "de", "Schreibmaschine")]
                 [EnumValueTranslations(91, "Courier", "de", "Kurier")]
                 enum FontFamily
                 {
                    Times=80,
                    SansSerif,
                    TrueType=90,
                    Courier,
                 }
                 \endcode
                 * The translation refers to the enumeration using the value. This class assumes <c>int</c>
                 * values.
                 * </remarks>
        </member>
        <member name="M:wx.Globalization.EnumValueTranslationsAttribute.#ctor(System.Int32,System.String,System.String[])">
            <summary>Defines a neutral name and translations for an enumeration value.</summary>
            <param name="enumIntValue"> designates the enumeration value providing its cast to <c>int</c>. </param>
            <param name="neutral"> is a neutral name that will be used when translating into unknown languages.</param>
            <param name="sequenceOfLocaleTranslationPairs"> is a sequence of pairs of canonical locale names and translations.</param>
        </member>
        <member name="P:wx.Globalization.EnumValueTranslationsAttribute.Name">
            <summary>Readonly access to the human readable name of the class or type and its translations.</summary>
        </member>
        <member name="T:wx.Globalization.POTWriter">
            <summary>
            Class to write POT entries. This class provides a text writer like interface to write 
            POT entries. You may create a file providing a file name to the ctor. This file will be created
            including a POT header in UTF-8 character coding. All internal streams will be closed on
            dispose.
            </summary>
        </member>
        <member name="M:wx.Globalization.POTWriter.#ctor(System.String)">
            <summary>
            Creates an instance that will open a file of the provided name.
            If the extension of the provided name is neither .po nor .pot, this will
            add esxtension .pot.
            </summary>
            <param name="potFileName"></param>
        </member>
        <member name="M:wx.Globalization.POTWriter.WriteHeader">
            <summary>
            This will write the header information.
            </summary>
        </member>
        <member name="M:wx.Globalization.POTWriter.WriteEntry(System.String,System.String,System.String)">
            <summary>
            Creates a new entry. If the provided key has already been used, this will return false.
            </summary>
            <param name="key">The key that will be used to identify the translation.</param>
            <param name="translation">The translation.</param>
            <param name="remark">An optional remark (use empty string if not needed). Provide a text that
            can help translator. This text will be visible in poEdit.</param>
            <returns></returns>
        </member>
        <member name="T:wx.Globalization.ExtractTranslationsOfTypesAndEnumValues">
            <summary>
            Looks for the attributes EnumValueTranslationsAttribute in TypeNameTranslationsAttribute in one
            or more assemblies and creates GetText entries in a POTWriter that can be used to provide translations
            for marked classes and enumeration constants.
            </summary>
        </member>
        <member name="M:wx.Globalization.ExtractTranslationsOfTypesAndEnumValues.ExtractTranslationsOfType(System.Reflection.Assembly)">
            <summary>
            This method will create a POT file using the base name of the code base file of the assembly.
            Thus, translations of wx.PackageBuilder.exe will be stored in ex.PackageBuilder.pot.
            </summary>
            <param name="a"></param>
        </member>
        <member name="T:wx.Html.Help.HtmlBookRecord">
            <summary>Instances of this class represent hyper text books to be read from a file system.
             Refer to class HtmlHelpData.
             Instances of this class shall never be generated by the user.  wx.NET generates
             them if necessary. All instances will be deleted virtually by their containers.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlBookRecord.GetFullPath(wx.wxString)">
            <summary>Returns full filename of <c>page</c> (which is part of the book),
             i.e. with book's <c>BasePath</c> prepended. If page is already absolute
             path, <c>BasePath</c> is  not prepended.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlBookRecord.Title">
            <summary>Get and Set the title.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlBookRecord.Start">
            <summary>Get and set the start.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlBookRecord.BasePath">
            <summary>Get and set the base path.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlBookRecord.ContentsStart">
            <summary>Use SetContentsRange() to set this property.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlBookRecord.ContentsEnd">
            <summary>Use SetContentsRange() to set this property.
            </summary>
        </member>
        <member name="T:wx.Html.Help.IConstList">
            <summary>A simple interface characterizing constant lists.
            This interface IList declares a subset of the methods of IList.</summary>
        </member>
        <member name="T:wx.Html.Help.ConstListIterator">
            <summary>A simple enumerator for read-only instances of IList.
            This simply iterates incrementing an index.</summary>
        </member>
        <member name="T:wx.Html.Help.HtmlBookRecords">
            <summary>This is simply a collection of instance of HtmlBookRecord.
             This is a particular class for some technical reasons.
             Avoid to use empty arrays of this kind.
             
             As wx.HtmlBookRecord, this is a const class that does not allow
             to modify the value.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlBookRecords.#ctor(System.IntPtr)">
            <summary>Instances of this type will typically generated by Object.FindObject().
             Reason: Instances of this class appear as output of a selector of HtmlHelpData.
             
             Although an implementor of IList, this class does not support making changes
             (adding or removing items).
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlBookRecords.HasFile(System.String)">
            <summary>Returns <c>true</c> iff this set of bookmarks contains an entry of the provided file.</summary>
        </member>
        <member name="M:wx.Html.Help.HtmlBookRecords.FindPage(System.String)">
            <summary>Finds the index of the provided page (URL) in the list of bookmarks.
            This will return -1 if the provided page does not have a bookmark.</summary>
        </member>
        <member name="T:wx.Html.Help.HtmlHelpDataItem">
            <summary>Instances of this class are used to represent items of content or index.
             Refer to class HtmlHelpData.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpDataItem.Name">
            <summary>The name of the item.
             Remark on the implementation: This method currently always returns the same instance.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpDataItem.Page">
            <summary>The page containing this item.
             Remark on the implementation: This method currently always returns the same instance.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpDataItem.FullPath">
            <summary>The full path of the page containing this item.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpDataItem.IndentedName">
            <summary>Returns the item's name indented with spaces (if it has level larger than 1, the first level).
            </summary>
        </member>
        <member name="T:wx.Html.Help.HtmlHelpDataItems">
            <summary>This is simply a collection of instance of HtmlHelpDataItem.
             This is a particular class for some technical reasons.
             Avoid to use empty arrays of this kind.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlHelpDataItems.#ctor(System.IntPtr,System.Boolean)">
            <summary>Instances of this type will be copied on generation.
             Although an implementor of IList, this class does not support making changes
             (adding or removing items).
            </summary>
        </member>
        <member name="T:wx.Html.Help.HtmlSearchStatus">
            <summary>State information of a search action.
             Note: This is about searching for pages containing a particular
             text rather than searching a single page.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlSearchStatus.#ctor(wx.Html.Help.HtmlHelpData,System.String,System.Boolean,System.Boolean)">
            <summary>Constructor: Supply HtmlHelpData instance, the keyword and (optionally) the title of the book to search.
             By default, all books are searched.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlSearchStatus.#ctor(wx.Html.Help.HtmlHelpData,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>Constructor: Supply HtmlHelpData instance, the keyword and (optionally) the title of the book to search.
             By default, all books are searched.
            </summary>
        </member>
        <member name="M:wx.Html.Help.HtmlSearchStatus.Search">
            <summary>do the next iteration.</summary>
        </member>
        <member name="T:wx.Html.Help.HtmlHelpData">
            <summary>This class represents the content of a help controller.
             This class is required for all alternative implementations of HTB-browsers (extending HtmlHelpController).
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.Html.Help.HtmlHelpData.SetTempDir(System.String)" ignoriert -->
        <member name="M:wx.Html.Help.HtmlHelpData.AddBook(System.String)">
            <summary>Adds new book. <c>book</c> is the location (filename) of an <c>.htb</c> file (stands for "html book").
            See documentation for details. The  wxWidgets documentation claims <c>book</c> to be
            a URL. Do not take this too serious. This means a URL in the sence of  wxWidget's file
            handlers. Consider the following example running with 2.6.4:
            <list type="bullet">
            <item> <c> @"c:\\directory\file.htb"</c> is not a URL but will work.</item>
            <item> <c> @"file:///directory/file.htb"</c> is a URL but will fail.</item>
            </list>
            Returns success.</summary>
        </member>
        <member name="M:wx.Html.Help.HtmlHelpData.FindPageByName(System.String)">
            <summary>returns URL of page on basis of (file)name</summary>
        </member>
        <member name="M:wx.Html.Help.HtmlHelpData.FindPageById(System.Int32)">
            <summary>returns URL of page on basis of MS id</summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpData.BookRecords">
            <summary>Public read-only property to get an array of descriptors for contained books.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpData.BookRecordsCount">
            <summary>Number of included books.</summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpData.ContentsCount">
            <summary>Number of content items.</summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpData.ContentsArray">
            <summary>Public read-only property to get an array of descriptors for items of the table of contents.
            </summary>
        </member>
        <member name="P:wx.Html.Help.HtmlHelpData.IndexArray">
            <summary>Public read-only property to get an array of descriptors for items of the index.
            </summary>
        </member>
        <member name="T:wx.Cursor">
            <summary>
            A cursor is a small bitmap usually used for denoting where the mouse pointer is, with a picture that
            might indicate the interpretation of a mouse click. As with icons, cursors in X and MS Windows are
            created in a different manner. Therefore, separate cursors will be created for the different
            environments. Platform-specific methods for creating a wxCursor object are catered for, and this
            is an occasion where conditional compilation will probably be required (see wxIcon for an example).
            </summary>
            <remarks>
            A single cursor object may be used in many windows (any subwindow type). The wx.NET convention is to
            set the cursor for a window, as in X, rather than to set it globally as in MS Windows.
            </remarks>
        </member>
        <member name="M:wx.Cursor.SafeNew(System.IntPtr)">
            <summary>
            A CTor that creates a <c>null</c> if the arg is a IntPtr.Zero.
            </summary>
            <param name="arg">Native cursor pointer.</param>
        </member>
        <member name="T:wx.WizardEvent">
            <summary>wx.WizardEvent class represents an event generated by the wizard:
            this event is first sent to the page itself and, if not processed there, goes up the window hierarchy as usual.
            
            \li <c>EVT_WIZARD_PAGE_CHANGED(id</c>, func)  The page has been just changed (this event can not be vetoed).  
            \li <c>EVT_WIZARD_PAGE_CHANGING(id</c>, func)  The page is being changed (this event can be vetoed).  
            \li <c>EVT_WIZARD_CANCEL(id</c>, func)  The user attempted to cancel the wizard (this event may also be vetoed).  
            \li <c>EVT_WIZARD_HELP(id</c>, func)  The wizard help button was pressed.  
            \li <c>EVT_WIZARD_FINISHED(id</c>, func)  The wizard finished button was pressed</summary>
        </member>
        <member name="M:wx.WizardEvent.#ctor(System.IntPtr)">
            <summary>For internal use only.</summary>
        </member>
        <member name="P:wx.WizardEvent.Direction">
            <summary>Return the direction in which the page is changing:
            for <c>EVT_WIZARD_PAGE_CHANGING</c>, return true if we're going forward or false otherwise and for
            <c>EVT_WIZARD_PAGE_CHANGED</c> return true if we came from the previous page and false if we returned from the next one.</summary>
        </member>
        <member name="P:wx.WizardEvent.Page">
            <summary>Returns the wx.WizardPage which was active when this event was generated.</summary>
        </member>
        <member name="F:wx.WindowVariant.wxWINDOW_VARIANT_NORMAL">
            <summary>Normal size</summary>
        </member>
        <member name="F:wx.WindowVariant.wxWINDOW_VARIANT_SMALL">
            <summary>Smaller size (about 25 % smaller than normal)</summary>
        </member>
        <member name="F:wx.WindowVariant.wxWINDOW_VARIANT_MINI">
            <summary>Mini size (about 33 % smaller than normal)</summary>
        </member>
        <member name="F:wx.WindowVariant.wxWINDOW_VARIANT_LARGE">
            <summary>Large size (about 25 % larger than normal)</summary>
        </member>
        <member name="T:wx.BackgroundStyle">
            <summary>The background style indicates whether background colour
            should be determined by the system (wxBG_STYLE_SYSTEM),
            be set to a specific colour (wxBG_STYLE_COLOUR),
            or should be left to the application to implement (wxBG_STYLE_CUSTOM).</summary>
        </member>
        <member name="M:wx.Utils.Exit">
            <summary>Exits application after calling wx.App.OnExit().
            Should only be used in an emergency: normally the top-level frame should be deleted (after deleting all
            other frames) to terminate the application. See wx.CloseEvent and wx.App.</summary>
        </member>
        <member name="M:wx.Utils.wxSleep(System.Int32)">
            <summary>
            Sleeps for the specified number of seconds.
            This is deprecated. Use System.Threading.Thread.Sleep() instead.
            </summary>
            <param name="num">Number of seconds to sleep.</param>
        </member>
        <member name="M:wx.Utils.wxYield">
             <summary>
             Calls wx.App.Yield.
            
             This function is kept only for backwards compatibility. Please use the wx.App.Yield method instead in any new code.
             </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "T:wx.BusyInfo" ignoriert -->
        <member name="T:wx.DirSelector">
            <summary>
             Pops up a directory selector dialog. The arguments have the same meaning as those of wx.DirDialog.DirDialog().
             The message is displayed at the top, and the default_path, if specified, is set as the initial selection.
            
             The application must check for an empty return value (if the user pressed Cancel).
            
             </summary>
             <remarks>
              For example:
             <code>
             string dir = new wx.DirSelector("Choose a folder").Value;
             if ( !dir.empty() )
             {
               ...
             }
             </code>
             </remarks>
        </member>
        <member name="M:wx.DirSelector.#ctor">
            <summary>
            Starts an instance with message string _("Select a file").
            </summary>
        </member>
        <member name="M:wx.DirSelector.#ctor(System.String)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
        </member>
        <member name="M:wx.DirSelector.#ctor(System.String,System.String)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
        </member>
        <member name="M:wx.DirSelector.#ctor(System.String,System.String,wx.WindowStyles)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="message">Message string</param>
            <param name="flags">The window styles</param>
        </member>
        <member name="M:wx.DirSelector.#ctor(System.String,System.String,wx.WindowStyles,wx.Window)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.DirSelector.#ctor(System.String,System.String,wx.WindowStyles,wx.Window,System.Drawing.Point)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
        </member>
        <member name="M:wx.DirSelector.#ctor(wx.wxString,wx.wxString,wx.WindowStyles,wx.Window,System.Int32,System.Int32)">
            <summary>
            Selects a directory displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Starts with this directory. This directory shall exist.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="x">The x-coordinate of this dialog</param>
            <param name="y">The y-coordinate of this dialog</param>
        </member>
        <member name="P:wx.DirSelector.Value">
            <summary>
            the selected file or the empty string if the user cancelled the input.
            This, use something like the following to deal with cancelations.
            <code>
            string result=new DirSelector(..).Value;
            if (result.Length == 0)
                return; // cancelled input.
            </code>
            </summary>
        </member>
        <member name="T:wx.FileSelector">
            <summary>Asks for a file name opening a file selector dialog.
             Especially relevant flags (on wx.WindowStyles) start with prefix FD_.
             </summary>
             <remarks>
             Pops up a file selector box. In Windows, this is the common file selector dialog. In X, this is a file selector
             box with the same functionality. The path and filename are distinct elements of a full file pathname. If path
             is empty, the current directory will be used. If filename is empty, no default filename will be supplied.
             The wildcard determines what files are displayed in the file selector, and file extension supplies a type extension
             for the required filename. Flags may be a combination of wx.WindowStyles.FD_OPEN, wx.WindowStyles.FD_SAVE,
             wx.WindowStyles.FD_OVERWRITE_PROMPT, or wx.WindowStyles.FD_FILE_MUST_EXIST. Note that .wx.WindowStyles.FD_MULTIPLE
             can only be used with wx.FileDialog and not here as this function only returns a single file name.
            
             Both the Unix and Windows versions implement a wildcard filter. Typing a filename containing wildcards (*, ?) in 
             the filename text item, and clicking on Ok, will result in only those files matching the pattern being displayed.
            
             The wildcard may be a specification for multiple types of file with a description for each, such as:
             <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.
            
             The application must check for an empty return value (the user pressed Cancel). For example:
             <code>
             wxString filename = wxFileSelector("Choose a file to open");
             if ( !filename.empty() )
             {
                 // work with the file
                 ...
             }
             //else: cancelled by user
             </code>
             </remarks>
             <seealso cref="T:wx.DirSelector"/>
        </member>
        <member name="M:wx.FileSelector.#ctor">
            <summary>
            Starts an instance with message string _("Select a file").
            </summary>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles,wx.Window)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles,wx.Window,System.Drawing.Point)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
        </member>
        <member name="M:wx.FileSelector.#ctor(wx.wxString,wx.wxString,wx.wxString,wx.wxString,wx.wxString,wx.WindowStyles,wx.Window,System.Int32,System.Int32)">
            <summary>
            Selects a file displaying the provided message.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="x">The x-coordinate of this dialog</param>
            <param name="y">The y-coordinate of this dialog</param>
        </member>
        <member name="M:wx.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:wx.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:wx.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles,wx.Window)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="M:wx.FileSelector.ShowModal(System.String,System.String,System.String,System.String,System.String,wx.WindowStyles,wx.Window,System.Drawing.Point)">
            <summary>
            Returns a file that has been selected by the user.
            </summary>
            <param name="message">Message string</param>
            <param name="default_path">Displays files in this path first</param>
            <param name="default_filename">The default filename</param>
            <param name="default_extension">The default extension of the searched files</param>
            <param name="wildcard">Determines which files will be displayed. Example: <c>"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"</c>.</param>
            <param name="flags">The window styles</param>
            <param name="parent">The parent window</param>
            <param name="position">The position of this dialog</param>
            <returns>The path to the selected file. The result will be empty if the user cancelled the dialog.</returns>
        </member>
        <member name="P:wx.FileSelector.Value">
            <summary>
            the selected file or the empty string if the user cancelled the input.
            This, use something like the following to deal with cancelations.
            <code>
            string result=fileselector.Value;
            if (result.Length == 0)
                return; // cancelled input.
            </code>
            </summary>
        </member>
        <member name="T:wx.ByteBuffer">
            <summary>This is an internal class representing a byte buffer.
             This class is applied sometimes when <c>wxWidgets</c> expects a void* buffer.
            </summary>
        </member>
        <member name="M:wx.ByteBuffer.#ctor(System.Int32)">
            <summary>Generates an instance capable of holding at most <c>size</c> bytes.
            </summary>
        </member>
        <member name="M:wx.ByteBuffer.#ctor(System.IntPtr,wx.Object.StorageMode,System.Boolean)">
            <summary>This is a CTor where callers can set memOwn. 
            This is for the construction of temporarily needed wrappers.
            </summary>
        </member>
        <member name="M:wx.ByteBuffer.SafeNew(System.Byte[])">
            <summary>Creates an instance copying the data from <c>bytes</c> or resturns <c>null</c> in case of argument <c>null</c>.
            </summary>
        </member>
        <member name="P:wx.ByteBuffer.Item(System.Int32)">
            <summary>Generates the filled byte at the provided index or 0 if the index is too large.</summary>
        </member>
        <member name="P:wx.ByteBuffer.SizeReserved">
            <summary>This is the number of bytes that can be stored within this index.</summary>
        </member>
        <member name="P:wx.ByteBuffer.SizeFilled">
            <summary>This is the number of bytes that have been written into this instance.</summary>
        </member>
        <member name="P:wx.ByteBuffer.PtrToBuffer">
            <summary>Returns a pointer to the internally represented <c>char</c>[] buffer.
            Please note, that this buffer is not terminated by a 0.</summary>
        </member>
        <member name="T:wx.ArrayInt">
            <summary>Wrapper around the  wxWidgets array of integer numbers.</summary>
        </member>
        <member name="M:wx.ArrayInt.SafeNew(System.IntPtr)">
            <summary>Creates a new ArrayInt. However, if <c>ptr</c> is <c>IntPtr.Zer</c>, then the result is <c>null</c>.</summary>
        </member>
        <member name="T:wx.ArrayIntPtr">
            <summary>This is a wrapper for a simple <c>void**</c> array.
            This will be used for instance to pass client data to choice dialogs.</summary>
        </member>
        <member name="T:wx.ArrayString">
            <summary>A wrapper for  wxWidgets arrays of string.
            This is used for internal purposes. However, just like wxString this has been
            left public to allow extreme non-functional optimizations reducing conversions
            between arrays of .NET strings and this.</summary>
        </member>
        <member name="M:wx.ArrayString.#ctor(System.Collections.IEnumerable)">
            <summary>Generates an instance comprising the items of the argument.
            All items of the argument shall be strings. Otherwise, this method
            will throw an dynamic type error.
            The argument may also be <c>null</c>. In this case, this is equivalent to
            the default constructor (generate an instance of size 0).</summary>
        </member>
        <member name="M:wx.ArrayString.SafeNewFrom(System.Collections.IEnumerable)">
            <summary>This is a safe alternative for the corresponding CTor.
            Safe means here: If the argument is <c>null</c>, the result is also <c>null</c> without
            any exceptions.</summary>
        </member>
        <member name="M:wx.ArrayString.Sort(System.Boolean)">
            <summary>Sorts the entry (optionally in reversed order).
            </summary>
        </member>
        <member name="M:wx.ArrayString.Add(System.Collections.IEnumerable)">
            <summary>This will add the elements of the collection.
             This will throw an exception of the collection contains non-strings.
            </summary>
        </member>
        <member name="M:wx.ArrayString.Index(System.String)">
            <summary>This will return the first index of string <c>lookForThisEntry</c> or -1 is this string is not in the array.</summary>
        </member>
        <member name="M:wx.ArrayString.Index(wx.wxString,System.Boolean,System.Boolean)">
            <summary>Search the element in the array, starting from the beginning if <c>bFromEnd</c> is false or from end otherwise.
             If <c>bCase</c>, comparison is case sensitive (default), otherwise the case is ignored.
            
             This function uses linear search for <c>ArrayString</c> and binary search for <c>SortedArrayString</c>,
             but it ignores the <c>bCase</c> and <c>bFromEnd</c> parameters in the latter case.
            
             Returns index of the first item matched or -1 if there is no match.
            </summary>
        </member>
        <member name="P:wx.ArrayString.Item(System.Int32)">
            <summary>Access string <c>num</c> of the array.
             Will cause an assert error on illegal indices.
            </summary>
        </member>
        <member name="T:wx.wxSize">
            <summary>This will produce or wrap a <c>wxSize</c> object.
            Use instances of this class, to pass <c>wxSize</c> objects to the C DLL.</summary>
        </member>
        <member name="M:wx.wxSize.#ctor(System.Drawing.Size)">
            <summary>Convert an instance from a C# standard size.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:wx.wxSize.SafeNew(System.Drawing.Size)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:wx.wxRect">
            <summary>This will produce or wrap instances of  wxWidgets <c>wxRect</c>.
            Never use <c>System.Drawing.Rectangle</c> with <c>wx-c.dll</c>. Always rely to instances of this class instead.
            </summary>
        </member>
        <member name="M:wx.wxRect.#ctor(System.Drawing.Rectangle)">
            <summary>Convert an instance from a C# standard rectangle.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:wx.wxRect.SafeNew(System.Drawing.Rectangle)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:wx.wxPoint">
            <summary>This will produce or wrap instances of  wxWidgets <c>wxPoint</c>.
            Never use <c>System.Drawing.Point</c> with <c>wx-c.dll</c>. Always rely to instances of this class instead.
            </summary>
        </member>
        <member name="M:wx.wxPoint.#ctor(System.Drawing.Point)">
            <summary>Convert an instance from a C# standard rectangle.
            This will throw an exception on a <c>null</c> argument. You may use SafeNew() instead.</summary>
        </member>
        <member name="M:wx.wxPoint.SafeNew(System.Drawing.Point)">
            <summary>This will generate an instance from a C# standard rectangle without throwing exception on a <c>null</c> argument.
            In that case this will also return a <c>null</c>.</summary>
        </member>
        <member name="T:wx.StatusBar">
            <summary>Class for the status bar.
            Style flags (cf. wx.WindowStyles) of static  texts (starting with ST_) and status bars
            (starting with SB_) apply to this class of windows.</summary>
        </member>
        <member name="T:wx.Language">
            <summary>
            Enumeration of langiages.
            </summary>
        </member>
        <member name="F:wx.Language.wxLANGUAGE_DEFAULT">
            <summary>
            user's default language as obtained from the operating system 
            </summary>
        </member>
        <member name="F:wx.Language.wxLANGUAGE_UNKNOWN">
            <summary>
            returned by Locale.GetSystemLanguage() if it fails to detect the default language 
            </summary>
        </member>
        <member name="T:wx.LocaleInitFlags">
            <summary>Flags for initializing instances of Locale.
            Please note that wxLOCALE_CONV_ENCODING() shall be avoided on unicode builds.</summary>
            
        </member>
        <member name="F:wx.LocaleInitFlags.wxLOCALE_LOAD_DEFAULT">
            <summary>Load the message catalog for the given locale containing the translations of standard wxWidgets messages automatically.</summary>
        </member>
        <member name="F:wx.LocaleInitFlags.wxLOCALE_CONV_ENCODING">
            <summary>This will cause wxWidgets to convert all imported
            catalogs into the current standard encoding (like western-1259-1).
            Since this is always wrong on unicode builds, this flag will silently
            be ignored then.</summary>
        </member>
        <member name="T:wx.Locale">
            <summary>This class wrapps <c>wxLocale</c>.</summary>
        </member>
        <member name="M:wx.Locale.Init">
            <summary>
            Initializes this locale with the users default language as obtained from the operating system.
            </summary>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:wx.Locale.Init(wx.Language)">
            <summary>
            Initializes this locale with the provided language.
            </summary>
            <param name="language">Language to be used for translation.</param>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:wx.Locale.Init(wx.Language,wx.LocaleInitFlags)">
            <summary>
            Initializes this locale with the provided language.
            </summary>
            <param name="language">Language to be used for translation.</param>
            <param name="flags">Flags</param>
            <returns>True on success and false if the locale has not been set.</returns>
        </member>
        <member name="M:wx.Locale.AddCatalog(System.String)">
            <summary>Add a catalog for use with the current locale: it is searched for in standard places
             (current directory first, then the system one), but you may also prepend additional directories
             to the search path with AddCatalogLookupPathPrefix().</summary>
             <remarks> All loaded catalogs will be used for message lookup by GetString() for the current locale.
            
             Returns true if catalog was successfully loaded, false otherwise (which might mean that the catalog is not
             found or that it isn't in the correct format).
             </remarks>
             <param name="szDomain">Descriptor of the domain that is covered by the requested catalog, i.e. the basename
              of the catalog file.</param>
        </member>
        <member name="M:wx.Locale.AddCatalog(System.String,wx.Language,System.String)">
            <summary>Add a catalog for use with the current locale: it is searched for in standard places
             (current directory first, then the system one), but you may also prepend additional directories
             to the search path with AddCatalogLookupPathPrefix().</summary>
             <remarks> All loaded catalogs will be used for message lookup by GetString() for the current locale.
            
             Returns true if catalog was successfully loaded, false otherwise (which might mean that the catalog is not
             found or that it isn't in the correct format).
             </remarks>
             <param name="szDomain">Descriptor of the domain that is covered by the requested catalog, i.e. the basename
              of the catalog file.</param>
              <param name="msgIdLanguage">The target language of translations from this catalog.</param>
              <param name="msgIdCharset">msgIdCharset lets you specify the charset used for msgids in sources in case they use
              8-bit characters (e.g. German or French strings). This argument has no effect in Unicode build, because literals
              in sources are Unicode strings; you have to use compiler-specific method of setting the right charset when
              compiling with Unicode.</param>
        </member>
        <member name="M:wx.Locale.AddCatalogLookupPathPrefix(System.String)">
             <summary>
             Add a prefix to the catalog lookup path: the message catalog files will be looked up under
             prefix/(CANONICAL_LANGUAGE_STRING)/LC_MESSAGES, prefix/(CANONICAL_LANGUAGE_STRING) and prefix (in this order).
            
             This only applies to subsequent invocations of AddCatalog().
             </summary>
             <param name="prefix">New prefix directories where to search for language catalogs.</param>
        </member>
        <member name="M:wx.Locale.GetLanguageInfo(wx.Language)">
            <summary>
            Information struct on the language as designated by the argument.
            </summary>
            <param name="lang">The language designator. Language.wxLANGUAGE_DEFAULT will
            be replaced by the system language.
            </param>
            <returns>Language information</returns>
        </member>
        <member name="M:wx.Locale.GetLanguageName(wx.Language)">
            <summary>
            Long name of the language as designated by the argument (e.g. "German").
            </summary>
            <param name="lang">The language designator. Language.wxLANGUAGE_DEFAULT will
            be replaced by the system language.
            </param>
            <returns>Language information</returns>
        </member>
        <member name="P:wx.Locale.CanonicalName">
            <summary>
            Canonical name of the language that is used by this locale. Examples: "en", "de-de".
            </summary>
        </member>
        <member name="P:wx.Locale.SystemEncodingName">
             <summary>
             Tries to detect the name of the user's default font encoding.
             This string isn't particularly useful for the application as its form is platform-dependent and so you
             should probably use GetSystemEncoding() instead.
            
             Returns a user-readable string value or an empty string if it couldn't be determined.
             </summary>
        </member>
        <member name="P:wx.Locale.SystemLanguage">
            <summary>
            Tries to detect the user's default language setting.
            Returns wxLanguage.LANGUAGE_UNKNOWN if the language-guessing algorithm failed.
            </summary>
        </member>
        <member name="T:wx.Graph.View.INodeAppearance">
            <summary>
            Implementors of this interface provide the data that will be used to display graph nodes.
            </summary>
        </member>
        <member name="M:wx.Graph.View.INodeAppearance.GetSize(wx.DC,wx.ImageList)">
            <summary>
            The size of the node. 
            Layout algorithms will reserve free space of this size.
            </summary>
            <param name="dc">The device context that shall display the node. Use this context to determine
            text sizes.</param>
            <param name="images">The list of images that is available to display nodes. This can be <c>null</c> if not available.</param>
            <returns></returns>
        </member>
        <member name="M:wx.Graph.View.INodeAppearance.Draw(wx.DC,wx.ImageList,System.Drawing.Point)">
            <summary>
            This will be called to draw the node.
            </summary>
            <param name="dc">The device context that shall display the node</param>
            <param name="pos">The upper left position of the free space that has been reserved by the layout algorithm.</param>
            <param name="images">The list of images that is available to display nodes. This can be <c>null</c> if not available.</param>
        </member>
        <member name="M:wx.Graph.View.INodeAppearance.GetDockingPoints(System.Drawing.Point)">
            <summary>
            If drawn by Draw() at the provided position, this returns a collection of positions that can be used
            as start or end of drawn edges.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="E:wx.Graph.View.INodeAppearance.OnChange">
            <summary>
            Call this if something changed. The graph views will update
            the display of this node.
            </summary>
        </member>
        <member name="T:wx.Graph.View.LabelledNode">
            <summary>
            Use In
            </summary>
        </member>
        <member name="M:wx.Graph.View.LabelledNode.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new instance that will display the provided text label.
            </summary>
            <param name="label">The text label that shall be displayed</param>
        </member>
        <member name="M:wx.Graph.View.LabelledNode.#ctor(System.String,System.Int32,wx.Direction)">
            <summary>
            Creates a new instance that will display a text label and an image from an image list.
            </summary>
            <param name="label">The text label. If this is empty, the node will be </param>
            <param name="imageIndex">The index of the image that shall be displayed.</param>
            <param name="direction">The direction defines, whether the label shall be displayd above, below, on the left, or on the right side of the image.</param>
        </member>
        <member name="M:wx.Graph.View.LabelledNode.GetDockingPoints(System.Drawing.Point)">
            <summary>
            If drawn by Draw() at the provided position, this returns a collection of positions that can be used
            as start or end of drawn edges.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.Label">
            <summary>
            Get or set the label.
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.ImageIndex">
            <summary>
            Get or set the index of the image that shall be displayed. If this is -1, no image will be displayed.
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.DrawBorderBox">
            <summary>
            Set or get a Boolean flag that is true iff the graph node shall be surrounded by a box.
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.Padding">
            <summary>
            Defines a number of pixels that shall be left blank between image and label (if both are given) and between
            image and label and the surrounding box (if one shall be drawn),
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.Direction">
            <summary>
            This direction defines the position of the text label relatively to the image.
            If this is Direction.wxUP, the text label will be directly above the image.
            If this is Direction.wxDOWN, the text label will be directly below the image.
            If the direction is Direction.wxLEFT or Direction.wxRIGHT, the text label will
            be on the left side of the image, or right side respectively. If the label is
            left and up, the label will be positioned relatively to the upper left corner of
            the image. The other directions are accordingly. In case of Direction.wxALL, 
            the text will be positioned in the center of the image.
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.Foreground">
            <summary>
            The foreground/text colour that will be used to draw the node label.
            If you assign a colour to this, please note: The assigned instance will get readonly.
            </summary>
        </member>
        <member name="P:wx.Graph.View.LabelledNode.Background">
            <summary>
            The background colour that will be used to draw the node. this can be <c>null</c>.
            In that case, the background will be filly transparent.
            If you assign a colour to this, please note: The assigned instance will get readonly.
            </summary>
        </member>
        <member name="T:wx.Graph.View.LayoutedNode">
            <summary>
            Associates a node appearance with a position.
            Instances of this class implement the data of the nodes of the
            classes LayoutedDAG and LayoutedTree.
            </summary>
        </member>
        <member name="T:wx.Graph.View.LayoutedTree">
            <summary>
            This class implements a tree layout.
            </summary>
        </member>
        <member name="T:wx.Graph.View.LayoutedDAG">
            <summary>
            This class implements a layout for directed acyclic graphs.
            The layout is specialized on acyclic graphs but will also display
            graphs with cycles. However, there should not be too many cycles to
            make this algorithm work.
            </summary>
        </member>
        <member name="T:wx.Font">
            <summary>
            The wx font model.
            </summary>
            <remarks>
            \image html fontsmall.png
            </remarks>
        </member>
        <member name="M:wx.Font.#ctor(wx.Font)">
            <summary>Copy CTor.</summary>
        </member>
        <member name="M:wx.Font.ToString">
            <summary>This shows face name and point size.</summary>
        </member>
        <member name="P:wx.Font.TheFontList">
            <summary>Returns <c>wx.FontList.TheFontList</c>.
            </summary>
        </member>
        <member name="T:wx.FileSys.wxInputStreamWrapper">
            <summary>Analogously to class wxString, this class wraps wxInputStream.
             Anatomy: This inherits from wx.Object and is, thus, a wx.NET wrapper class.
             Constructors either are required by wx.Object to implement the FindObject service
             or they pass a System.IO.Stream. This instance then serves as a wxWidgets fassade
             to the stream that you originally provided. On instance creation, this instance
             sets callback to implement a wxInputStream using the framework stream as source.
             
             However, instances of this class may occur in another state: Without a framework
             stream as source. In that case, the instance simply wrapps a fully functional
             wxWidgets input stream without setting callbacks.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStreamWrapper.#ctor(System.IO.Stream)">
            <summary>Generates a new  wxWidgets <c>wxInputStream</c> instance whose basic functions refer to methods of <c>src</c>.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStreamWrapper.#ctor(System.IntPtr)">
            <summary>Generates an instance wrapping a fully functional  wxWidgets <c>wxInputStream</c>.</summary>
        </member>
        <member name="M:wx.FileSys.wxInputStreamWrapper.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStreamWrapper.LastReadFromSrc">
            \name Implementations of Delegates
        </member>
        <member name="M:wx.FileSys.wxInputStreamWrapper.GetLength">
            <summary>In contrast to property Length this does not throw exceptions but returns -1.
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStreamWrapper.Src">
            <summary>This is the C# stream that is used as data source.
             Depending of the mode of this implementation this may either be a standard System.IO.Stream
             providing data for an internal <c>wxInputStream</c> or an instance of class wxInputStream
             wrapping a  wxWidgets input stream.
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStreamWrapper.CanSeek">
            <summary>This returns whether a seek operation failed in the past or the wrapped stream does not provide a current position.</summary>
        </member>
        <member name="P:wx.FileSys.wxInputStreamWrapper.Length">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStreamWrapper.Position">
            <summary>This will throw an <c>NotSupportedException</c> iff the wrapped <c>wxInputStream</c> does not support the analogous operation.
            </summary>
        </member>
        <member name="T:wx.FileSys.wxInputStream">
            <summary>This is a .NET framework stream wrapping a  wxWidgets <c>wxInputStream</c>.
             The wrapper of a <c>wxInputStream</c> falls into 2 parts. This is the instance that directly
             inherits from Stream and, thus, provides a fassades compliant to the standard .NET framework.
             Class <c>wxInputStreamWrapper</c> inherits from <c>wx.Object</c> instead and wrapps the pointer
             to a  wxWidgets stream.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStream.#ctor(System.IntPtr)">
            <summary>Receives an IntPtr to a <c>wxInputStream</c>.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStream.SetLength(System.Int64)">
            <summary>This is not supported.
            </summary>
        </member>
        <member name="M:wx.FileSys.wxInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>This is not implemented.
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStream.CanSeek">
            <summary>Tests whether this can tell and
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStream.CanWrite">
            <summary>This is false.</summary>
        </member>
        <member name="P:wx.FileSys.wxInputStream.Length">
            <summary>This typically returns the length of the stream in position units.
            </summary>
        </member>
        <member name="P:wx.FileSys.wxInputStream.Position">
            <summary>This is supported if the source supports <c>TellI</c> and <c>SeekI</c>.
            </summary>
        </member>
        <member name="T:wx.FileSys.FSFile">
            <summary>This is a wrapper to <c>wxFSFile</c>.
             Purpose: Provide some additional information on a file read through
             the <c>wxWidgets</c> file system. Unfortunately, the known characteristics of a <c>wxWidgets</c> file
             differ strongly from the <c>FileInfo</c> class: Instances of this class know s stream
            </summary>
        </member>
        <member name="M:wx.FileSys.FSFile.#ctor(System.IntPtr)">
            <summary>This CTor receives an IntPtr of a <c>wxFSFile</c>.
            </summary>
        </member>
        <member name="M:wx.FileSys.FSFile.#ctor(wx.FileSys.wxInputStreamWrapper,System.String,System.String,System.String,System.DateTime)">
            <summary>This creates a file descriptor reading content from the provided stream.
            Please note, that this will try to take ownership of the <c>wxObject</c> of <c>streamWrapper</c>.
            This will raise an exception, if this operation fails.</summary>
        </member>
        <member name="M:wx.FileSys.FSFile.#ctor(System.IO.Stream,System.String,System.String,System.String,System.DateTime)">
            <summary>This creates a file descriptor reading content from the provided stream.</summary>
        </member>
        <member name="M:wx.FileSys.FSFile.ToString">
            <summary>A comprehensable text description of this file.
            </summary>
        </member>
        <member name="P:wx.FileSys.FSFile.Anchor">
            <summary>The "anchor" part of a hyper link.
             Refer to the  wxWidgets documentation for details.
            </summary>
        </member>
        <member name="P:wx.FileSys.FSFile.Location">
            <summary>The "location" of the source of the stream data.</summary><remarks>
                     * This is the full location description of the file, e.g.
                     * \verbatim
                     http://www.wxwidgets.org
                     http://www.ms.mff.cuni.cz/~vsla8348/wxhtml/archive.zip#zip:info.txt
                     file:/home/vasek/index.htm
                     relative-file.htm
                     \endverbatim
                     *</remarks>
        </member>
        <member name="P:wx.FileSys.FSFile.MimeType">
            <summary>The mime type description (in text form).</summary>
        </member>
        <member name="P:wx.FileSys.FSFile.Stream">
            <summary>A stream for receiving the data.
            </summary>
        </member>
        <member name="F:wx.FileSys.KindOfFile.Indifferent">
            <summary>Either a directory or usual data file, I don't mind.
            </summary>
        </member>
        <member name="F:wx.FileSys.KindOfFile.wxFILE">
            <summary>Operate on data files only.</summary>
        </member>
        <member name="F:wx.FileSys.KindOfFile.wxDIR">
            <summary>Operate on directories only.</summary>
        </member>
        <member name="T:wx.FileSys.FileSystemHandler">
            <summary>This class wrapps  wxWidgets class <c>wxFileSystemHandler</c> and all inheritors.
             Investigate the documetnation of subclasses for details on predefined file system
             handlers. For instance class IOStreamFSHandler enables the implementation of  wxWidgets
             file system handlers as streams of the .NET framework.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.OpenFile(wx.FileSys.FileSystem,System.String)">
            <summary>Returns an instance of FSFile that provides a stream over the data as denoted by <c>location</c>.
             \param location absolute location of the desired data.
             \param fs is the parent file system. This parameter still exists maybe because of historical reasons.
             The manual 2.6.3. refers to <c>wxZipFSHandler</c> as a reference for using this parameter but this
             class in the meanwhile explicitely refers to a freshly created file system to avoid infinite recursions
             (as the remark says).
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.CanOpen(System.String)">
            <summary>The handler identifies himself with result <c>true</c> to be appropriate to deal with a file at the provided location.</summary><remarks>
                     * Example: A handler for the HTTP protocol over the internet could answer here with
                     * \code
                     return this.GetProtocol(location) == "http";
                     \endcode
                     * 
                     * Please note, that this method should also work with the allowed wildcards, since this method
                     * also works as a filter for FindFirst().
                     *</remarks>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.FindFirst(System.String,wx.FileSys.KindOfFile)">
            <summary>Returns the first matching filename or an empty string if nothing matches.
             This will only be called if the <c>wildcard</c> can be opened (CanOpen()).
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.FindNext">
            <summary>Returns the next filename matching with the constraints of the previous FindFirst() or an empty string if nothing matches.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.GetAnchor(System.String)">
            <summary>Returns the anchor if present in the location.
             Example:
             <code>
             GetAnchor("index.htm#chapter2") == "chapter2"
             </code>
            
             Note: the anchor is NOT part of the left location.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.GetProtocol(System.String)">
            <summary>Returns the protocol string extracted from location. 
                      * <code>Example: GetProtocol("file:myzipfile.zip#zip:index.htm") == "zip"</code>
                     *</summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.GetLeftLocation(System.String)">
            <summary>Returns the left location string extracted from location. 
             Example:
             <code>
             GetLeftLocation("file:myzipfile.zip#zip:index.htm") == "file:myzipfile.zip"
             </code>
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:wx.FileSys.FileSystemHandler.GetRightLocation(System.String)" ignoriert -->
        <member name="M:wx.FileSys.FileSystemHandler.GetMimeTypeFromExt(System.String)">
            <summary>Returns the MIME type based on extension of location.
             (While FSFile.MimeType returns real MIME type - either extension-based or queried
             from HTTP.) However, particular handlers may use this to generate an FSFile of 
             an appropriate mime type if nothing particular is known on such things.
            
             Example : 
             <code>
             this.GetMimeTypeFromExt("index.htm") == "text/html"
             </code>
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystemHandler.MimeTypeFromExt(System.String)">
            <summary>A static public version of GetMimeTypeFromExt() running on a particular, transparently generated instance.
             This method may be changed in order to add some support for additional types.
            </summary>
        </member>
        <member name="T:wx.FileSys.FileSystem">
            <summary>This wrapps <c>wxFileSystem</c> but concentrates on the methods that are not already implemented in the .NET framework.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.#ctor">
            <summary>The  wxWidgets file system uses instances created by the default constructor as handles for accessing files systems of various types through something like an URL.
             File system are implemented by a handler (refer to class FileSystemHandler). This wrapper to the .NET framework also
             allows file system handlers to be written in C# or another CRL language.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.AddHandler(wx.FileSys.FileSystemHandler)">
            <summary>Adds the provided instance as a handler to the handler list.
             Refer for instance to <c>MemoryFSHandler</c> for a wrapper to a standard
              wxWidgets resource handler. Note, that all inheritors of FileSystemHandler may
             be used here.
            
             The native object wrapped by <c>handler</c> will be owned by the singleton managing file system handlers.
             This will raise an exception, if te handler instance is already shared by another object.
             
             Please refer also to CleanUpHandlers().
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.CleanUpHandlers">
            <summary>Clean up all installed file handlers.
             Calling this method is unfortunately necessary on shutting down applications
             installing some kinds of file system handlers by using AddHandler(). The reason
             is:  wxWidgets will delete the C++ instances of installed file system handlers
             on shutting down. However,  wxWidgets can of course not delete the corresponding
             .NET instances. These may also try to delete C++ instances on being disposed. So,
             we will likely to get access violations.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.ChangePathTo(System.String,System.Boolean)">
            <summary>Sets the current location.</summary><remarks>
                     * <c>location</c> parameter passed to OpenFile is relative to this path.
                     * \b Caution!
                     * Unless <c>is_dir</c> is true the location parameter is not the directory name but
                     * the name of the file in this directory. All these commands change the path to
                     * "dir/subdir/":
                     * \code
                    FileSystem fs=new FileSystem();
                    fs.ChangePathTo("dir/subdir/xh.htm");
                    fs.ChangePathTo("dir/subdir", true);
                    fs.ChangePathTo("dir/subdir/", true);
                    \endcode
                    * \param location the new location. Its meaning depends on the value of <c>is_dir</c>
                    * \param is_dir if <c>true</c> location is new directory. If false (default) location
                    *  is file in the new directory.
                    *
                    * Example:
                    \code
              f = fs -> OpenFile("hello.htm"); // opens file 'hello.htm'
              fs -> ChangePathTo("subdir/folder", true);
              f = fs -> OpenFile("hello.htm"); // opens file 'subdir/folder/hello.htm' !!
                   \endcode
                     *</remarks>
        </member>
        <member name="M:wx.FileSys.FileSystem.FindFirst(System.String,wx.FileSys.KindOfFile)">
            <summary>Returns name of the first filename (within filesystem's current path) that matches wildcard.
              <c>flags</c> may be one of KindOfFile.wxFILE (only files), KindOfFile.wxDIR (only directories)
             or KindOfFile.Indifferent (both).
             
             Returns filename or empty string if no more matching file exists.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.FindNext">
            <summary>Finds the next filename matching constraints of the previous FindFirst().
             Returns filename or empty string if no more matching file exists.
            </summary>
        </member>
        <member name="M:wx.FileSys.FileSystem.OpenFile(System.String)">
            <summary>Opens the file and returns a <c>FSFile</c> object or <c>null</c> if failed.
             It first tries to open the file in relative scope (based on value passed to
             ChangePathTo() method) and then as an absolute path.
            </summary>
        </member>
        <member name="P:wx.FileSys.FileSystem.Path">
            <summary>Returns the path according to ChangePathTo().
             Setting this value is synonym to ChangePathTo(). 
            </summary>
        </member>
        <member name="T:wx.FileSys.ZipFSHandler">
            <summary>A wrapper to <c>wxZipFSHandler</c>. 
            This is a handler for FileSystem that can deal with Zip archives.
            In contrast to most other handlers, this one uses first and second part locations where
            the first part describes the archive file and the second part describes the archived file.
            </summary>
            <remarks>
            Example: 
            <code>
            "file:ZipFile.zip#anHTMLIndex.htm#aChapterInThisIndex"
            </code>
            </remarks>
        </member>
        <member name="M:wx.FileSys.ZipFSHandler.#ctor">
            <summary>
            Creates a handler of a file system that can deal with Zip archives.
            In contrast to most other handlers, this one uses first and second part locations where
            the first part describes the archive file and the second part describes the archived file.
            </summary>
        </member>
        <member name="T:wx.FileSys.InternetFSHandler">
            <summary>A wrapper to <c>wxInternetFSHandler</c>.
             Instances of this class provide a handler for FileSystem to deal with FTP and HTTP files.
            </summary>
        </member>
        <member name="T:wx.FileSys.MemoryFSHandler">
            <summary>This FileSystem handler can store arbitrary data in memory stream and make them
             accessible via URL. It is particularly suitable for storing bitmaps from resources
             or included XPM files so that they can be used with wx.HTML.
            
             Filenames are prefixed with <c> "memory:"</c>, e.g. <c>"memory:myfile.html"</c>.
            </summary>
        </member>
        <member name="M:wx.FileSys.MemoryFSHandler.Add(System.String,wx.Image,wx.BitmapType)">
            <summary>Adds an image as a file of the specified type.
             Please note, that the type argument shall be something like 
             <c>wx.BitmapType.wxBITMAP_TYPE_PNG</c> that  wxWidgets can save.
            </summary>
        </member>
        <member name="M:wx.FileSys.MemoryFSHandler.Add(System.String,wx.Bitmap,wx.BitmapType)">
            <summary>Adds an image as a file of the specified type.
             Please note, that the type argument shall be something like 
             <c>wx.BitmapType.wxBITMAP_TYPE_PNG</c> that  wxWidgets can save.
            </summary>
        </member>
        <member name="T:wx.FileSys.IOStreamFSHandler">
            <summary>Class of  wxWidgets file system handlers that are implemented by a <c>System.IO.Stream</c>. 
            Generate an instance of this class and install this (call FileSystemHandler.AddHandler)
            to provide the ability to deal with the following protocols:
            <list type="bullet"> 
            <item> <c>file:file</c> and <c>dotnetfile:file</c> implemented by a FileStream.</item>
            <item> <c>rs:file</c> or <c>rs:assembly.filename//file </c> tries to find the provided file name in the manifest
                and returns (if possible) a stream over the data of a resource file. Source assembly <c>assembly.filename</c> will be loaded by
                Assembly.LoadFile(). If the source assembly is omitted,
                this will refer to the entry assembly. You may also use the long protocol name <c>resource:file</c>.</item>
            <item> <c>zrs:archivefile//resourcefile</c> loads resource <c>resourcefile</c> from
                the ZRS archive <c>archivefile</c> (refer to class ZipResource). Long protocol name
                <c>zipresource:archivefile//resourcefile</c> also works.
            </item>
            </list>
            </summary>>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.#ctor">
            <summary>Creates a file system handler providing the ability to deal with the following protocols:
            <list type="bullet"> 
            <item> <c>file:file</c> and <c>dotnetfile:file</c> implemented by a FileStream.</item>
            <item> <c>rs:file</c> or <c>rs:assembly.filename//file </c> tries to find the provided file name in the manifest
                and returns (if possible) a stream over the data of a resource file. Source assembly <c>assembly.filename</c> will be loaded by
                Assembly.LoadFile(). If the source assembly is omitted,
                this will refer to the entry assembly. You may also use the long protocol name <c>resource:file</c>.</item>
            <item> <c>zrs:archivefile//resourcefile</c> loads resource <c>resourcefile</c> from
                the ZRS archive <c>archivefile</c> (refer to class ZipResource). Long protocol name
                <c>zipresource:archivefile//resourcefile</c> also works.
            </item>
            </list>
            </summary>>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.GetFirstFilename(System.String)">
            <summary>Returns the primary file.
            First and second file names complete standard  wxWidgets elements of
            file system names (protocol, left location, right location, anchor).
            Both filenames are subelements of the right location spanning over the filename
            right from the protocol and left from the (optional) anchor.
            If this filename contains a double slash (//), the filename left from this separator
            is called first filename and the filename on the right is called second filename.
            The first name is optional (i.e. is empty if the whole file name is without
            a double slash).
            </summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.DoFindFirst(System.IntPtr,wx.FileSys.KindOfFile)">
            <summary>Currently not supported.</summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.DoFindNext">
            <summary>Currently not supported.</summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.OpenFile(wx.FileSys.FileSystem,System.String)">
            <summary>Returns an instance of FSFile that provides a stream over the data as denoted by <c>location</c>.
             \param location absolute location of the desired data.
             \param fs is the parent file system.
             The manual 2.6.3. refers to <c>wxZipFSHandler</c> as a reference for using this parameter but this
             class in the meanwhile explicitely refers to a freshly created file system to avoid infinite recursions
             (as the remark says). I found out that this parameter contains the path.
            </summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.CanOpen(System.String)">
            <summary>The handler identifies himself with result <c>true</c> to be appropriate to deal with a file at the provided location.
             
            </summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.FindFirst(System.String,wx.FileSys.KindOfFile)">
            <summary>Returns the first matching filename or an empty string if nothing matches.
             This will only be called if the <c>wildcard</c> can be opened (CanOpen()).
            </summary>
        </member>
        <member name="M:wx.FileSys.IOStreamFSHandler.FindNext">
            <summary>Returns the next filename matching with the constraints of the previous FindFirst() or an empty string if nothing matches.
            </summary>
        </member>
        <member name="T:wx.wxString">
            <summary>Wrapper for the  wxWidgets string class <c>wxString</c>.</summary>
             <remarks>
             Objectives: 
             \li Several <c>wx.NET</c> implementations interchange string data with the used  wxWidgets library.
                 Conversion from .NET strings to  wxWidgets strings shall be hidden. .NET implementations shall
                 be able to use something like a lazy conversion: Simply getting a string from one method of
                  wxWidgets and sending it to another shall be possible without conversion to .NET strings.
             \li  wxWidgets class might be compiled in Unicode or ANSI mode. This shall be hidden completely to
                 the <c>wx.NET</c> implementation.
            
             The changed implementation follows the guidelines of the  wxWidgets manual for implementations.
             The internal character encoding within the .NET framework is uniquely defined to UTF 16.
             The used constructors and selectors use an explicit conversion as argument (on the <c>wx-c</c> side)
             to convert from or to this encoding. So, the interface provided by <c>wx-c</c> is always UTF 16 whether
             the library is able to represent such strings internally or not.
             An <c>MarshalAsAttribute</c> is used to define a more verbatim marshalling scheme on DLL import.
            
             So, any kind of conversion is done by  wxWidgets (if necessary) and not by the .NET framework.
             
             Refer to wxWCharBuffer and DisposableStringBox for remarks on helper classes for dealing with strings.
              </remarks>
        </member>
        <member name="M:wx.wxString.SafeNew(System.String)">
            <summary>This will safely create an instance of wx.wxString without throwing exceptions on argument <c>null</c>.
            Instead the method will return result <c>null</c> on argument <c>null</c>.
            </summary>
        </member>
        <member name="M:wx.wxString.ToString">
            <summary>Conversion of <c>wxString</c> into a string.
             This method works different on Unicode- and ANSI-builds of  wxWidgets.
             On Unicode builds we can directly refer to the internal buffer using
             the indexer of this class. Otherwise we read a wxWCharBuffer and convert this.
            
             Special case: PNET with internal UTF8 character encoding if <c>WXNET_INTERNAL_USE_UTF8</c>.
             In this case, we always have to decode.
            </summary>
        </member>
        <member name="P:wx.wxString.Item(System.Int32)">
            <summary>Get the n-th character.
            Returns a 2 byte UTF16 character. Only <c>get</c> implemented.
            Undefined positions will result in a 0.
            This works perfect on a Unicode build (ReflectConfig.CheckUseUnicode)
            since internal characer encoding of <c>wxString</c> is the same as the encoding
            in C#. On ANSI builds this will return blanks as replacemetns of non-ascii
            characters.
            
            Correction: Microsoft and Mono use UTF16 as internal string representation just
            like <c>wxWidgets</c> with wide character Unicode support compiled in. However, PNET
            seems to use UTF 8 instead. If this assumes internal UTF 8 strings, this method
            will return ASCII only.</summary>
        </member>
        <member name="P:wx.wxString.Length">
            <summary>Returns the length of the encapsulated string.</summary>
        </member>
        <member name="T:wx.wxWCharBuffer">
            <summary>This is a wrapper for the  wxWidgets class of the same type.
             This class is required for interchanging strings with ANSI builds of  wxWidgets.
             In such situations, we have to request the <c>wxString</c>, that internally holds an
             ANSI representation, into a wide character UTF-16 string buffer.
            </summary>
        </member>
        <member name="M:wx.wxWCharBuffer.ToString">
            <summary>Conversion into a string.
            Copies character by character into a .NET string.</summary>
        </member>
        <member name="T:wx.DisposableStringBox">
            <summary>This is a box for instances of wxString that calls wxString.Dispose() on deletion of the box and deletes the string instance.
            Use this class to pass instances of wxString from C# callbacks implementing virtual methods.
            Refer to <c>wx.ListCtrl.OnDoGetItemText()</c> for an example.</summary>
        </member>
        <member name="P:wx.DisposableStringBox.InstancesCount">
            <summary>This is the number of valid string instances.</summary>
        </member>
        <member name="T:wx.StyledText.StcStyleCollection">
            <summary>Parameters referring to a particular lexer.
            You may collect all style properties referring to a particular type of text within an instance
            of this type and apply this styles to a wx.StyledText.StyledTextCtrl if appropriate.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.#ctor(System.String,wx.StyledText.LexerId)">
            <summary>Creates a new set of properties.</summary>
            <param name="languageName">defines the name of the programming language. This will be used in lists to identify this style properties.</param>
            <param name="stylesForLexer"> defines the used lexer that will analyse the language.</param>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.DeactivateFor(wx.StyledText.StyledTextCtrl)">
            <summary>Deactivates this style for the provided control.
            From calling this method on, this style will not react on events sent from <c>stc</c> (e.g. for folding).
            Run this if you want to use another style in <c>stc</c> in order to avoid side-effects between both.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.Apply(wx.StyledText.StyledTextCtrl)">
            <summary>This will apply the represented settings to the provided styled text editor.
            This method activated this style i.e. all events from the <c>destination</c> will be processed.
            Do not forget do Deactivate() this if the control loads another style.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.OnFoldMarginClick(System.Object,wx.Event)">
            <summary>This will fold or unfold the clicked region.
            The sender probably is a styled text control where this configuration has been applied to.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.WriteXml(System.Xml.XmlWriter)">
            <summary>Writes all properties into <c>stc_styles</c> tag.</summary>
        </member>
        <member name="T:wx.StyledText.StcStyleCollection.TextProperties">
            <summary>Records the text properties that may be associated with styles.
            Please note, that each property might be <c>null</c> is not defined.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.TextProperties.#ctor(wx.StyledText.LexerStates,System.String)">
            <summary>Use predefined settings or derive heuristically a default text property from the state name.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.TextProperties.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.TextProperties.ReadXml(System.Xml.XmlReader)">
            <summary></summary>
        </member>
        <member name="M:wx.StyledText.StcStyleCollection.TextProperties.WriteXml(System.Xml.XmlWriter)">
            <summary>write properties into a <c>stc_textproperties</c> tag.</summary>
        </member>
        <member name="T:wx.StyledText.StcStyleConfiguration">
            <summary>Stores a full set of configurations.
            This creates a default set of styles for some programming languages and manages them.
            You may add or remove instances of StcStyleCollection as you like. This class also assigns
            styles to text files referring to their name in the file system. 
            Use instances of this class as a database of styles defining the way that text files are
            presented in a wx.StyledText.StyledTextCtrl.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleConfiguration.ForFilename(System.String)">
            <summary>Returns the styles appropriate to a file names <c>filename</c>.
            This will look for a matching suffix property of a contained style description.
            This will return the first style without suffix constraint if none of the contained
            description matches the file name.</summary>
        </member>
        <member name="M:wx.StyledText.StcStyleConfiguration.GetSchema">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="M:wx.PageSetupDialog.ShowModal">
            <summary>Shows the dialog, returning wx.Window.wxID_OK if the user pressed OK, and wx.Window.wxID_CANCEL otherwise.
            Please note, that this is not a wx.Dialog.</summary>
        </member>
        <member name="T:wx.PrintDialog">
            <summary>
            The printer dialog.
            </summary>
            <remarks>
            \image html printpreview.png
            </remarks>
        </member>
        <member name="M:wx.PrintDialog.ShowModal">
            <summary>Shows the dialog, returning wx.Window.wxID_OK if the user pressed OK, and wx.Window.wxID_CANCEL otherwise.
            Please note, that this is not a wx.Dialog.</summary>
        </member>
        <member name="T:wx.MiniFrame">
            <summary>A miniframe is a frame with a small title bar.
            It is suitable for floating toolbars that must not take up too much screen area.</summary>
        </member>
        <member name="T:wx.Log">
            <summary>Wrapper of the  wxWidgets log class.
            Refer to LogTraceListener for System.Diagnostics.Trace support.</summary>
        </member>
        <member name="F:wx.Log._enabled">
            <summary>
            The redundant managed flag that implements disabling of the protocol.
            </summary>
        </member>
        <member name="M:wx.Log.SetActiveTarget(wx.TextCtrl)">
            <summary>at the moment only TextCtrl</summary>
        </member>
        <member name="M:wx.Log.AddTraceMask(System.String)">
            <summary>Add the mask to the list of allowed masks for LogTrace().</summary>
        </member>
        <member name="M:wx.Log.RemoveTraceMask(System.String)">
            <summary>Remove the mask from the list of allowed masks for LogTrace().
            See also: AddTraceMask().</summary>
        </member>
        <member name="M:wx.Log.IsAllowedTraceMask(System.String)">
            <summary>True if mask <c>tmask</c> is in TraceMasks().
            This means that output with this mask will be logged.</summary>
        </member>
        <member name="M:wx.Log.LogTrace(System.String,System.String,System.Object[])">
            <summary>Trace functions only do something in debug build and expand to nothing in the release one.
            The reason for making it a separate function from it is that usually there are a lot of trace
            messages, so it might make sense to separate them from other debug messages.
            
            For the second function (taking a string mask), the message is logged only if the mask has been previously enabled by the call to AddTraceMask or by setting WXTRACE environment variable. The predefined string trace masks used by wxWidgets are:
            \li <c>wxTRACE_MemAlloc</c>: trace memory allocation (new/delete) 
            \li <c>wxTRACE_Messages</c>: trace window messages/X callbacks 
            \li <c>wxTRACE_ResAlloc</c>: trace GDI resource allocation 
            \li <c>wxTRACE_RefCount</c>: trace various ref counting operations 
            \li <c>wxTRACE_OleCalls</c>: trace OLE method calls (Win32 only)</summary>
        </member>
        <member name="P:wx.Log.IsEnabled">
            <summary>Read whether this is enabled or not and enable or disable assigning <c>true</c> or
            <c>false</c> respectively.</summary>
            <remarks>By the way - this will manage two flags for enable /diable: On in the native wxWidgets 
            implementations and one in the managed code. Goal: If logging is disabled, wx.NET will not
            even call the native DLL functions.</remarks>
        </member>
        <member name="P:wx.Log.Timestamp">
            <summary>Gets or sets the timestamp format prepended by the default log targets to all messages.
            The string may contain any normal characters as well as % prefixed
            format specificators, see strftime() manual for details.
            Passing a <c>null</c> value (not empty string) to this function disables
            message timestamping.</summary>
        </member>
        <member name="T:wx.LogTraceListener">
            <summary>This class integrates  wxWidget's Log into .NET's trace capability.
             Add an instance of this listener to the Trace and all output to the Trace log
             will also appear in listeners to  wxWidget's Log.
            </summary>
        </member>
        <member name="M:wx.LogTraceListener.#ctor">
            <summary>This will post all messages to the Trace as Log.eLogLevel.xLOGMESSAGE().
            </summary>
        </member>
        <member name="P:wx.LogTraceListener.Level">
            <summary>Returns the log level.
            </summary>
        </member>
        <member name="P:wx.CheckListBox.ItemHeight">
            <summary>Returns the item height.
            This is not supported for <c>wx.ReflectConfig.CheckWxMAC</c>.
            </summary>
        </member>
        <member name="T:wx.FindReplaceFlags">
            <summary>Flags for wx.FindReplaceData.Flags and wx.FindDialogEvent.Flags.</summary>
        </member>
        <member name="F:wx.FindReplaceFlags.NONE">
            <summary>Useful for initialization: No flag set.</summary>
        </member>
        <member name="F:wx.FindReplaceFlags.DOWN">
            <summary>Flag for the wx.FindReplaceDialog.
            downward search/replace selected (otherwise - upwards)</summary>
        </member>
        <member name="F:wx.FindReplaceFlags.WHOLEWORD">
            <summary>Flag for the wx.FindReplaceDialog.
            whole word search/replace selected</summary>
        </member>
        <member name="F:wx.FindReplaceFlags.MATCHCASE">
            <summary>Flag for the wx.FindReplaceDialog.
            case sensitive search/replace selected (otherwise - case insensitive)</summary>
        </member>
        <member name="T:wx.FindDialogEvent">
            <summary>Event issued by the wx.FindReplaceDialog to start a search process.
            Use the folloing functions to define event handlers:
            \li wx.EvtHandler.EVT_FIND() to find a first occurance of the searched string (user pressed RETURN in text field),
            \li wx.EvtHandler.EVT_FIND_NEXT() to find the next occurance of the searched string (user pressed button),
            \li wx.EvtHandler.EVT_FIND_REPLACE() to replace strings,
            \li wx.EvtHandler.EVT_FIND_REPLACE_ALL() to replace all occurances of a string,
            \li wx.EvtHandler.EVT_FIND_CLOSE() to handle the closing of the dialog.
            
            You may specify the identifier of the find dialog if you use more than one dialog of
            this type.</summary>
        </member>
        <member name="T:wx.FindReplaceData">
            <summary>Data model of the wx.FindReplaceDialog.</summary>
        </member>
        <member name="T:wx.Display">
            <summary>Use static method GetDisplay() to generate instances.
             Please note, that this method will generate at most on instance for each display.
             
             Currently, this class causes access violations with Windows.
            </summary>
        </member>
        <member name="F:wx.Display.wxNOT_FOUND">
            <summary>Symbolic constant used by all Find()-like functions returning positive
            		  * integer on success as failure indicator. While this is global in
            		  * wxWidgets it makes more sense to be in each class that uses it??? 
            		  * Or maybe move it to Window.cs.
                     *</summary>
        </member>
        <member name="M:wx.Display.GetDisplays">
            <summary>The array of all Displays indexed by display number.
            These are all instance of this class that should ever live.</summary>
        </member>
        <member name="M:wx.Display.GetDisplay(System.Int32)">
            <summary>Returns the representation of the desired display.
            \return null iff the index is too large.</summary>
        </member>
        <member name="M:wx.Display.GetModes(wx.VideoMode)">
            <summary>An array of the VideoModes that match mode.
                    * A match occurs when
            		* the resolution and depth matches and the refresh frequency in 
            		* equal to or greater than mode.RefreshFrequency.</summary>
        </member>
        <member name="M:wx.Display.GetFromWindow(wx.Window)">
            <summary>This returns the display that shows <c>window</c>.
            This will throw an exception of this is not Windows.
            </summary>
        </member>
        <member name="M:wx.ComboBox.#ctor(wx.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,System.String[],wx.WindowStyles)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:wx.ComboBox.#ctor(wx.Window,System.Int32,System.String,System.Drawing.Point,System.Drawing.Size,System.String[],wx.WindowStyles,System.String)">
            <summary>Refer to prefix <c>CB_</c> for especially applicable style flags.</summary>
        </member>
        <member name="M:wx.ComboBox.SetSelection(System.Int32,System.Int32)">
            <summary>Refer to ControlWithItems for the method receiving only one index.
            </summary>
        </member>
        <member name="M:wx.TextAttr.#ctor(wx.Colour,wx.Colour)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for the <c>colText</c> if you only want to specify the background colour.</summary>
        </member>
        <member name="M:wx.TextAttr.#ctor(wx.Colour,wx.Colour,wx.Font)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for unspecific properties.</summary>
        </member>
        <member name="M:wx.TextAttr.#ctor(wx.Colour,wx.Colour,wx.Font,wx.TextAttrAlignment)">
            <summary>Text attributes defining text and background colour.
            Use <c>null</c> for unspecific properties.</summary>
        </member>
        <member name="P:wx.TextAttr.Flags">
            <summary>Returns or sets a bitlist indicating which attributes will be set.</summary>
        </member>
        <member name="T:wx.TextAttr.Attr">
            <summary>These are the bits used in property Flags.</summary>
        </member>
        <member name="T:wx.StyledText.WhiteSpaceModes">
            <summary>Modes for displaying the white space character.</summary>
        </member>
        <member name="T:wx.StyledText.EOLModes">
            <summary>Enumeration to represent line ending mode.</summary>
        </member>
        <member name="T:wx.StyledText.CaseForce">
            <summary>Modes to enforce lower or upper case letters.</summary>
        </member>
        <member name="F:wx.StyledText.CaseForce.MIXED">
            <summary>Display letter in original case.</summary>
        </member>
        <member name="F:wx.StyledText.CaseForce.UPPER">
            <summary>Enforce upper case letters.</summary>
        </member>
        <member name="F:wx.StyledText.CaseForce.LOWER">
            <summary>Enforce lower case latters.</summary>
        </member>
        <member name="T:wx.StyledText.Mark">
            <summary>Shapes used for outlining column.
            Refer to MarkerDefine().</summary>
        </member>
        <member name="F:wx.StyledText.Mark.BACKGROUND">
            <summary>Invisible mark that only sets the line background color.</summary>
        </member>
        <member name="T:wx.StyledText.MarkNum">
            <summary>Markers used for outlining column (wrt folding).
            Refer to MarkerDefine().</summary>
        </member>
        <member name="F:wx.StyledText.MarkNum.FOLDER">
            <summary>Designates a region that can be hidden in a folder.</summary>
        </member>
        <member name="F:wx.StyledText.MarkNum.FOLDEROPEN">
            <summary></summary>
        </member>
        <member name="T:wx.StyledText.MarginMask">
            <summary>The displayed symbol when MarginType.Symbol.</summary>
        </member>
        <member name="T:wx.StyledText.MarginType">
            <summary>Type of a margin.
            Defines whether a margin shall present symbols, line numbers, etc.</summary>
        </member>
        <member name="T:wx.StyledText.LexerId">
            <summary> For SciLexer.h: specifying lexer implementations.
            These are the available lexicographic analysis methods as provided by the used Scintilla implementation.</summary> 
        </member>
        <member name="T:wx.StyledText.Keywords">
            <summary>This is an enumeration of designatros for keyword sets.
            Keyword sets are parameters to some LexerStates.</summary>
        </member>
        <member name="T:wx.StyledText.LexerStates">
            <summary>These are the lexicographic states that will be assigned by the Scintilla lexers (refer to LexerId).
            Styles in range 32..37 are predefined for parts of the UI and are not used as normal styles.
            Styles 38 and 39 are for future use. Styles up to 127 may be used.
            
            Some style are defined w.r.t. sets of keywords.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.LAST_PREDEFINED">
            <summary>First definitley unused style index.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.DEFAULT">
            <summary> General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.LINENUMBER">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.BRACELIGHT">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.BRACEBAD">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.CONTROLCHAR">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.INDENTGUIDE">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.CALLTIP">
            <summary>General styles for any lexer.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_DEFAULT">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_COMMENTLINE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_NUMBER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_STRING">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_CHARACTER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_WORD">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.
            
            Uses keyword list Keywords.PY_WORD.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_TRIPLE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_TRIPLEDOUBLE">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_CLASSNAME">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_DEFNAME">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.
            
            Uses Keywords.PY_DEFNAME.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_OPERATOR">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_IDENTIFIER">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_COMMENTBLOCK">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.PY_STRINGEOL">
            <summary>Lexical state for wx.StyledText.LexerId.PYTHON.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_DEFAULT">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENT">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENTLINE">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENTDOC">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_NUMBER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_WORD">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            Uses Keywords.C_WORD.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_STRING">
            <summary>Lexical state for SCLEX_CPP
             Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            </summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_CHARACTER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_UUID">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_PREPROCESSOR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_OPERATOR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_IDENTIFIER">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_STRINGEOL">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_VERBATIM">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_REGEX">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENTLINEDOC">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_WORD2">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            This will use Keywords.C_WORD2.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENTDOCKEYWORD">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.
            
            This style covers keyword in comments introduced by '\' or '@'. Typically, these
            are keywords referring to common document extractors like <c>doxygen</c> or <c>javadoc</c>.
            
            This will use Keywords.C_COMMENTDOCKEYWORD.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.C_COMMENTDOCKEYWORDERROR">
            <summary>Lexical state for SCLEX_CPP
            Refer to wx.StyledText.LexerId.CPP and wx.StyledText.LexerId.CPPNOCASE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_DEFAULT">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_TAG">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_TAGUNKNOWN">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_ATTRIBUTE">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_ATTRIBUTEUNKNOWN">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_NUMBER">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_DOUBLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SINGLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_OTHER">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_ENTITY">
            <summary>Lexical state for wx.StyledText.LexerId.XML and wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_TAGEND">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_XMLSTART">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_XMLEND">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SCRIPT">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_ASP">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_ASPAT">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_CDATA">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_QUESTION">
            <summary>Lexical state for wx.StyledText.LexerId.XML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_VALUE">
            <summary>Lexical state for wx.StyledText.LexerId.HTML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_XCCOMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.XCODE.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_DEFAULT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_COMMAND">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_1ST_PARAM">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_DOUBLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_SIMPLESTRING">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_ERROR">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_SPECIAL">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_ENTITY">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_1ST_PARAM_COMMENT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.H_SGML_BLOCK_DEFAULT">
            <summary>Lexical state for wx.StyledText.LexerId.SGML.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJ_START">
            \name Embedded Javascript 
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_START">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_DEFAULT">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_COMMENT">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_COMMENTLINE">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_COMMENTDOC">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_NUMBER">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_WORD">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_KEYWORD">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_DOUBLESTRING">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_SINGLESTRING">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_SYMBOLS">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_STRINGEOL">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HJA_REGEX">
            <summary>ASP Javascript wx.StyledText.LexerId.ASP</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.HB_START">
            \name Embedded VBScript 
        </member>
        <member name="F:wx.StyledText.LexerStates.HBA_START">
            \name ASP VBScript 
        </member>
        <member name="F:wx.StyledText.LexerStates.HP_START">
            \name Embedded Python 
        </member>
        <member name="F:wx.StyledText.LexerStates.HPA_START">
            \name ASP Python 
        </member>
        <member name="F:wx.StyledText.LexerStates.HPHP_DEFAULT">
            \name PHP 
        </member>
        <member name="F:wx.StyledText.LexerStates.PL_DEFAULT">
            \name Lexical states for SCLEX_PERL 
        </member>
        <member name="F:wx.StyledText.LexerStates.B_DEFAULT">
            \name Lexical states for SCLEX_VB, SCLEX_VBSCRIPT 
        </member>
        <member name="F:wx.StyledText.LexerStates.PROPS_DEFAULT">
            \name Lexical states for SCLEX_PROPERTIES 
        </member>
        <member name="F:wx.StyledText.LexerStates.L_DEFAULT">
            \name Lexical states for SCLEX_LATEX 
        </member>
        <member name="F:wx.StyledText.LexerStates.LUA_DEFAULT">
            \name Lexical states for SCLEX_LUA 
        </member>
        <member name="F:wx.StyledText.LexerStates.ERR_DEFAULT">
            \name Lexical states for SCLEX_ERRORLIST 
        </member>
        <member name="F:wx.StyledText.LexerStates.BAT_DEFAULT">
            \name Lexical states for SCLEX_BATCH 
        </member>
        <member name="F:wx.StyledText.LexerStates.MAKE_DEFAULT">
            \name Lexical states for SCLEX_MAKEFILE 
        </member>
        <member name="F:wx.StyledText.LexerStates.DIFF_DEFAULT">
            \name Lexical states for SCLEX_DIFF 
        </member>
        <member name="F:wx.StyledText.LexerStates.CONF_DEFAULT">
            \name Lexical states for SCLEX_CONF (Apache Configuration Files Lexer) 
        </member>
        <member name="F:wx.StyledText.LexerStates.AVE_DEFAULT">
            \name Lexical states for SCLEX_AVE, Avenue 
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_DEFAULT">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_WORD">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_IDENTIFIER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_NUMBER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_DELIMITER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_CHARACTER">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_CHARACTEREOL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_STRING">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_STRINGEOL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_LABEL">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_COMMENTLINE">
            <summary>Lexical states for SCLEX_ADA
            Refer to wx.StyledText.LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.ADA_ILLEGAL">
            <summary>Lexical states for SCLEX_ADA
            Refer to LexerId.ADA.</summary>
        </member>
        <member name="F:wx.StyledText.LexerStates.BAAN_DEFAULT">
            \name Lexical states for SCLEX_BAAN 
        </member>
        <member name="F:wx.StyledText.LexerStates.LISP_DEFAULT">
            \name Lexical states for SCLEX_LISP 
        </member>
        <member name="F:wx.StyledText.LexerStates.EIFFEL_DEFAULT">
            \name Lexical states for SCLEX_EIFFEL and SCLEX_EIFFELKW 
        </member>
        <member name="F:wx.StyledText.LexerStates.NNCRONTAB_DEFAULT">
            \name Lexical states for SCLEX_NNCRONTAB (nnCron crontab Lexer) 
        </member>
        <member name="F:wx.StyledText.LexerStates.MATLAB_DEFAULT">
            \name Lexical states for SCLEX_MATLAB 
        </member>
        <member name="F:wx.StyledText.LexerStates.SCRIPTOL_DEFAULT">
            \name  Lexical states for SCLEX_SCRIPTOL 
        </member>
        <member name="F:wx.StyledText.LexerStates.ASM_DEFAULT">
            \name Lexical states for SCLEX_ASM 
        </member>
        <member name="F:wx.StyledText.LexerStates.F_DEFAULT">
            \name Lexical states for SCLEX_FORTRAN 
        </member>
        <member name="F:wx.StyledText.LexerStates.CSS_DEFAULT">
            \name Lexical states for SCLEX_CSS 
        </member>
        <member name="F:wx.StyledText.LexerStates.POV_DEFAULT">
            \name Lexical states for SCLEX_POV 
        </member>
        <member name="T:wx.StyledText.CharsetIdentifier">
            <summary>Character set identifiers are used in StyleSetCharacterSet.
            The values are the same as the Windows *_CHARSET values.</summary>
        </member>
        <member name="F:wx.StyledText.TheFoldFlags.FOLDFLAG_BOX">
            <summary>Draws a box around a folded or fodable region.</summary>
        </member>
        <member name="T:wx.StyledText.FoldLevel">
            <summary>The fold level describes properties of a line referring to folding.
            Refer also to StyledTextCtrl.GetFoldLevel().</summary>
        </member>
        <member name="F:wx.StyledText.FoldLevel.HEADERFLAG">
            <summary>This flag is in the fold level iff the referring line starts a foldable region.</summary>
        </member>
        <member name="F:wx.StyledText.FoldLevel.CONTRACTED">
            <summary>This is in the fold flags if this line belongs to a foldable region.</summary>
        </member>
        <member name="F:wx.StyledText.FoldLevel.BASE">
            <summary>This is the base for the number describing the folding level.</summary>
        </member>
        <member name="F:wx.StyledText.FoldLevel.NUMBERMASK">
            <summary>This is the mask for the number describing the folding level.</summary>
        </member>
        <member name="F:wx.StyledText.FoldLevel.FLAGSMASK">
            <summary>This is the mask for the flags describing the folding level.</summary>
        </member>
        <member name="T:wx.StyledText.STCCursors">
            <summary>Available cursors to be used within the edit control.</summary>
        </member>
        <member name="T:wx.StyledText.WrapModes">
            <summary>Modes for wrapping lines if they are too long to fit into the edit control.</summary>
        </member>
        <member name="T:wx.StyledText.EdgeModes">
            <summary>Use this to define the policy for</summary>
        </member>
        <member name="T:wx.StyledText.VisiblePolicies">
            <summary> Constants for use with SetVisiblePolicy(), similar to SetCaretPolicy().</summary>
        </member>
        <member name="F:wx.StyledText.CaretPolicies.SLOP">
            <summary>Caret policy, used by SetXCaretPolicy and SetYCaretPolicy.
            If CARET_SLOP is set, we can define a slop value: caretSlop.
            This value defines an unwanted zone (UZ) where the caret is... unwanted.
            This zone is defined as a number of pixels near the vertical margins,
            and as a number of lines near the horizontal margins.
            By keeping the caret away from the edges, it is seen within its context,
            so it is likely that the identifier that the caret is on can be completely seen,
            and that the current line is seen with some of the lines following it which are
            often dependent on that line.</summary>
        </member>
        <member name="F:wx.StyledText.CaretPolicies.STRICT">
            <summary>If CARET_STRICT is set, the policy is enforced... strictly.
            The caret is centred on the display if slop is not set,
            and cannot go in the UZ if slop is set.</summary>
        </member>
        <member name="F:wx.StyledText.CaretPolicies.EVEN">
            <summary>If CARET_EVEN is not set, instead of having symmetrical UZs,
            the left and bottom UZs are extended up to right and top UZs respectively.
            This way, we favour the displaying of useful information: the begining of lines,
            where most code reside, and the lines after the caret, eg. the body of a function.</summary>
        </member>
        <member name="T:wx.StyledText.StyledTextCtrl">
            <summary>Text control particularly applicable for displaying programming languages.
            This is a text control with builtin lexicographic analysis (configured by StyledTextCtrl.Lexer).
            This analysis assigns styles to particular parts of the displayed text. 
            You may assign various directives for text formatting to these styles.
            </summary>
            <remarks>
            \image html stcsample.PNG "The STC Sample Program"
            
            Purpose:
            A wxWidgets implementation of Scintilla.  This class is the
                     one meant to be used directly by wx applications.  It does not
                     derive directly from the Scintilla classes, and in fact there
                     is no mention of Scintilla classes at all in this header.
                     This class delegates all method calls and events to the
                     Scintilla objects and so forth.  This allows the use of
                     Scintilla without polluting the namespace with all the
                     classes and itentifiers from Scintilla.
            </remarks>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_CP_UTF8">
            <summary>The SC_CP_UTF8 value can be used to enter Unicode mode.
                      * This is the same value as CP_UTF8 in Windows
                     *</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_CP_DBCS">
            <summary>The SC_CP_DBCS value can be used to indicate a DBCS mode for GTK+.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_PRINT_NORMAL">
            <summary>PrintColourMode - use same colours as screen.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_PRINT_INVERTLIGHT">
            <summary>PrintColourMode - invert the light value of each style for printing.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_PRINT_BLACKONWHITE">
            <summary>PrintColourMode - force black text on white background for printing.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_PRINT_COLOURONWHITE">
            <summary>PrintColourMode - text stays coloured, but all background is forced to be white for printing.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_PRINT_COLOURONWHITEDEFAULTBG">
            <summary>PrintColourMode - only the default-background is forced to be white for printing.</summary>
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_MOD_INSERTTEXT">
            \name Notifications
            Type of modification and the action which caused the modification.
            These are defined as a bit mask to make it easy to specify which notifications are wanted.
            One bit is set from each of SC_MOD_* and SC_PERFORMED_*.
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_KEY_DOWN">
            \name Symbolic key codes and modifier flags.
            ASCII and other printable characters below 256.
            Extended keys above 300.
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_CMD_REDO">
            \name Commands that can be bound to keystrokes. 
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_CMD_HOMEWRAP">
            \name These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
            except they behave differently when word-wrap is enabled:
            They go first to the start / end of the display line, like (Home|LineEnd)Display
            The difference is that, the cursor is already at the point, it goes on to the start
            or end of the document line, as appropriate for (Home|LineEnd|VCHome)Extend.
        </member>
        <member name="F:wx.StyledText.StyledTextCtrl.wxSTC_CMD_PARADOWN">
            \name Move caret between paragraphs (delimited by empty lines) 
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.PositionFromPoint(System.Drawing.Point)">
            <summary>Position from a position.
            This apparently does currently not work. However, this might be a problem of the origin
            of the coordinates. Mouse positions do not work.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.MarkerDefine(wx.StyledText.MarkNum,wx.StyledText.Mark)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.MarkerDefine(wx.StyledText.MarkNum,wx.StyledText.Mark,wx.Colour)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.
            \param foreground is the foreground colour to be used to draw the marker symbol
            \param background is the background colour to be used to draw the marker symbol</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.MarkerDefine(wx.StyledText.MarkNum,wx.StyledText.Mark,wx.Colour,wx.Colour)">
            <summary>Defines a symbol for the designated marker.
            \param markerNumber designates a particular marker that is used by this control to display some information.
            \param markerSymbol is the index of a symbol that shall be used to display the marker.
            \param foreground is the foreground colour to be used to draw the marker symbol
            \param background is the background colour to be used to draw the marker symbol</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetMarginType(System.Int32,wx.StyledText.MarginType)">
            <summary>Set a margin to be either numeric or symbolic.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetMarginWidth(System.Int32,System.Int32)">
            <summary>Defines margin of the specified type in pixels.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetMarginMask(System.Int32,wx.StyledText.MarginMask)">
            <summary>Set a mask that determines which markers are displayed in a margin.
            Users of this control mey define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetMarginSensitive(System.Int32,System.Boolean)">
            <summary>Make a margin sensitive or insensitive to mouse clicks.
            Users of this control may define a number of margins that may display symbols or line numbers etc.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetMarginSensitive(System.Int32)">
            <summary>Return <c>true</c> of the margin of the provided index is sensitive to mouse clicks.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompShow(System.Int32,System.String)">
            <summary>Display a auto-completion list.
            The lenEntered parameter indicates how many characters before
            the caret should be used to provide context.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompShow(System.Int32,wx.wxString)">
            <summary>Display a auto-completion list.
            The lenEntered parameter indicates how many characters before
            the caret should be used to provide context.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompCancel">
            <summary>Remove the auto-completion list from the screen.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompComplete">
            <summary>User has selected an item so remove the list and insert the selection.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompSelect(System.String)">
            <summary>Select the item in the auto-completion list that starts with a string.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.AutoCompSelect(wx.wxString)">
            <summary>Select the item in the auto-completion list that starts with a string.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.UserListShow(System.Int32,System.String)">
            <summary>Display a list of strings and send notification when user chooses one.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.UserListShow(System.Int32,wx.wxString)">
            <summary>Display a list of strings and send notification when user chooses one.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.CallTipShow(System.Int32,System.String)">
            <summary>Show a call tip containing a definition near position pos.
            Prerequisite: CallTipUseStyle().</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.CallTipShow(System.Int32,wx.wxString)">
            <summary>Show a call tip containing a definition near position pos.
            Prerequisite: CallTipUseStyle().</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.CallTipCancel">
            <summary>Remove the call tip from the screen.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.CallTipUseStyle(System.Int32)">
            <summary>Enable use of STYLE_CALLTIP and set call tip tab size in pixels.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetFoldLevel(System.Int32,System.Int32)">
            <summary>Sets the fold level of the designated line.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetFoldLevelFlags(System.Int32)">
            <summary>The flags in GetFoldLevel().</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetFoldLevelNumber(System.Int32)">
            <summary>Fold level number in GetFoldLevel().</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetFoldLevel(System.Int32)">
            <summary>Gets the fold level of the designated line.
             The result indicates whether this line starts a folded region or not.
             
             Refer to FoldLevel for the documentation of flags.
            </summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetFoldParent(System.Int32)">
            <summary>Returns the line that is the parent of <c>line</c> wrt folding.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetFoldExpanded(System.Int32,System.Boolean)">
            <summary>Contract or expand fold below <c>line</c> (<c>line</c> must denote header line).
            Use ToggleFold().</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetFoldExpanded(System.Int32)">
            <summary>Result indicates whether fold with header line <c>line</c> is expanded or contracted.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.ToggleFold(System.Int32)">
            <summary>Toggles fold at <c>line</c>.
            The GetFoldLevelFlags(line) must contain FoldLevel.HEADERFLAG.
            This will fold up if the fold is expanded. This will fold down otherwise.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetProperty(System.String,System.String)">
            <summary>Defines properties.</summary><remarks>
                     * Examples:
                     * \code
                            SetProperty("fold", "1");
                            SetProperty("fold.comment", "1");
                            SetProperty("fold.compact", "1");
            
                            SetProperty("fold.html", "1");
                            SetProperty("fold.htmlprep", "1");
                            SetProperty("fold.commentpy", "1");
                            SetProperty("fold.quotespy", "1");
                     \endcode
                     * </remarks>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetProperty(wx.wxString,wx.wxString)">
            <summary>Defines properties.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetKeyWords(wx.StyledText.Keywords,System.String[])">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetKeyWords(wx.StyledText.Keywords,System.String)">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords separated by a single blank character.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.SetKeyWords(wx.StyledText.Keywords,wx.wxString)">
            <summary>Defines a set of keywords of the specified type.
            This defines parameters that will be used by the lexer: a set of keywords separated by a single blank character.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.StyleSetSpec(wx.StyledText.LexerStates,System.String)">
            <summary>Extract style settings from a spec-string which is composed of one or more of the following comma separated elements:
            \li bold                    turns on bold
            \li italic                  turns on italics
            \li fore:[name or #RRGGBB]  sets the foreground colour
            \li back:[name or #RRGGBB]  sets the background colour
            \li face:[facename]         sets the font face name to use
            \li size:[num]              sets the font size in points
            \li eol                     turns on eol filling
            \li underline               turns on underlining</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.StyleSetSpec(System.Int32,System.String)">
            <summary>Extract style settings from a spec-string which is composed of one or more of the following comma separated elements:
            \li bold                    turns on bold
            \li italic                  turns on italics
            \li fore:[name or #RRGGBB]  sets the foreground colour
            \li back:[name or #RRGGBB]  sets the background colour
            \li face:[facename]         sets the font face name to use
            \li size:[num]              sets the font size in points
            \li eol                     turns on eol filling
            \li underline               turns on underlining</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.LoadFile(System.String)">
            <summary>
            Loading a file into the editor.
            Please note that loading a file is treated as an editor action.
            Loading a file will be reflected by the Undo/Redo-buffer and 
            the control shall not be readonly when loading. This, you may wish
            to set <c>ReadOnly</c> to false before loading a file and
            call <c>EmptyUndoBuffer</c> after loading.
            </summary>
            <param name="filename">The name of the loaded file.</param>
            <returns></returns>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.LoadFile(wx.wxString)">
            <summary>
            Loading a file into the editor.
            Please note that loading a file is treated as an editor action.
            Loading a file will be reflected by the Undo/Redo-buffer and 
            the control shall not be readonly when loading. This, you may wish
            to set <c>ReadOnly</c> to false before loading a file and
            call <c>EmptyUndoBuffer</c> after loading.
            </summary>
            <param name="filename">The name of the loaded file.</param>
            <returns></returns>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.StatePrefixForLexer(wx.StyledText.LexerId)">
            <summary>This will return a prefix string defining all those values of STCStyle that describe valid states of <c>lexer</c>.
            Example: LexerId.CPP and LexerId.CPPNOCASE will return {"C_"}.
            The result may be <c>null</c> if this is not supported.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetLexerStateNameAtPos(System.Int32)">
            <summary>Returns the name of the lexer at the designated position.</summary>
        </member>
        <member name="M:wx.StyledText.StyledTextCtrl.GetLexerStateName(wx.StyledText.LexerStates,wx.StyledText.LexerId)">
            <summary>This returns a name string for the lexer state <c>state</c> that refers to <c>lexer</c>.
            Problem: Lexer state are named ambigiously among different lexers.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.ViewWhiteSpace">
            <summary>Defines how to view white spaces.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompActive">
            <summary>Is there an auto-completion list visible?</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompPosStart">
            <summary>Retrieve the position of the caret when the auto-completion list was displayed.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompStops">
            <summary>Define a set of character that when typed cancel the auto-completion list.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompSeparator">
            <summary>Gets or changes the separator character in the string setting up an auto-completion list.
            Default is space but can be changed if items contain space.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompCancelAtStart">
            <summary>Should the auto-completion list be cancelled if the user backspaces to a
            position before where the box was created.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompFillUps">
            <summary>Defines a set of characters that when typed will cause the autocompletion to
            choose the selected item.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompChooseSingle">
            <summary>Should a single item auto-completion list automatically choose the item.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompIgnoreCase">
            <summary>Retrieve whether a single item auto-completion list automatically choose the item.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompAutoHide">
            <summary>Set whether case is significant when performing auto-completion searches.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompDropRestOfWord">
            <summary>Retrieve whether or not autocompletion deletes any word characters
            after the inserted text upon completion.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.AutoCompTypeSeparator">
            <summary>Retrieve the auto-completion list type-separator character.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.UseTabs">
            <summary>Indentation will only use space characters if useTabs is false, otherwise
            it will use a combination of tabs and spaces.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.Modify">
            <summary>True if this contains unsafed changes.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.Overtype">
            <summary>Read or set overtype mode (in contrast to insert mode).</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.FoldFlags">
            <summary>Defines some flags for folding.
            Do not forget to define markers in order to configure a fine looking folding capability.</summary>
        </member>
        <member name="P:wx.StyledText.StyledTextCtrl.Lexer">
            <summary>Returns or defines the used lexer.</summary>
        </member>
        <member name="E:wx.StyledText.StyledTextCtrl.Change">
            <summary>This will be raised on any kind of change.
            Use Modify() in the event handler if you want to trigger actions only if the text has been changed.</summary>
        </member>
        <member name="T:wx.MenuIDs">
            <summary>Standard menu IDs. </summary>
        </member>
        <member name="T:wx.KeyCode">
            <summary>Designators for eys on the keyboard.</summary>
        </member>
        <member name="T:wx.ShowModalResult">
            <summary>This enumerates possible results of Dialog.ShowModal.</summary>
        </member>
        <member name="F:wx.ShowModalResult.YES">
            <summary>YES button has been pressed.</summary>
        </member>
        <member name="F:wx.ShowModalResult.OK">
            <summary>OK button has been pressed.</summary>
        </member>
        <member name="F:wx.ShowModalResult.NO">
            <summary>NO button has been pressed.</summary>
        </member>
        <member name="F:wx.ShowModalResult.CANCEL">
            <summary>CANCEL button has been pressed.</summary>
        </member>
        <member name="T:wx.WindowStyles">
            <summary>These are the flags that are used in instances of Window (and inheriting classes) to configure appearance and behaviour.
            Some enumeration instances apply to only some classes of windows. 
            The same enumeration value may be used for different enumeration instances.
            This means in general that the enumeration isntances (sharing the same value)
            shall be applied to different classes of windows.
            
            Note, that flags are named similar to their origin in  wxWidgets but they do
            not necessarily bear the same name. Reason: Better navigation with IntelliSence.
            Example: You may type WindowStyles.BOR to navigate through all styles referring to
            borders.</summary>
        </member>
        <member name="F:wx.WindowStyles.NO_STYLE">
            <summary>An empty style definition.
            This may be useful for some occasions as default argument.
            It is simply an enumeration instance for zero.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_DEFAULT">
            <summary>Default border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_NONE">
            <summary>No border.
            Overriding the default behaviour of the window. Applicable to all windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_STATIC">
            <summary>Displays a border suitable for a static control.
            Applicable to all windows but effect only on machines using OS Windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_SIMPLE">
            <summary>Displays a thin border around the window.
            Applicable to all windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_RAISED">
            <summary>Displays a raised border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_SUNKEN">
            <summary>Displays a sunken border.
            Applicable to all windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_DOUBLE">
            <summary>Displays a double border.
             Mac only. Applicable to all windows.
            
             This is \b deprecated. In fact, this is just another name
             of the bit representing the <c>BORDER_THEME</c>.
             </summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_THEME">
            <summary>Starting with wxWidgets 2.8.5, you can specify the <c>BORDER_THEME</c> style to have  wxWidgets use a themed border.
             Using the default XP theme, this is a thin 1-pixel blue border, with an extra 1-pixel border in the window
             client background colour (usually white) to separate the client area's scrollbars from the border.
            
             If you don't specify a border style for a wxTextCtrl in rich edit mode,  wxWidgets now gives the control themed
             borders automatically, where previously they would take the Windows 95-style sunken border. Other native controls
             such as <c>wx.TextCtrl</c> in non-rich edit mode, and wxComboBox, already paint themed borders where appropriate.
             To use themed borders on other windows, such as <c>wx.Panel</c>, pass the <c>BORDER_THEME</c> style.
            
             Note that in  wxWidgets 2.9 and above, <c>BORDER_THEME</c> will be used on all platforms to indicate that there
             should definitely be a border, whose style is determined by  wxWidgets for the current platform.
              wxWidgets  2.9 and above will also be better at determining whether there should be a themed border.
             Because of the requirements of binary compatibility, this automatic border capability could not be put into
              wxWidgets 2.8 except for built-in, native controls. In 2.8, the border must be specified for custom controls
             and windows.
             </summary>
        </member>
        <member name="F:wx.WindowStyles.BORDER_MASK">
            <summary>All bits defining the border of the window.</summary>
        </member>
        <member name="F:wx.WindowStyles.TAB_TRAVERSAL">
            <summary>Use this to enable tab traversal for non-dialog windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.NO_FULL_REPAINT_ON_RESIZE">
            <summary>Now obsolete.
            On Windows, this style used to disable repainting the window completely
            when its size is changed. Since this behaviour is now the default,
            the style is now obsolete and no longer has an effect.</summary>
        </member>
        <member name="F:wx.WindowStyles.FULL_REPAINT_ON_RESIZE">
            <summary>Use this style to force a complete redraw of the window whenever it is resized instead of redrawing just the part of the window affected by resizing.
            Note that this was the behaviour by default before 2.5.1 release and
            that if you experience redraw problems with code which previously used
            to work you may want to try this.
            Currently this style applies on GTK+ 2 and Windows only, and full
            repainting is always done on other platforms.</summary>
        </member>
        <member name="F:wx.WindowStyles.WANTS_CHARS">
            <summary>Use this to indicate that the window wants to get all char/key events for all keys - even for keys like TAB or ENTER which are usually used for dialog navigation and which wouldn't be generated without this style.
            If you need to use this style in order to get the arrows or etc., but
            would still like to have normal keyboard navigation take place, you
            should create and send a NavigationKeyEvent in response to the key events for Tab and Shift-Tab.</summary>
        </member>
        <member name="F:wx.WindowStyles.VSCROLL">
            <summary>Use this style to enable a vertical scrollbar.</summary>
        </member>
        <member name="F:wx.WindowStyles.HSCROLL">
            <summary>Use this style to enable a horizontal scrollbar.</summary>
        </member>
        <member name="F:wx.WindowStyles.ALWAYS_SHOW_SB">
            <summary>If a window has scrollbars, disable them instead of hiding them when they are not needed (i.e. when the size of the window is big enough to not require the scrollbars to navigate it).
            This style is currently only implemented for <c>wxMSW</c> and <c>wxUniversal</c>
            and does nothing on the other platforms.</summary>
        </member>
        <member name="F:wx.WindowStyles.CLIP_CHILDREN">
            <summary>Use this style to eliminate flicker caused by the background being repainted, then children being painted over them.
            Windows only.</summary>
        </member>
        <member name="F:wx.WindowStyles.TRANSPARENT_WINDOW">
            <summary>The window is transparent, that is, it will not receive paint events.
            Windows only.</summary>
        </member>
        <member name="F:wx.WindowStyles.POPUP_WINDOW">
            <summary>Set this flag to create a special popup window:
            it will be always shown on top of other windows, will capture the mouse
            and will be dismissed when the mouse is clicked outside of it or if it
            loses focus in any other way.</summary>
        </member>
        <member name="F:wx.WindowStyles.WINDOW_STYLE_MASK">
            <summary>A mask which can be used to filter (out) all wxWindow-specific styles.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAPTION">
            <summary>Puts a caption on the frame. 
            Applicable to instances of Frame.</summary>
        </member>
        <member name="F:wx.WindowStyles.FRAME_DEFAULT_STYLE">
            <summary>Comprises all those styles that apply to a frame by default.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_DEFAULT_STYLE">
            <summary>Comprises those styles that apply to dialogs by default.</summary>
        </member>
        <member name="F:wx.WindowStyles.MINIMIZE">
            <summary>Display the frame iconized (minimized).
            Windows only. Applicable to top level windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.MINIMIZE_BOX">
            <summary>Displays a minimize box on the frame.
            Applicable to top level windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.CLOSE_BOX">
            <summary>Displays a close box on the frame.
            Applicable to top level windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.STAY_ON_TOP">
            <summary>Stay on top of all other windows.
            Applicable to top level windows. Refer also to FRAME_FLOAT_ON_PARENT.</summary>
        </member>
        <member name="F:wx.WindowStyles.MAXIMIZE">
            <summary>Displays the frame maximized.
            Windows only.</summary>
        </member>
        <member name="F:wx.WindowStyles.MAXIMIZE_BOX">
            <summary>Displays a maximize box on the frame.</summary>
        </member>
        <member name="F:wx.WindowStyles.RESIZE_BORDER">
            <summary>Displays a resizeable border around the window.</summary>
        </member>
        <member name="F:wx.WindowStyles.SYSTEM_MENU">
            <summary>Displays a system menu.</summary>
        </member>
        <member name="F:wx.WindowStyles.FRAME_NO_TASKBAR">
            <summary>Creates an otherwise normal frame but it does not appear in the taskbar under Windows or GTK+
            (note that it will minimize to the desktop window under Windows
            which may seem strange to the users and thus it might be better to
            use this style only without MINIMIZE_BOX style). In <c>wxGTK</c>, the
            flag is respected only if GTK+ is at least version 2.2 and the
            window manager supports <c>_NET_WM_STATE_SKIP_TASKBAR</c> hint. Has no
            effect under other platforms.</summary>
        </member>
        <member name="F:wx.WindowStyles.FRAME_TOOL_WINDOW">
            <summary>Causes a frame with a small titlebar to be created;
            the frame does not appear in the taskbar under Windows or GTK+.</summary>
        </member>
        <member name="F:wx.WindowStyles.FRAME_FLOAT_ON_PARENT">
            <summary>The frame will always be on top of its parent (unlike STAY_ON_TOP).
            A frame created with this style must have a non-NULL parent.</summary>
        </member>
        <member name="F:wx.WindowStyles.FRAME_SHAPED">
            <summary>Windows with this style are allowed to have their shape changed with the SetShape method.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_NO_PARENT">
            <summary>By default, a dialog created with a <c>null</c> parent window will be given the application's top level window as parent.
            Use this style to prevent this from happening and create an orphan
            dialog. This is not recommended for modal dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_YES">
            <summary>Show an YES button.
            This shall be used together either with DIALOG_NO or DIALOG_CANCEL.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_OK">
            <summary>Show an OK button.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_NO">
            <summary>Show an NO button.
            This shall be used together either with DIALOG_YES.
            There is a wxWidgets assertion.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_CANCEL">
            <summary>Show an CANCEL button.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_YES_NO">
            <summary>Show YES and NO button.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_YES_DEFAULT">
            <summary>Used with <c>DIALOG_YES</c>, makes YES button the default - which is the default behaviour.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_NO_DEFAULT">
            <summary>Used with <c>DIALOG_NO</c>, makes NO button the default.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_CENTRE">
            <summary>Centre the message.
            Applicable to message dialog and certain standard dialogs.
            Not Windows.</summary>
        </member>
        <member name="F:wx.WindowStyles.DIALOG_CENTER">
            <summary>Refer to DIALOG_CENTRE().</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_EXCLAMATION">
            <summary>Shows an exclamation mark icon.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_HAND">
            <summary>Shows an error icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_WARNING">
            <summary>Shows an exclamation mark icon.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_ERROR">
            <summary>Shows an error icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_QUESTION">
            <summary>Shows a question mark icon. 
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_INFORMATION">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_STOP">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_ASTERISK">
            <summary>An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.ICON_MASK">
            <summary>A bit mask for filtering those styles referring to icons.
            An icon for some standard dialogs.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_NO_VSCROLL">
            <summary> For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_AUTO_SCROLL">
            <summary> For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_READONLY">
            <summary>The text will not be user-editable. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_MULTILINE">
            <summary>The text control allows multiple lines. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_PROCESS_TAB">
            <summary>The control will receive <c>wxEVT_CHAR</c> events for TAB pressed - normally, TAB is used for passing to the next control in a dialog instead.
            For the control created with this style, you can still use
            Ctrl-Enter to pass to the next control from the keyboard. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_LEFT">
            <summary>The text in the control will be left-justified (default). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_CENTER">
            <summary>The text in the control will be centered (currently <c>wxMSW</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_RIGHT">
            <summary>The text in the control will be right-justified (currently wxMSW and wxGTK2 only). 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_RICH">
            <summary>Use rich text control under Win32, this allows to have more than 64KB of text in the control even under Win9x.
            This style is ignored under other platforms. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_PROCESS_ENTER">
            <summary>The control will generate the event <c>wxEVT_COMMAND_TEXT_ENTER</c>
            (otherwise pressing Enter key is either processed internally by
            the control or used for navigation between dialog controls). 
            For instances of wx.TextCtrl, wx.ComboCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_PASSWORD">
            <summary>The text will be echoed as asterisks. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_AUTO_URL">
            <summary>Highlight the URLs and generate the TextUrlEvents when mouse events occur over them.
            This style is only supported for <c>TE_RICH</c> Win32 and multi-line
            <c>wxGTK2</c> text controls. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_NOHIDESEL">
            <summary>Show selection even if not focussed.
            By default, the Windows text control doesn't show the selection
            when it doesn't have focus - use this style to force it to always
            show it. It doesn't do anything under other platforms. 
            For instances of wx.TextCtrtl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TE_LINEWRAP">
            <summary>Tells a wx.TextCtrl to wrap lines that are too long to be displayed in the control.
            This is another name for the standard behaviour. Refer also to <c>TE_BESTWRAP</c>.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_DONTWRAP">
            <summary>Same as <c>HSCROLL</c> style: don't wrap at all, show horizontal scrollbar instead.
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_CHARWRAP">
            <summary>Wrap the lines too long to be shown entirely at any position (<c>wxUniv</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_WORDWRAP">
            <summary>Wrap the lines too long to be shown entirely at word boundaries (<c>wxUniv</c> and <c>wxGTK2</c> only). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_BESTWRAP">
            <summary>Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default). 
            For instances of wx.TextCtrtl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_RICH2">
            <summary>Use rich text control version 2.0 or 3.0 under Win32.
            This style is ignored under other platforms.
            Style flag for instances of wx.TextCtrl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TE_DIALOG_STYLE">
            <summary>Default style bits for instances of wx.TextEntryDialog.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.HW_SCROLLBAR_NEVER">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.HW_SCROLLBAR_AUTO">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.HW_NO_SELECTION">
            <summary> Applicable to wx.HtmlWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_CENTRE_ON_PARENT">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_CENTRE_ON_SCREEN">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_NO_CENTRE">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_TIMEOUT">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_NO_TIMEOUT">
            <summary>A style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.SPLASH_DEFAULT">
            <summary>The bits defining the default style for wx.SplahScreen.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_SORT">
            <summary>Style for wx.ListBox.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.LB_SINGLE">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_MULTIPLE">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_EXTENDED">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_OWNERDRAW">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_NEED_SB">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_ALWAYS_SB">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_HSCROLL">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LB_INT_HEIGHT">
            <summary>Style for wx.ListBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_VRULES">
            <summary>Draws light vertical rules between columns in report mode.  
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_HRULES">
            <summary>Draws light horizontal rules between rows in report mode. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_ICON">
            <summary>Large icon view, with optional labels. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_SMALL_ICON">
            <summary>Small icon view, with optional labels. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_LIST">
            <summary>Multicolumn list view, with optional small icons.
            Columns are computed automatically, i.e. you don't set columns as in wx.WindowStyles.LC_REPORT.
            In other words, the list wraps, unlike a wx.ListBox.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_REPORT">
            <summary>Single or multicolumn report view, with optional header. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_ALIGN_TOP">
            <summary>Icons align to the top. Win32 default, Win32 only. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_ALIGN_LEFT">
            <summary>Icons align to the left. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_AUTO_ARRANGE">
            <summary>Icons arrange themselves. Win32 only.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_VIRTUAL">
            <summary>The application provides items text on demand.
            May only be used with wx.WindowsStyles.LC_REPORT. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_EDIT_LABELS">
            <summary>Labels are editable: the application will be notified when editing starts. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_NO_HEADER">
            <summary>No header in report mode. 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_NO_SORT_HEADER">
            <summary> Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_SINGLE_SEL">
            <summary>Single selection (default is multiple). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_SORT_ASCENDING">
            <summary>Sort in ascending order (must still supply a comparison callback in wx.ListCtrl.SortItems()). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_SORT_DESCENDING">
            <summary>Sort in descending order (must still supply a comparison callback in wx.ListCtrl.SortItems). 
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_MASK_TYPE">
            <summary>Mask of style bits defining the kind of presentation in instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_MASK_ALIGN">
            <summary>Mask of style bits referring to the alignment in instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.LC_MASK_SORT">
            <summary>Mask of styles referring to sorting instances of wx.ListCtrl.
            Style for wx.ListCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CHOICEDLG_STYLE">
            <summary>Default style bits for instances of wx.SingleChoiceDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.MDI_FRAME_DEFAULT_STYLE">
            <summary>Default style bits for instances of wx.MDIParentFrame.</summary>
        </member>
        <member name="F:wx.WindowStyles.ORIENT_HORIZONTAL">
            <summary> Style for wx.ToolBar, wx.ScrollBar, wx.Slider, wx.RadioBox, wx.Gauge wx.SpinCtrl and wx.SpinButton</summary>
        </member>
        <member name="F:wx.WindowStyles.ORIENT_VERTICAL">
            <summary>Style for wx.ToolBar, wx.ScrollBar, wx.Slider, wx.RadioBox, wx.Gauge wx.SpinCtrl and wx.SpinButton</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_3DBUTTONS">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_FLAT">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_DOCKABLE">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_NOICONS">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_TEXT">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_NODIVIDER">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.TB_NOALIGN">
            <summary>Style for wx.ToolBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.SW_NOBORDER">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SW_BORDER">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SW_3DSASH">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SW_3DBORDER">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SW_3D">
            <summary>Style for wx.SashWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_NOTIFY_DRAG">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_TICKS">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_AUTOTICKS">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_LABELS">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_LEFT">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_TOP">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_RIGHT">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_BOTTOM">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_BOTH">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.SL_SELRANGE">
            <summary> Style for wx.Slider.</summary>
        </member>
        <member name="F:wx.WindowStyles.RA_LEFTTORIGHT">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.RA_TOPTOBOTTOM">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.RA_SPECIFY_COLS">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.RA_SPECIFY_ROWS">
            <summary> Style for wx.RadioBox.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_ARROW_KEYS">
            <summary>The user can use arrow keys to change the value. 
            Style for wx.SpinCtrl and wx.SpinButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_WRAP">
            <summary>The value wraps at the minimum and maximum. 
            Style for wx.SpinCtrl and wx.SpinButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_3DBORDER">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for borders.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_LIVE_UPDATE">
            <summary>A style for the wx.SplitterWindow.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_3D">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for borders and sash.</summary>
        </member>
        <member name="F:wx.WindowStyles.SP_3DSASH">
            <summary>A style for the wx.SplitterWindow turning on 3D effect for the sash.
            <c>SP_3D</c> combines this with  <c>SP_3BORDER</c> to turn on both 3D effects.</summary>
        </member>
        <member name="F:wx.WindowStyles.GA_PROGRESSBAR">
            <summary> Style for wx.Gauge.</summary>
        </member>
        <member name="F:wx.WindowStyles.GA_SMOOTH">
            <summary> Style for wx.Gauge.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_SUNDAY_FIRST">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_MONDAY_FIRST">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_SHOW_HOLIDAYS">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_NO_YEAR_CHANGE">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_NO_MONTH_CHANGE">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_SEQUENTIAL_MONTH_SELECTION">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.CAL_SHOW_SURROUNDING_WEEKS">
            <summary> Style for wx.CalendarCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_CAN_ABORT">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_APP_MODAL">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_AUTO_HIDE">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_ELAPSED_TIME">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_ESTIMATED_TIME">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.PD_REMAINING_TIME">
            <summary> Style flag for wx.ProgressDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.RB_GROUP">
            <summary> Style flag for wx.RadioButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.RB_SINGLE">
            <summary> Style flag for wx.RadioButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_FIXEDWIDTH">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_TOP">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_LEFT">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_RIGHT">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_BOTTOM">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.NB_MULTILINE">
            <summary> Style flag fow wx.Notebook.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_NO_BUTTONS">
            <summary>For convenience to document that no buttons are to be drawn. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_HAS_BUTTONS">
            <summary>Use this style to show + and - buttons to the left of parent items. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_TWIST_BUTTONS">
            <summary> Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_NO_LINES">
            <summary>Use this style to hide vertical level connectors. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_LINES_AT_ROOT">
            <summary>Use this style to show lines between root nodes.
            Only applicable if <c>TR_HIDE_ROOT</c> is set and <c>TR_NO_LINES</c> is not set. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_MAC_BUTTONS">
            <summary> Deprecated style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_AQUA_BUTTONS">
            <summary> Deprecated style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_SINGLE">
            <summary> Style for wx.TreeCtrl.
            This defines single selection and is standard behaviour.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_MULTIPLE">
            <summary>Use this style to allow a range of items to be selected.
            If a second range is selected, the current range, if any, is deselected. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_EXTENDED">
            <summary>Use this style to allow disjoint items to be selected.
            (Only partially implemented; may not work in all cases.) 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_FULL_ROW_HIGHLIGHT">
            <summary>Use this style to have the background colour and the selection highlight extend over the entire horizontal row of the tree control window.
            (This flag is ignored under Windows unless you specify <c>TR_NO_LINES</c> as well.) 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_EDIT_LABELS">
            <summary>Use this style if you wish the user to be able to edit labels in the tree control. 
             Style for wx.TreeCtrl.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.TR_ROW_LINES">
            <summary>Use this style to draw a contrasting border between displayed rows. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_HIDE_ROOT">
            <summary>Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes. 
            Style for wx.TreeCtrl.</summary>
        </member>
        <member name="F:wx.WindowStyles.TR_HAS_VARIABLE_ROW_HEIGHT">
            <summary>Use this style to cause row heights to be just big enough to fit the content.
            If not set, all rows use the largest row height.
            Style for wx.TreeCtrl. The default is that this flag is unset. Generic only.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_POINT_SIZE">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for point size.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_FONT_FAMILY">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font family.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_FONT_WEIGHT">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font weight.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_FONT_STYLE">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for font style.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_FONT_COLOUR">
            <summary>Style for wx.FontCtrl.
            Turns on text edit field for text colour.</summary>
        </member>
        <member name="F:wx.WindowStyles.FONTCTRL_EDIT_ALL">
            <summary>Style for wx.FontCtrl.
            Turns on all edit fields.</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_OPEN">
            <summary>This is a dialog requesting a file to be opened.
            Style for wx.FileDialog and wx.FileSelector</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_SAVE">
            <summary>This is a save dialog. 
            Style for wx.FileDialog and wx.FileSelector</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_OVERWRITE_PROMPT">
            <summary>For save dialog only: prompt for a confirmation if a file will be overwritten. 
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_HIDE_READONLY">
            <summary>Do not display the checkbox to toggle display of read-only files.
            Deprecated in 2.6; the checkbox is never shown.
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_FILE_MUST_EXIST">
            <summary>The user may only select files that actually exist. 
            Style for wx.FileDialog and wx.FileSelector.</summary>
        </member>
        <member name="F:wx.WindowStyles.FD_MULTIPLE">
            <summary>For open dialog only: allows selecting multiple files. 
            Style for wx.FileDialog and wx.FileSelector.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.FD_PREVIEW">
            <summary>
            Show the preview of the selected files (currently only supported by wxGTK using GTK+ 2.4 or later). 
            Style for wx.FileDialog and wx.FileSelector.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.FD_CHANGE_DIR">
            <summary>Two different meanings in wx.FileDialog and wx.FileSeletor.
            <list type="table">
            <item><term>wx.FileDialog</term><description> Change the current working directory to the directory where the file(s) chosen by the user are.</description></item> 
            <item><term>wx.FileSelector</term><description> Select a directory rather than a file.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:wx.WindowStyles.FR_REPLACEDIALOG">
            <summary>Inititializes replace dialog (otherwise find dialog).
            Style flag for wx.FindReplaceDialog.</summary>
        </member>
        <member name="F:wx.WindowStyles.FR_NOUPDOWN">
            <summary>Don't allow changing the search direction.
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for changing search direction will be disabled.</summary>
        </member>
        <member name="F:wx.WindowStyles.FR_NOMATCHCASE">
            <summary>Don't allow case sensitive searching.
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for changing relevance of letter case will be disabled.</summary>
        </member>
        <member name="F:wx.WindowStyles.FR_NOWHOLEWORD">
            <summary>don't allow whole word searching 
            Style flag for wx.FindReplaceDialog.
            If this is set, controls for defining search for whole words only will be disabled.</summary>
        </member>
        <member name="F:wx.WindowStyles.CB_SIMPLE">
            <summary>Style for wx.Choice, wx.ComboBox etc.</summary>
        </member>
        <member name="F:wx.WindowStyles.CB_SORT">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Sorts the entries in the list alphabetically.</summary>
        </member>
        <member name="F:wx.WindowStyles.CB_READONLY">
            <summary>Style for wx.Choice, wx.ComboBox, wx.ComboCtrl etc.
            Text will not be editable.</summary>
        </member>
        <member name="F:wx.WindowStyles.CB_DROPDOWN">
            <summary>Style for wx.Choice, wx.ComboBox etc.</summary>
        </member>
        <member name="F:wx.WindowStyles.CC_BUTTON_OUTSIDE_BORDER">
            <summary>Style for wx.ComboCtrl: Button is preferred outside the border (GTK style).</summary>
        </member>
        <member name="F:wx.WindowStyles.CC_POPUP_ON_MOUSE_UP">
            <summary>Style for wx.ComboCtrl: Show popup on mouse up instead of mouse down (which is the Windows style)</summary>
        </member>
        <member name="F:wx.WindowStyles.CC_NO_TEXT_AUTO_SELECT">
            <summary>Style for wx.ComboCtrl: All text is not automatically selected on click</summary>
        </member>
        <member name="F:wx.WindowStyles.ST_NO_AUTORESIZE">
            <summary>Style flag for static text and wx.StatusBar. Static text fields also use alignment flags.</summary>
        </member>
        <member name="F:wx.WindowStyles.ST_SIZEGRIP">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.SB_NORMAL">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.SB_FLAT">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.SB_RAISED">
            <summary>Style flag for wx.StatusBar.</summary>
        </member>
        <member name="F:wx.WindowStyles.ALIGN_LEFT">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:wx.WindowStyles.ALIGN_RIGHT">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:wx.WindowStyles.ALIGN_CENTRE">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:wx.WindowStyles.ALIGN_CENTER">
            <summary>Flags for alignment are also used with wx.StaticText.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_LEFT">
            <summary>Style flag for wx.Button and wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_TOP">
            <summary>Style flag for wx.Button and wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_RIGHT">
            <summary>Style flag for wx.Button and wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_BOTTOM">
            <summary>Style flag for wx.Button and wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_EXACTFIT">
            <summary>Style flag for wx.Button and wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.BU_AUTODRAW">
            <summary>Style flag for instances of wx.BitmapButton.</summary>
        </member>
        <member name="F:wx.WindowStyles.GRID_SELECT_CELLS">
            <summary>This defines the <c>wx.GridSelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:wx.WindowStyles.GRID_SELECT_ROWS">
            <summary>This defines the <c>wx.GridSelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:wx.WindowStyles.GRID_SELECT_COLUMNS">
            <summary>This defines the <c>wx.GridSelectionMode</c> of a wx.Grid.</summary>
        </member>
        <member name="F:wx.WindowStyles.GENERICFORM_READONLY">
            <summary>Specifies that a generic form will not be user-editable. 
            wx.GenericForm.GenericFormPanel.</summary>
        </member>
        <member name="F:wx.WindowStyles.DP_DEFAULT">
            <summary>wx.DatePickerCtrl style.
            Default style on this platform, either <c>DP_SPIN</c> or <c>DP_DROPDOWN</c>.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DP_SPIN">
            <summary>wx.DatePickerCtrl style.
            A spin control-like date picker (not supported in generic version)
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DP_DROPDOWN">
            <summary>wx.DatePickerCtrl style.
            A combobox-like date picker (not supported in mac version)
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DP_SHOWCENTURY">
            <summary>wx.DatePickerCtrl style.
             Always show century in the default date display (otherwise it depends on
            the system date format which may include the century or not)
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DP_ALLOWNONE">
            <summary>wx.DatePickerCtrl style.
             Allow not having any valid date in the control (by default it always has
            some date, today initially if no valid date specified in ctor)
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CLRP_DEFAULT_STYLE">
            <summary>wx.ColourPickerCtrl style.
            The default style: 0.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CLRP_USE_TEXTCTRL">
            <summary>wx.ColourPickerCtrl style.
            Creates a text control to the left of the picker button which is completely managed by the wx.ColourPickerCtrl
            and which can be used by the user to specify a colour (see <c>SetColour</c>).
            The text control is automatically synchronized with button's value.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CLRP_SHOW_LABEL">
            <summary>wx.ColourPickerCtrl style.
            Shows the colour in HTML form (AABBCC) as colour button label (instead of no label at all).
            </summary>
        </member>
        <member name="F:wx.WindowStyles.FNTP_FONTDESC_AS_LABEL">
            <summary>wx.FontPickerCtrl style.
            Keeps the label of the button updated with the fontface name and font size.
            E.g. choosing "Times New Roman bold, italic with size 10" from the fontdialog,
            updates the button label (overwriting any previous label)
            with the "Times New Roman, 10" text (only fontface + fontsize is displayed
            to avoid extralong labels).
            </summary>
        </member>
        <member name="F:wx.WindowStyles.FNTP_USEFONT_FOR_LABEL">
            <summary>wx.FontPickerCtrl style.
            Uses the currently selected font to draw the label of the button.</summary>
        </member>
        <member name="F:wx.WindowStyles.FNTP_USE_TEXTCTRL">
            <summary>wx.FontPickerCtrl style.
            Creates a text control to the left of the picker button which is completely managed by the wx.FontPickerCtrl
            and which can be used by the user to specify a font.
            The text control is automatically synchronized with button's value.</summary>
        </member>
        <member name="F:wx.WindowStyles.FNTP_DEFAULT_STYLE">
            <summary>Default style for wx.FontPickerCtrl.
            Currently <c>FNTP_FONTDESC_AS_LABEL</c>|FNTP_USEFONT_FOR_LABEL, i.e. if <c>FNTP_USE_TEXTCTRL</c> is active,
            then use a textual description of the font as label and display it in the selected font.</summary>
        </member>
        <member name="F:wx.WindowStyles.DD_DEFAULT_STYLE">
            <summary>
            Equivalent to a combination of DEFAULT_DIALOG_STYLE and RESIZE_BORDER (the last one is not used under wxWinCE).
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DD_DIR_MUST_EXIST">
            <summary>
            The dialog will allow the user to choose only an existing folder. When this style is not given, a "Create new directory"
            button is added to the dialog (on Windows) or some other way is provided to the user to type the name of a new folder.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.DD_CHANGE_DIR">
            <summary>
            Change the current working directory to the directory chosen by the user.
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CHK_2STATE">
            <summary>
            Create a 2-state checkbox. This is the default.  
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CHK_3STATE">
            <summary>
              Create a 3-state checkbox. Not implemented in wxMGL, wxOS2 and wxGTK built against GTK+ 1.2.  
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CHK_ALLOW_3RD_STATE_FOR_USER">
            <summary>
            By default a user can't set a 3-state checkbox to the third state. It can only be done from code. Using this flags allows the user to set the checkbox to the third state by clicking.  
            </summary>
        </member>
        <member name="F:wx.WindowStyles.CHK_ALIGN_RIGHT">
            <summary>
              Makes the text appear on the left of the checkbox.  
            </summary>
        </member>
        <member name="T:wx.Direction">
            <summary>Represent a direction.
            Used to specify dynamic layouts.</summary>
        </member>
        <member name="T:wx.FillRule">
            <summary>Used to define how polygons will be filled.
            cf. wx.DC.</summary>
        </member>
        <member name="T:wx.DCBackgroundMode">
            <summary>Used to define the background mode in wx.DC.</summary>
        </member>
        <member name="T:wx.Logic">
            <summary>Operations to merge pixels for instance on blitting an image onto another.</summary>
        </member>
        <member name="T:wx.Orientation">
            <summary>Represents an orientation (e.g. of a sizer).
            </summary>
        </member>
        <member name="F:wx.Orientation.wxVERTICAL">
            <summary>
            Vertical orientation.
            </summary>
        </member>
        <member name="F:wx.Orientation.wxHORIZONTAL">
            <summary>
            Horizontal orientation.
            </summary>
        </member>
        <member name="F:wx.Orientation.wxBOTH">
            <summary>
            Both orientations, horizontal and vertical.
            </summary>
        </member>
        <member name="T:wx.Stretch">
            <summary>Stretching behaviour in dynamic layouts.
            Refer to wx.Sizer.
            </summary>
        </member>
        <member name="F:wx.Stretch.wxADJUST_MINSIZE">
            <summary>changed in wxWidgets 2.5.2, see discussion on wx-dev</summary>
        </member>
        <member name="T:wx.Alignment">
            <summary>Alignments.
            for instance in instances of wx.Sizer.
            </summary>
        </member>
        <member name="T:wx.SizerFlag">
            <summary>Flags from <c>wx.Stretch</c>, <c>wx.Direction</c> and <c>wx.Alignment</c>.
            This will be used in instances of wx.Sizer when adding new windows.
            </summary>
        </member>
        <member name="F:wx.SizerFlag.wxNo_FLAG">
            <summary>No flag at all.
            If unique, specifies default behaviour.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxLEFT">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxRIGHT">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxUP">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxDOWN">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxTOP">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxBOTTOM">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxNORTH">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxSOUTH">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxWEST">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxEAST">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALL">
            <summary>Specifies a direction as in wx.Direction.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxSTRETCH_NOT">
            <summary>This is a flag on stretching.
            Refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxSHRINK">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxGROW">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxEXPAND">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxSHAPED">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxFIXED_MINSIZE">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxTILE">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxADJUST_MINSIZE">
            <summary>This is a flag on stretching.
            refer to wx.Stretch.
            changed in wxWidgets 2.5.2, see discussion on wx-dev</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_NOT">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTER_HORIZONTAL">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_LEFT">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_TOP">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_RIGHT">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_BOTTOM">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTER_VERTICAL">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTER">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_MASK">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTRE_VERTICAL">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTRE_HORIZONTAL">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="F:wx.SizerFlag.wxALIGN_CENTRE">
            <summary>This flag is on alignment.
            Refer to wx.Alignment.</summary>
        </member>
        <member name="T:wx.MouseButton">
            <summary>Enumeration of mouse buttons.</summary>
        </member>
    </members>
</doc>
